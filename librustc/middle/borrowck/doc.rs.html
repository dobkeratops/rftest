<head><link href="../../../css/shCore.css" rel="stylesheet" type="text/css"/><link href="../../../css/shThemeDefault.css" rel="stylesheet" type="text/css"/><link href="../../../css/sourcestyle.css" rel="stylesheet" type="text/css"/></head><body><div><maintext><div><fileblock><br/>&nbsp;&nbsp;&nbsp;&nbsp;<a href="./../../../index.html">(index&lt;-&nbsp;)</a>&nbsp;&nbsp;&nbsp;&nbsp;<a href="./../../../">&nbsp;&nbsp;&nbsp;&nbsp;./</a><c0><a href="./../../../librustc/">librustc</a></c0><c1>/</c1><c0><a href="./../../../librustc/middle/">middle</a></c0><c1>/</c1><c0><a href="./../../../librustc/middle/borrowck/">borrowck</a></c0><c1>/</c1><c0><a href="./../../../librustc/middle/borrowck/doc.rs.html">doc.rs</a></c0><br/><br/><c40>&nbsp;&nbsp;&nbsp;&nbsp;git&nbsp;branch:&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;master&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5200215&nbsp;auto&nbsp;merge&nbsp;of&nbsp;#14035&nbsp;:&nbsp;alexcrichton/rust/experimental,&nbsp;r=huonw<br/></c40><c40>&nbsp;&nbsp;&nbsp;&nbsp;modified:&nbsp;&nbsp;&nbsp;&nbsp;Fri&nbsp;May&nbsp;&nbsp;9&nbsp;13:02:28&nbsp;2014<br/></c40></fileblock></div><ln>&nbsp;&nbsp;&nbsp;&nbsp;1</ln><a id="1">&nbsp;</a>&nbsp;<c40>//&nbsp;Copyright&nbsp;2012&nbsp;The&nbsp;Rust&nbsp;Project&nbsp;Developers.&nbsp;See&nbsp;the&nbsp;COPYRIGHT
</c40><br/><ln>&nbsp;&nbsp;&nbsp;&nbsp;2</ln><a id="2">&nbsp;</a>&nbsp;<c40>//&nbsp;file&nbsp;at&nbsp;the&nbsp;top-level&nbsp;directory&nbsp;of&nbsp;this&nbsp;distribution&nbsp;and&nbsp;at
</c40><br/><ln>&nbsp;&nbsp;&nbsp;&nbsp;3</ln><a id="3">&nbsp;</a>&nbsp;<c40>//&nbsp;http://rust-lang.org/COPYRIGHT.
</c40><br/><ln>&nbsp;&nbsp;&nbsp;&nbsp;4</ln><a id="4">&nbsp;</a>&nbsp;<c40>//
</c40><br/><ln>&nbsp;&nbsp;&nbsp;&nbsp;5</ln><a id="5">&nbsp;</a>&nbsp;<c40>//&nbsp;Licensed&nbsp;under&nbsp;the&nbsp;Apache&nbsp;License,&nbsp;Version&nbsp;2.0&nbsp;&lt;LICENSE-APACHE&nbsp;or
</c40><br/><ln>&nbsp;&nbsp;&nbsp;&nbsp;6</ln><a id="6">&nbsp;</a>&nbsp;<c40>//&nbsp;http://www.apache.org/licenses/LICENSE-2.0&gt;&nbsp;or&nbsp;the&nbsp;MIT&nbsp;license
</c40><br/><ln>&nbsp;&nbsp;&nbsp;&nbsp;7</ln><a id="7">&nbsp;</a>&nbsp;<c40>//&nbsp;&lt;LICENSE-MIT&nbsp;or&nbsp;http://opensource.org/licenses/MIT&gt;,&nbsp;at&nbsp;your
</c40><br/><ln>&nbsp;&nbsp;&nbsp;&nbsp;8</ln><a id="8">&nbsp;</a>&nbsp;<c40>//&nbsp;option.&nbsp;This&nbsp;file&nbsp;may&nbsp;not&nbsp;be&nbsp;copied,&nbsp;modified,&nbsp;or&nbsp;distributed
</c40><br/><ln>&nbsp;&nbsp;&nbsp;&nbsp;9</ln><a id="9">&nbsp;</a>&nbsp;<c40>//&nbsp;except&nbsp;according&nbsp;to&nbsp;those&nbsp;terms.
</c40><br/><ln>&nbsp;&nbsp;&nbsp;10</ln><a id="10">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;&nbsp;11</ln><a id="11">&nbsp;</a>&nbsp;<c41>/*!
</c41><br/><ln>&nbsp;&nbsp;&nbsp;12</ln><a id="12">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;&nbsp;13</ln><a id="13">&nbsp;</a>&nbsp;<c41>#&nbsp;The&nbsp;Borrow&nbsp;Checker
</c41><br/><ln>&nbsp;&nbsp;&nbsp;14</ln><a id="14">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;&nbsp;15</ln><a id="15">&nbsp;</a>&nbsp;<c41>This&nbsp;pass&nbsp;has&nbsp;the&nbsp;job&nbsp;of&nbsp;enforcing&nbsp;memory&nbsp;safety.&nbsp;This&nbsp;is&nbsp;a&nbsp;subtle
</c41><br/><ln>&nbsp;&nbsp;&nbsp;16</ln><a id="16">&nbsp;</a>&nbsp;<c41>topic.&nbsp;This&nbsp;docs&nbsp;aim&nbsp;to&nbsp;explain&nbsp;both&nbsp;the&nbsp;practice&nbsp;and&nbsp;the&nbsp;theory
</c41><br/><ln>&nbsp;&nbsp;&nbsp;17</ln><a id="17">&nbsp;</a>&nbsp;<c41>behind&nbsp;the&nbsp;borrow&nbsp;checker.&nbsp;They&nbsp;start&nbsp;with&nbsp;a&nbsp;high-level&nbsp;overview&nbsp;of
</c41><br/><ln>&nbsp;&nbsp;&nbsp;18</ln><a id="18">&nbsp;</a>&nbsp;<c41>how&nbsp;it&nbsp;works,&nbsp;and&nbsp;then&nbsp;proceed&nbsp;to&nbsp;dive&nbsp;into&nbsp;the&nbsp;theoretical
</c41><br/><ln>&nbsp;&nbsp;&nbsp;19</ln><a id="19">&nbsp;</a>&nbsp;<c41>background.&nbsp;Finally,&nbsp;they&nbsp;go&nbsp;into&nbsp;detail&nbsp;on&nbsp;some&nbsp;of&nbsp;the&nbsp;more&nbsp;subtle
</c41><br/><ln>&nbsp;&nbsp;&nbsp;20</ln><a id="20">&nbsp;</a>&nbsp;<c41>aspects.
</c41><br/><ln>&nbsp;&nbsp;&nbsp;21</ln><a id="21">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;&nbsp;22</ln><a id="22">&nbsp;</a>&nbsp;<c41>#&nbsp;Table&nbsp;of&nbsp;contents
</c41><br/><ln>&nbsp;&nbsp;&nbsp;23</ln><a id="23">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;&nbsp;24</ln><a id="24">&nbsp;</a>&nbsp;<c41>These&nbsp;docs&nbsp;are&nbsp;long.&nbsp;Search&nbsp;for&nbsp;the&nbsp;section&nbsp;you&nbsp;are&nbsp;interested&nbsp;in.
</c41><br/><ln>&nbsp;&nbsp;&nbsp;25</ln><a id="25">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;&nbsp;26</ln><a id="26">&nbsp;</a>&nbsp;<c41>-&nbsp;Overview
</c41><br/><ln>&nbsp;&nbsp;&nbsp;27</ln><a id="27">&nbsp;</a>&nbsp;<c41>-&nbsp;Formal&nbsp;model
</c41><br/><ln>&nbsp;&nbsp;&nbsp;28</ln><a id="28">&nbsp;</a>&nbsp;<c41>-&nbsp;Borrowing&nbsp;and&nbsp;loans
</c41><br/><ln>&nbsp;&nbsp;&nbsp;29</ln><a id="29">&nbsp;</a>&nbsp;<c41>-&nbsp;Moves&nbsp;and&nbsp;initialization
</c41><br/><ln>&nbsp;&nbsp;&nbsp;30</ln><a id="30">&nbsp;</a>&nbsp;<c41>-&nbsp;Future&nbsp;work
</c41><br/><ln>&nbsp;&nbsp;&nbsp;31</ln><a id="31">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;&nbsp;32</ln><a id="32">&nbsp;</a>&nbsp;<c41>#&nbsp;Overview
</c41><br/><ln>&nbsp;&nbsp;&nbsp;33</ln><a id="33">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;&nbsp;34</ln><a id="34">&nbsp;</a>&nbsp;<c41>The&nbsp;borrow&nbsp;checker&nbsp;checks&nbsp;one&nbsp;function&nbsp;at&nbsp;a&nbsp;time.&nbsp;It&nbsp;operates&nbsp;in&nbsp;two
</c41><br/><ln>&nbsp;&nbsp;&nbsp;35</ln><a id="35">&nbsp;</a>&nbsp;<c41>passes.&nbsp;The&nbsp;first&nbsp;pass,&nbsp;called&nbsp;`gather_loans`,&nbsp;walks&nbsp;over&nbsp;the&nbsp;function
</c41><br/><ln>&nbsp;&nbsp;&nbsp;36</ln><a id="36">&nbsp;</a>&nbsp;<c41>and&nbsp;identifies&nbsp;all&nbsp;of&nbsp;the&nbsp;places&nbsp;where&nbsp;borrows&nbsp;(e.g.,&nbsp;`&amp;`&nbsp;expressions
</c41><br/><ln>&nbsp;&nbsp;&nbsp;37</ln><a id="37">&nbsp;</a>&nbsp;<c41>and&nbsp;`ref`&nbsp;bindings)&nbsp;and&nbsp;moves&nbsp;(copies&nbsp;or&nbsp;captures&nbsp;of&nbsp;a&nbsp;linear&nbsp;value)
</c41><br/><ln>&nbsp;&nbsp;&nbsp;38</ln><a id="38">&nbsp;</a>&nbsp;<c41>occur.&nbsp;It&nbsp;also&nbsp;tracks&nbsp;initialization&nbsp;sites.&nbsp;For&nbsp;each&nbsp;borrow&nbsp;and&nbsp;move,
</c41><br/><ln>&nbsp;&nbsp;&nbsp;39</ln><a id="39">&nbsp;</a>&nbsp;<c41>it&nbsp;checks&nbsp;various&nbsp;basic&nbsp;safety&nbsp;conditions&nbsp;at&nbsp;this&nbsp;time&nbsp;(for&nbsp;example,
</c41><br/><ln>&nbsp;&nbsp;&nbsp;40</ln><a id="40">&nbsp;</a>&nbsp;<c41>that&nbsp;the&nbsp;lifetime&nbsp;of&nbsp;the&nbsp;borrow&nbsp;doesn't&nbsp;exceed&nbsp;the&nbsp;lifetime&nbsp;of&nbsp;the
</c41><br/><ln>&nbsp;&nbsp;&nbsp;41</ln><a id="41">&nbsp;</a>&nbsp;<c41>value&nbsp;being&nbsp;borrowed,&nbsp;or&nbsp;that&nbsp;there&nbsp;is&nbsp;no&nbsp;move&nbsp;out&nbsp;of&nbsp;an&nbsp;`&amp;T`
</c41><br/><ln>&nbsp;&nbsp;&nbsp;42</ln><a id="42">&nbsp;</a>&nbsp;<c41>referent).
</c41><br/><ln>&nbsp;&nbsp;&nbsp;43</ln><a id="43">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;&nbsp;44</ln><a id="44">&nbsp;</a>&nbsp;<c41>It&nbsp;then&nbsp;uses&nbsp;the&nbsp;dataflow&nbsp;module&nbsp;to&nbsp;propagate&nbsp;which&nbsp;of&nbsp;those&nbsp;borrows
</c41><br/><ln>&nbsp;&nbsp;&nbsp;45</ln><a id="45">&nbsp;</a>&nbsp;<c41>may&nbsp;be&nbsp;in&nbsp;scope&nbsp;at&nbsp;each&nbsp;point&nbsp;in&nbsp;the&nbsp;procedure.&nbsp;A&nbsp;loan&nbsp;is&nbsp;considered
</c41><br/><ln>&nbsp;&nbsp;&nbsp;46</ln><a id="46">&nbsp;</a>&nbsp;<c41>to&nbsp;come&nbsp;into&nbsp;scope&nbsp;at&nbsp;the&nbsp;expression&nbsp;that&nbsp;caused&nbsp;it&nbsp;and&nbsp;to&nbsp;go&nbsp;out&nbsp;of
</c41><br/><ln>&nbsp;&nbsp;&nbsp;47</ln><a id="47">&nbsp;</a>&nbsp;<c41>scope&nbsp;when&nbsp;the&nbsp;lifetime&nbsp;of&nbsp;the&nbsp;resulting&nbsp;reference&nbsp;expires.
</c41><br/><ln>&nbsp;&nbsp;&nbsp;48</ln><a id="48">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;&nbsp;49</ln><a id="49">&nbsp;</a>&nbsp;<c41>Once&nbsp;the&nbsp;in-scope&nbsp;loans&nbsp;are&nbsp;known&nbsp;for&nbsp;each&nbsp;point&nbsp;in&nbsp;the&nbsp;program,&nbsp;the
</c41><br/><ln>&nbsp;&nbsp;&nbsp;50</ln><a id="50">&nbsp;</a>&nbsp;<c41>borrow&nbsp;checker&nbsp;walks&nbsp;the&nbsp;IR&nbsp;again&nbsp;in&nbsp;a&nbsp;second&nbsp;pass&nbsp;called
</c41><br/><ln>&nbsp;&nbsp;&nbsp;51</ln><a id="51">&nbsp;</a>&nbsp;<c41>`check_loans`.&nbsp;This&nbsp;pass&nbsp;examines&nbsp;each&nbsp;statement&nbsp;and&nbsp;makes&nbsp;sure&nbsp;that
</c41><br/><ln>&nbsp;&nbsp;&nbsp;52</ln><a id="52">&nbsp;</a>&nbsp;<c41>it&nbsp;is&nbsp;safe&nbsp;with&nbsp;respect&nbsp;to&nbsp;the&nbsp;in-scope&nbsp;loans.
</c41><br/><ln>&nbsp;&nbsp;&nbsp;53</ln><a id="53">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;&nbsp;54</ln><a id="54">&nbsp;</a>&nbsp;<c41>#&nbsp;Formal&nbsp;model
</c41><br/><ln>&nbsp;&nbsp;&nbsp;55</ln><a id="55">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;&nbsp;56</ln><a id="56">&nbsp;</a>&nbsp;<c41>Throughout&nbsp;the&nbsp;docs&nbsp;we'll&nbsp;consider&nbsp;a&nbsp;simple&nbsp;subset&nbsp;of&nbsp;Rust&nbsp;in&nbsp;which
</c41><br/><ln>&nbsp;&nbsp;&nbsp;57</ln><a id="57">&nbsp;</a>&nbsp;<c41>you&nbsp;can&nbsp;only&nbsp;borrow&nbsp;from&nbsp;lvalues,&nbsp;defined&nbsp;like&nbsp;so:
</c41><br/><ln>&nbsp;&nbsp;&nbsp;58</ln><a id="58">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;&nbsp;59</ln><a id="59">&nbsp;</a>&nbsp;<c41>```notrust
</c41><br/><ln>&nbsp;&nbsp;&nbsp;60</ln><a id="60">&nbsp;</a>&nbsp;<c41>LV&nbsp;=&nbsp;x&nbsp;|&nbsp;LV.f&nbsp;|&nbsp;*LV
</c41><br/><ln>&nbsp;&nbsp;&nbsp;61</ln><a id="61">&nbsp;</a>&nbsp;<c41>```
</c41><br/><ln>&nbsp;&nbsp;&nbsp;62</ln><a id="62">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;&nbsp;63</ln><a id="63">&nbsp;</a>&nbsp;<c41>Here&nbsp;`x`&nbsp;represents&nbsp;some&nbsp;variable,&nbsp;`LV.f`&nbsp;is&nbsp;a&nbsp;field&nbsp;reference,
</c41><br/><ln>&nbsp;&nbsp;&nbsp;64</ln><a id="64">&nbsp;</a>&nbsp;<c41>and&nbsp;`*LV`&nbsp;is&nbsp;a&nbsp;pointer&nbsp;dereference.&nbsp;There&nbsp;is&nbsp;no&nbsp;auto-deref&nbsp;or&nbsp;other
</c41><br/><ln>&nbsp;&nbsp;&nbsp;65</ln><a id="65">&nbsp;</a>&nbsp;<c41>niceties.&nbsp;This&nbsp;means&nbsp;that&nbsp;if&nbsp;you&nbsp;have&nbsp;a&nbsp;type&nbsp;like:
</c41><br/><ln>&nbsp;&nbsp;&nbsp;66</ln><a id="66">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;&nbsp;67</ln><a id="67">&nbsp;</a>&nbsp;<c41>```notrust
</c41><br/><ln>&nbsp;&nbsp;&nbsp;68</ln><a id="68">&nbsp;</a>&nbsp;<c41>struct&nbsp;S&nbsp;{&nbsp;f:&nbsp;uint&nbsp;}
</c41><br/><ln>&nbsp;&nbsp;&nbsp;69</ln><a id="69">&nbsp;</a>&nbsp;<c41>```
</c41><br/><ln>&nbsp;&nbsp;&nbsp;70</ln><a id="70">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;&nbsp;71</ln><a id="71">&nbsp;</a>&nbsp;<c41>and&nbsp;a&nbsp;variable&nbsp;`a:&nbsp;Box&lt;S&gt;`,&nbsp;then&nbsp;the&nbsp;rust&nbsp;expression&nbsp;`a.f`&nbsp;would&nbsp;correspond
</c41><br/><ln>&nbsp;&nbsp;&nbsp;72</ln><a id="72">&nbsp;</a>&nbsp;<c41>to&nbsp;an&nbsp;`LV`&nbsp;of&nbsp;`(*a).f`.
</c41><br/><ln>&nbsp;&nbsp;&nbsp;73</ln><a id="73">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;&nbsp;74</ln><a id="74">&nbsp;</a>&nbsp;<c41>Here&nbsp;is&nbsp;the&nbsp;formal&nbsp;grammar&nbsp;for&nbsp;the&nbsp;types&nbsp;we'll&nbsp;consider:
</c41><br/><ln>&nbsp;&nbsp;&nbsp;75</ln><a id="75">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;&nbsp;76</ln><a id="76">&nbsp;</a>&nbsp;<c41>```notrust
</c41><br/><ln>&nbsp;&nbsp;&nbsp;77</ln><a id="77">&nbsp;</a>&nbsp;<c41>TY&nbsp;=&nbsp;()&nbsp;|&nbsp;S&lt;'LT...&gt;&nbsp;|&nbsp;Box&lt;TY&gt;&nbsp;|&nbsp;&amp;&nbsp;'LT&nbsp;MQ&nbsp;TY&nbsp;|&nbsp;@&nbsp;MQ&nbsp;TY
</c41><br/><ln>&nbsp;&nbsp;&nbsp;78</ln><a id="78">&nbsp;</a>&nbsp;<c41>MQ&nbsp;=&nbsp;mut&nbsp;|&nbsp;imm&nbsp;|&nbsp;const
</c41><br/><ln>&nbsp;&nbsp;&nbsp;79</ln><a id="79">&nbsp;</a>&nbsp;<c41>```
</c41><br/><ln>&nbsp;&nbsp;&nbsp;80</ln><a id="80">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;&nbsp;81</ln><a id="81">&nbsp;</a>&nbsp;<c41>Most&nbsp;of&nbsp;these&nbsp;types&nbsp;should&nbsp;be&nbsp;pretty&nbsp;self&nbsp;explanatory.&nbsp;Here&nbsp;`S`&nbsp;is&nbsp;a
</c41><br/><ln>&nbsp;&nbsp;&nbsp;82</ln><a id="82">&nbsp;</a>&nbsp;<c41>struct&nbsp;name&nbsp;and&nbsp;we&nbsp;assume&nbsp;structs&nbsp;are&nbsp;declared&nbsp;like&nbsp;so:
</c41><br/><ln>&nbsp;&nbsp;&nbsp;83</ln><a id="83">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;&nbsp;84</ln><a id="84">&nbsp;</a>&nbsp;<c41>```notrust
</c41><br/><ln>&nbsp;&nbsp;&nbsp;85</ln><a id="85">&nbsp;</a>&nbsp;<c41>SD&nbsp;=&nbsp;struct&nbsp;S&lt;'LT...&gt;&nbsp;{&nbsp;(f:&nbsp;TY)...&nbsp;}
</c41><br/><ln>&nbsp;&nbsp;&nbsp;86</ln><a id="86">&nbsp;</a>&nbsp;<c41>```
</c41><br/><ln>&nbsp;&nbsp;&nbsp;87</ln><a id="87">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;&nbsp;88</ln><a id="88">&nbsp;</a>&nbsp;<c41>#&nbsp;Borrowing&nbsp;and&nbsp;loans
</c41><br/><ln>&nbsp;&nbsp;&nbsp;89</ln><a id="89">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;&nbsp;90</ln><a id="90">&nbsp;</a>&nbsp;<c41>##&nbsp;An&nbsp;intuitive&nbsp;explanation
</c41><br/><ln>&nbsp;&nbsp;&nbsp;91</ln><a id="91">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;&nbsp;92</ln><a id="92">&nbsp;</a>&nbsp;<c41>###&nbsp;Issuing&nbsp;loans
</c41><br/><ln>&nbsp;&nbsp;&nbsp;93</ln><a id="93">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;&nbsp;94</ln><a id="94">&nbsp;</a>&nbsp;<c41>Now,&nbsp;imagine&nbsp;we&nbsp;had&nbsp;a&nbsp;program&nbsp;like&nbsp;this:
</c41><br/><ln>&nbsp;&nbsp;&nbsp;95</ln><a id="95">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;&nbsp;96</ln><a id="96">&nbsp;</a>&nbsp;<c41>```notrust
</c41><br/><ln>&nbsp;&nbsp;&nbsp;97</ln><a id="97">&nbsp;</a>&nbsp;<c41>struct&nbsp;Foo&nbsp;{&nbsp;f:&nbsp;uint,&nbsp;g:&nbsp;uint&nbsp;}
</c41><br/><ln>&nbsp;&nbsp;&nbsp;98</ln><a id="98">&nbsp;</a>&nbsp;<c41>...
</c41><br/><ln>&nbsp;&nbsp;&nbsp;99</ln><a id="99">&nbsp;</a>&nbsp;<c41>'a:&nbsp;{
</c41><br/><ln>&nbsp;&nbsp;100</ln><a id="100">&nbsp;</a>&nbsp;<c41>&nbsp;&nbsp;let&nbsp;mut&nbsp;x:&nbsp;Box&lt;Foo&gt;&nbsp;=&nbsp;...;
</c41><br/><ln>&nbsp;&nbsp;101</ln><a id="101">&nbsp;</a>&nbsp;<c41>&nbsp;&nbsp;let&nbsp;y&nbsp;=&nbsp;&amp;mut&nbsp;(*x).f;
</c41><br/><ln>&nbsp;&nbsp;102</ln><a id="102">&nbsp;</a>&nbsp;<c41>&nbsp;&nbsp;x&nbsp;=&nbsp;...;
</c41><br/><ln>&nbsp;&nbsp;103</ln><a id="103">&nbsp;</a>&nbsp;<c41>}
</c41><br/><ln>&nbsp;&nbsp;104</ln><a id="104">&nbsp;</a>&nbsp;<c41>```
</c41><br/><ln>&nbsp;&nbsp;105</ln><a id="105">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;106</ln><a id="106">&nbsp;</a>&nbsp;<c41>This&nbsp;is&nbsp;of&nbsp;course&nbsp;dangerous&nbsp;because&nbsp;mutating&nbsp;`x`&nbsp;will&nbsp;free&nbsp;the&nbsp;old
</c41><br/><ln>&nbsp;&nbsp;107</ln><a id="107">&nbsp;</a>&nbsp;<c41>value&nbsp;and&nbsp;hence&nbsp;invalidate&nbsp;`y`.&nbsp;The&nbsp;borrow&nbsp;checker&nbsp;aims&nbsp;to&nbsp;prevent
</c41><br/><ln>&nbsp;&nbsp;108</ln><a id="108">&nbsp;</a>&nbsp;<c41>this&nbsp;sort&nbsp;of&nbsp;thing.
</c41><br/><ln>&nbsp;&nbsp;109</ln><a id="109">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;110</ln><a id="110">&nbsp;</a>&nbsp;<c41>####&nbsp;Loans&nbsp;and&nbsp;restrictions
</c41><br/><ln>&nbsp;&nbsp;111</ln><a id="111">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;112</ln><a id="112">&nbsp;</a>&nbsp;<c41>The&nbsp;way&nbsp;the&nbsp;borrow&nbsp;checker&nbsp;works&nbsp;is&nbsp;that&nbsp;it&nbsp;analyzes&nbsp;each&nbsp;borrow
</c41><br/><ln>&nbsp;&nbsp;113</ln><a id="113">&nbsp;</a>&nbsp;<c41>expression&nbsp;(in&nbsp;our&nbsp;simple&nbsp;model,&nbsp;that's&nbsp;stuff&nbsp;like&nbsp;`&amp;LV`,&nbsp;though&nbsp;in
</c41><br/><ln>&nbsp;&nbsp;114</ln><a id="114">&nbsp;</a>&nbsp;<c41>real&nbsp;life&nbsp;there&nbsp;are&nbsp;a&nbsp;few&nbsp;other&nbsp;cases&nbsp;to&nbsp;consider).&nbsp;For&nbsp;each&nbsp;borrow
</c41><br/><ln>&nbsp;&nbsp;115</ln><a id="115">&nbsp;</a>&nbsp;<c41>expression,&nbsp;it&nbsp;computes&nbsp;a&nbsp;`Loan`,&nbsp;which&nbsp;is&nbsp;a&nbsp;data&nbsp;structure&nbsp;that
</c41><br/><ln>&nbsp;&nbsp;116</ln><a id="116">&nbsp;</a>&nbsp;<c41>records&nbsp;(1)&nbsp;the&nbsp;value&nbsp;being&nbsp;borrowed,&nbsp;(2)&nbsp;the&nbsp;mutability&nbsp;and&nbsp;scope&nbsp;of
</c41><br/><ln>&nbsp;&nbsp;117</ln><a id="117">&nbsp;</a>&nbsp;<c41>the&nbsp;borrow,&nbsp;and&nbsp;(3)&nbsp;a&nbsp;set&nbsp;of&nbsp;restrictions.&nbsp;In&nbsp;the&nbsp;code,&nbsp;`Loan`&nbsp;is&nbsp;a
</c41><br/><ln>&nbsp;&nbsp;118</ln><a id="118">&nbsp;</a>&nbsp;<c41>struct&nbsp;defined&nbsp;in&nbsp;`middle::borrowck`.&nbsp;Formally,&nbsp;we&nbsp;define&nbsp;`LOAN`&nbsp;as
</c41><br/><ln>&nbsp;&nbsp;119</ln><a id="119">&nbsp;</a>&nbsp;<c41>follows:
</c41><br/><ln>&nbsp;&nbsp;120</ln><a id="120">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;121</ln><a id="121">&nbsp;</a>&nbsp;<c41>```notrust
</c41><br/><ln>&nbsp;&nbsp;122</ln><a id="122">&nbsp;</a>&nbsp;<c41>LOAN&nbsp;=&nbsp;(LV,&nbsp;LT,&nbsp;MQ,&nbsp;RESTRICTION*)
</c41><br/><ln>&nbsp;&nbsp;123</ln><a id="123">&nbsp;</a>&nbsp;<c41>RESTRICTION&nbsp;=&nbsp;(LV,&nbsp;ACTION*)
</c41><br/><ln>&nbsp;&nbsp;124</ln><a id="124">&nbsp;</a>&nbsp;<c41>ACTION&nbsp;=&nbsp;MUTATE&nbsp;|&nbsp;CLAIM&nbsp;|&nbsp;FREEZE
</c41><br/><ln>&nbsp;&nbsp;125</ln><a id="125">&nbsp;</a>&nbsp;<c41>```
</c41><br/><ln>&nbsp;&nbsp;126</ln><a id="126">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;127</ln><a id="127">&nbsp;</a>&nbsp;<c41>Here&nbsp;the&nbsp;`LOAN`&nbsp;tuple&nbsp;defines&nbsp;the&nbsp;lvalue&nbsp;`LV`&nbsp;being&nbsp;borrowed;&nbsp;the
</c41><br/><ln>&nbsp;&nbsp;128</ln><a id="128">&nbsp;</a>&nbsp;<c41>lifetime&nbsp;`LT`&nbsp;of&nbsp;that&nbsp;borrow;&nbsp;the&nbsp;mutability&nbsp;`MQ`&nbsp;of&nbsp;the&nbsp;borrow;&nbsp;and&nbsp;a
</c41><br/><ln>&nbsp;&nbsp;129</ln><a id="129">&nbsp;</a>&nbsp;<c41>list&nbsp;of&nbsp;restrictions.&nbsp;The&nbsp;restrictions&nbsp;indicate&nbsp;actions&nbsp;which,&nbsp;if
</c41><br/><ln>&nbsp;&nbsp;130</ln><a id="130">&nbsp;</a>&nbsp;<c41>taken,&nbsp;could&nbsp;invalidate&nbsp;the&nbsp;loan&nbsp;and&nbsp;lead&nbsp;to&nbsp;type&nbsp;safety&nbsp;violations.
</c41><br/><ln>&nbsp;&nbsp;131</ln><a id="131">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;132</ln><a id="132">&nbsp;</a>&nbsp;<c41>Each&nbsp;`RESTRICTION`&nbsp;is&nbsp;a&nbsp;pair&nbsp;of&nbsp;a&nbsp;restrictive&nbsp;lvalue&nbsp;`LV`&nbsp;(which&nbsp;will
</c41><br/><ln>&nbsp;&nbsp;133</ln><a id="133">&nbsp;</a>&nbsp;<c41>either&nbsp;be&nbsp;the&nbsp;path&nbsp;that&nbsp;was&nbsp;borrowed&nbsp;or&nbsp;some&nbsp;prefix&nbsp;of&nbsp;the&nbsp;path&nbsp;that
</c41><br/><ln>&nbsp;&nbsp;134</ln><a id="134">&nbsp;</a>&nbsp;<c41>was&nbsp;borrowed)&nbsp;and&nbsp;a&nbsp;set&nbsp;of&nbsp;restricted&nbsp;actions.&nbsp;&nbsp;There&nbsp;are&nbsp;three&nbsp;kinds
</c41><br/><ln>&nbsp;&nbsp;135</ln><a id="135">&nbsp;</a>&nbsp;<c41>of&nbsp;actions&nbsp;that&nbsp;may&nbsp;be&nbsp;restricted&nbsp;for&nbsp;the&nbsp;path&nbsp;`LV`:
</c41><br/><ln>&nbsp;&nbsp;136</ln><a id="136">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;137</ln><a id="137">&nbsp;</a>&nbsp;<c41>-&nbsp;`MUTATE`&nbsp;means&nbsp;that&nbsp;`LV`&nbsp;cannot&nbsp;be&nbsp;assigned&nbsp;to;
</c41><br/><ln>&nbsp;&nbsp;138</ln><a id="138">&nbsp;</a>&nbsp;<c41>-&nbsp;`CLAIM`&nbsp;means&nbsp;that&nbsp;the&nbsp;`LV`&nbsp;cannot&nbsp;be&nbsp;borrowed&nbsp;mutably;
</c41><br/><ln>&nbsp;&nbsp;139</ln><a id="139">&nbsp;</a>&nbsp;<c41>-&nbsp;`FREEZE`&nbsp;means&nbsp;that&nbsp;the&nbsp;`LV`&nbsp;cannot&nbsp;be&nbsp;borrowed&nbsp;immutably;
</c41><br/><ln>&nbsp;&nbsp;140</ln><a id="140">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;141</ln><a id="141">&nbsp;</a>&nbsp;<c41>Finally,&nbsp;it&nbsp;is&nbsp;never&nbsp;possible&nbsp;to&nbsp;move&nbsp;from&nbsp;an&nbsp;lvalue&nbsp;that&nbsp;appears&nbsp;in&nbsp;a
</c41><br/><ln>&nbsp;&nbsp;142</ln><a id="142">&nbsp;</a>&nbsp;<c41>restriction.&nbsp;This&nbsp;implies&nbsp;that&nbsp;the&nbsp;"empty&nbsp;restriction"&nbsp;`(LV,&nbsp;[])`,
</c41><br/><ln>&nbsp;&nbsp;143</ln><a id="143">&nbsp;</a>&nbsp;<c41>which&nbsp;contains&nbsp;an&nbsp;empty&nbsp;set&nbsp;of&nbsp;actions,&nbsp;still&nbsp;has&nbsp;a&nbsp;purpose---it
</c41><br/><ln>&nbsp;&nbsp;144</ln><a id="144">&nbsp;</a>&nbsp;<c41>prevents&nbsp;moves&nbsp;from&nbsp;`LV`.&nbsp;I&nbsp;chose&nbsp;not&nbsp;to&nbsp;make&nbsp;`MOVE`&nbsp;a&nbsp;fourth&nbsp;kind&nbsp;of
</c41><br/><ln>&nbsp;&nbsp;145</ln><a id="145">&nbsp;</a>&nbsp;<c41>action&nbsp;because&nbsp;that&nbsp;would&nbsp;imply&nbsp;that&nbsp;sometimes&nbsp;moves&nbsp;are&nbsp;permitted
</c41><br/><ln>&nbsp;&nbsp;146</ln><a id="146">&nbsp;</a>&nbsp;<c41>from&nbsp;restrictived&nbsp;values,&nbsp;which&nbsp;is&nbsp;not&nbsp;the&nbsp;case.
</c41><br/><ln>&nbsp;&nbsp;147</ln><a id="147">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;148</ln><a id="148">&nbsp;</a>&nbsp;<c41>####&nbsp;Example
</c41><br/><ln>&nbsp;&nbsp;149</ln><a id="149">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;150</ln><a id="150">&nbsp;</a>&nbsp;<c41>To&nbsp;give&nbsp;you&nbsp;a&nbsp;better&nbsp;feeling&nbsp;for&nbsp;what&nbsp;kind&nbsp;of&nbsp;restrictions&nbsp;derived
</c41><br/><ln>&nbsp;&nbsp;151</ln><a id="151">&nbsp;</a>&nbsp;<c41>from&nbsp;a&nbsp;loan,&nbsp;let's&nbsp;look&nbsp;at&nbsp;the&nbsp;loan&nbsp;`L`&nbsp;that&nbsp;would&nbsp;be&nbsp;issued&nbsp;as&nbsp;a
</c41><br/><ln>&nbsp;&nbsp;152</ln><a id="152">&nbsp;</a>&nbsp;<c41>result&nbsp;of&nbsp;the&nbsp;borrow&nbsp;`&amp;mut&nbsp;(*x).f`&nbsp;in&nbsp;the&nbsp;example&nbsp;above:
</c41><br/><ln>&nbsp;&nbsp;153</ln><a id="153">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;154</ln><a id="154">&nbsp;</a>&nbsp;<c41>```notrust
</c41><br/><ln>&nbsp;&nbsp;155</ln><a id="155">&nbsp;</a>&nbsp;<c41>L&nbsp;=&nbsp;((*x).f,&nbsp;'a,&nbsp;mut,&nbsp;RS)&nbsp;where
</c41><br/><ln>&nbsp;&nbsp;156</ln><a id="156">&nbsp;</a>&nbsp;<c41>&nbsp;&nbsp;&nbsp;&nbsp;RS&nbsp;=&nbsp;[((*x).f,&nbsp;[MUTATE,&nbsp;CLAIM,&nbsp;FREEZE]),
</c41><br/><ln>&nbsp;&nbsp;157</ln><a id="157">&nbsp;</a>&nbsp;<c41>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*x,&nbsp;[MUTATE,&nbsp;CLAIM,&nbsp;FREEZE]),
</c41><br/><ln>&nbsp;&nbsp;158</ln><a id="158">&nbsp;</a>&nbsp;<c41>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(x,&nbsp;[MUTATE,&nbsp;CLAIM,&nbsp;FREEZE])]
</c41><br/><ln>&nbsp;&nbsp;159</ln><a id="159">&nbsp;</a>&nbsp;<c41>```
</c41><br/><ln>&nbsp;&nbsp;160</ln><a id="160">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;161</ln><a id="161">&nbsp;</a>&nbsp;<c41>The&nbsp;loan&nbsp;states&nbsp;that&nbsp;the&nbsp;expression&nbsp;`(*x).f`&nbsp;has&nbsp;been&nbsp;loaned&nbsp;as
</c41><br/><ln>&nbsp;&nbsp;162</ln><a id="162">&nbsp;</a>&nbsp;<c41>mutable&nbsp;for&nbsp;the&nbsp;lifetime&nbsp;`'a`.&nbsp;Because&nbsp;the&nbsp;loan&nbsp;is&nbsp;mutable,&nbsp;that&nbsp;means
</c41><br/><ln>&nbsp;&nbsp;163</ln><a id="163">&nbsp;</a>&nbsp;<c41>that&nbsp;the&nbsp;value&nbsp;`(*x).f`&nbsp;may&nbsp;be&nbsp;mutated&nbsp;via&nbsp;the&nbsp;newly&nbsp;created&nbsp;reference
</c41><br/><ln>&nbsp;&nbsp;164</ln><a id="164">&nbsp;</a>&nbsp;<c41>(and&nbsp;*only*&nbsp;via&nbsp;that&nbsp;pointer).&nbsp;This&nbsp;is&nbsp;reflected&nbsp;in&nbsp;the
</c41><br/><ln>&nbsp;&nbsp;165</ln><a id="165">&nbsp;</a>&nbsp;<c41>restrictions&nbsp;`RS`&nbsp;that&nbsp;accompany&nbsp;the&nbsp;loan.
</c41><br/><ln>&nbsp;&nbsp;166</ln><a id="166">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;167</ln><a id="167">&nbsp;</a>&nbsp;<c41>The&nbsp;first&nbsp;restriction&nbsp;`((*x).f,&nbsp;[MUTATE,&nbsp;CLAIM,&nbsp;FREEZE])`&nbsp;states&nbsp;that
</c41><br/><ln>&nbsp;&nbsp;168</ln><a id="168">&nbsp;</a>&nbsp;<c41>the&nbsp;lender&nbsp;may&nbsp;not&nbsp;mutate,&nbsp;freeze,&nbsp;nor&nbsp;alias&nbsp;`(*x).f`.&nbsp;Mutation&nbsp;is
</c41><br/><ln>&nbsp;&nbsp;169</ln><a id="169">&nbsp;</a>&nbsp;<c41>illegal&nbsp;because&nbsp;`(*x).f`&nbsp;is&nbsp;only&nbsp;supposed&nbsp;to&nbsp;be&nbsp;mutated&nbsp;via&nbsp;the&nbsp;new
</c41><br/><ln>&nbsp;&nbsp;170</ln><a id="170">&nbsp;</a>&nbsp;<c41>reference,&nbsp;not&nbsp;by&nbsp;mutating&nbsp;the&nbsp;original&nbsp;path&nbsp;`(*x).f`.&nbsp;Freezing&nbsp;is
</c41><br/><ln>&nbsp;&nbsp;171</ln><a id="171">&nbsp;</a>&nbsp;<c41>illegal&nbsp;because&nbsp;the&nbsp;path&nbsp;now&nbsp;has&nbsp;an&nbsp;`&amp;mut`&nbsp;alias;&nbsp;so&nbsp;even&nbsp;if&nbsp;we&nbsp;the
</c41><br/><ln>&nbsp;&nbsp;172</ln><a id="172">&nbsp;</a>&nbsp;<c41>lender&nbsp;were&nbsp;to&nbsp;consider&nbsp;`(*x).f`&nbsp;to&nbsp;be&nbsp;immutable,&nbsp;it&nbsp;might&nbsp;be&nbsp;mutated
</c41><br/><ln>&nbsp;&nbsp;173</ln><a id="173">&nbsp;</a>&nbsp;<c41>via&nbsp;this&nbsp;alias.&nbsp;They&nbsp;will&nbsp;be&nbsp;enforced&nbsp;for&nbsp;the&nbsp;lifetime&nbsp;`'a`&nbsp;of&nbsp;the
</c41><br/><ln>&nbsp;&nbsp;174</ln><a id="174">&nbsp;</a>&nbsp;<c41>loan.&nbsp;After&nbsp;the&nbsp;loan&nbsp;expires,&nbsp;the&nbsp;restrictions&nbsp;no&nbsp;longer&nbsp;apply.
</c41><br/><ln>&nbsp;&nbsp;175</ln><a id="175">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;176</ln><a id="176">&nbsp;</a>&nbsp;<c41>The&nbsp;second&nbsp;restriction&nbsp;on&nbsp;`*x`&nbsp;is&nbsp;interesting&nbsp;because&nbsp;it&nbsp;does&nbsp;not
</c41><br/><ln>&nbsp;&nbsp;177</ln><a id="177">&nbsp;</a>&nbsp;<c41>apply&nbsp;to&nbsp;the&nbsp;path&nbsp;that&nbsp;was&nbsp;lent&nbsp;(`(*x).f`)&nbsp;but&nbsp;rather&nbsp;to&nbsp;a&nbsp;prefix&nbsp;of
</c41><br/><ln>&nbsp;&nbsp;178</ln><a id="178">&nbsp;</a>&nbsp;<c41>the&nbsp;borrowed&nbsp;path.&nbsp;This&nbsp;is&nbsp;due&nbsp;to&nbsp;the&nbsp;rules&nbsp;of&nbsp;inherited&nbsp;mutability:
</c41><br/><ln>&nbsp;&nbsp;179</ln><a id="179">&nbsp;</a>&nbsp;<c41>if&nbsp;the&nbsp;user&nbsp;were&nbsp;to&nbsp;assign&nbsp;to&nbsp;(or&nbsp;freeze)&nbsp;`*x`,&nbsp;they&nbsp;would&nbsp;indirectly
</c41><br/><ln>&nbsp;&nbsp;180</ln><a id="180">&nbsp;</a>&nbsp;<c41>overwrite&nbsp;(or&nbsp;freeze)&nbsp;`(*x).f`,&nbsp;and&nbsp;thus&nbsp;invalidate&nbsp;the&nbsp;reference
</c41><br/><ln>&nbsp;&nbsp;181</ln><a id="181">&nbsp;</a>&nbsp;<c41>that&nbsp;was&nbsp;created.&nbsp;In&nbsp;general&nbsp;it&nbsp;holds&nbsp;that&nbsp;when&nbsp;a&nbsp;path&nbsp;is
</c41><br/><ln>&nbsp;&nbsp;182</ln><a id="182">&nbsp;</a>&nbsp;<c41>lent,&nbsp;restrictions&nbsp;are&nbsp;issued&nbsp;for&nbsp;all&nbsp;the&nbsp;owning&nbsp;prefixes&nbsp;of&nbsp;that
</c41><br/><ln>&nbsp;&nbsp;183</ln><a id="183">&nbsp;</a>&nbsp;<c41>path.&nbsp;In&nbsp;this&nbsp;case,&nbsp;the&nbsp;path&nbsp;`*x`&nbsp;owns&nbsp;the&nbsp;path&nbsp;`(*x).f`&nbsp;and,
</c41><br/><ln>&nbsp;&nbsp;184</ln><a id="184">&nbsp;</a>&nbsp;<c41>because&nbsp;`x`&nbsp;is&nbsp;an&nbsp;owned&nbsp;pointer,&nbsp;the&nbsp;path&nbsp;`x`&nbsp;owns&nbsp;the&nbsp;path&nbsp;`*x`.
</c41><br/><ln>&nbsp;&nbsp;185</ln><a id="185">&nbsp;</a>&nbsp;<c41>Therefore,&nbsp;borrowing&nbsp;`(*x).f`&nbsp;yields&nbsp;restrictions&nbsp;on&nbsp;both
</c41><br/><ln>&nbsp;&nbsp;186</ln><a id="186">&nbsp;</a>&nbsp;<c41>`*x`&nbsp;and&nbsp;`x`.
</c41><br/><ln>&nbsp;&nbsp;187</ln><a id="187">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;188</ln><a id="188">&nbsp;</a>&nbsp;<c41>###&nbsp;Checking&nbsp;for&nbsp;illegal&nbsp;assignments,&nbsp;moves,&nbsp;and&nbsp;reborrows
</c41><br/><ln>&nbsp;&nbsp;189</ln><a id="189">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;190</ln><a id="190">&nbsp;</a>&nbsp;<c41>Once&nbsp;we&nbsp;have&nbsp;computed&nbsp;the&nbsp;loans&nbsp;introduced&nbsp;by&nbsp;each&nbsp;borrow,&nbsp;the&nbsp;borrow
</c41><br/><ln>&nbsp;&nbsp;191</ln><a id="191">&nbsp;</a>&nbsp;<c41>checker&nbsp;uses&nbsp;a&nbsp;data&nbsp;flow&nbsp;propagation&nbsp;to&nbsp;compute&nbsp;the&nbsp;full&nbsp;set&nbsp;of&nbsp;loans
</c41><br/><ln>&nbsp;&nbsp;192</ln><a id="192">&nbsp;</a>&nbsp;<c41>in&nbsp;scope&nbsp;at&nbsp;each&nbsp;expression&nbsp;and&nbsp;then&nbsp;uses&nbsp;that&nbsp;set&nbsp;to&nbsp;decide&nbsp;whether
</c41><br/><ln>&nbsp;&nbsp;193</ln><a id="193">&nbsp;</a>&nbsp;<c41>that&nbsp;expression&nbsp;is&nbsp;legal.&nbsp;&nbsp;Remember&nbsp;that&nbsp;the&nbsp;scope&nbsp;of&nbsp;loan&nbsp;is&nbsp;defined
</c41><br/><ln>&nbsp;&nbsp;194</ln><a id="194">&nbsp;</a>&nbsp;<c41>by&nbsp;its&nbsp;lifetime&nbsp;LT.&nbsp;&nbsp;We&nbsp;sometimes&nbsp;say&nbsp;that&nbsp;a&nbsp;loan&nbsp;which&nbsp;is&nbsp;in-scope&nbsp;at
</c41><br/><ln>&nbsp;&nbsp;195</ln><a id="195">&nbsp;</a>&nbsp;<c41>a&nbsp;particular&nbsp;point&nbsp;is&nbsp;an&nbsp;"outstanding&nbsp;loan",&nbsp;and&nbsp;the&nbsp;set&nbsp;of
</c41><br/><ln>&nbsp;&nbsp;196</ln><a id="196">&nbsp;</a>&nbsp;<c41>restrictions&nbsp;included&nbsp;in&nbsp;those&nbsp;loans&nbsp;as&nbsp;the&nbsp;"outstanding
</c41><br/><ln>&nbsp;&nbsp;197</ln><a id="197">&nbsp;</a>&nbsp;<c41>restrictions".
</c41><br/><ln>&nbsp;&nbsp;198</ln><a id="198">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;199</ln><a id="199">&nbsp;</a>&nbsp;<c41>The&nbsp;kinds&nbsp;of&nbsp;expressions&nbsp;which&nbsp;in-scope&nbsp;loans&nbsp;can&nbsp;render&nbsp;illegal&nbsp;are:
</c41><br/><ln>&nbsp;&nbsp;200</ln><a id="200">&nbsp;</a>&nbsp;<c41>-&nbsp;*assignments*&nbsp;(`lv&nbsp;=&nbsp;v`):&nbsp;illegal&nbsp;if&nbsp;there&nbsp;is&nbsp;an&nbsp;in-scope&nbsp;restriction
</c41><br/><ln>&nbsp;&nbsp;201</ln><a id="201">&nbsp;</a>&nbsp;<c41>&nbsp;&nbsp;against&nbsp;mutating&nbsp;`lv`;
</c41><br/><ln>&nbsp;&nbsp;202</ln><a id="202">&nbsp;</a>&nbsp;<c41>-&nbsp;*moves*:&nbsp;illegal&nbsp;if&nbsp;there&nbsp;is&nbsp;any&nbsp;in-scope&nbsp;restriction&nbsp;on&nbsp;`lv`&nbsp;at&nbsp;all;
</c41><br/><ln>&nbsp;&nbsp;203</ln><a id="203">&nbsp;</a>&nbsp;<c41>-&nbsp;*mutable&nbsp;borrows*&nbsp;(`&amp;mut&nbsp;lv`):&nbsp;illegal&nbsp;there&nbsp;is&nbsp;an&nbsp;in-scope&nbsp;restriction
</c41><br/><ln>&nbsp;&nbsp;204</ln><a id="204">&nbsp;</a>&nbsp;<c41>&nbsp;&nbsp;against&nbsp;claiming&nbsp;`lv`;
</c41><br/><ln>&nbsp;&nbsp;205</ln><a id="205">&nbsp;</a>&nbsp;<c41>-&nbsp;*immutable&nbsp;borrows*&nbsp;(`&amp;lv`):&nbsp;illegal&nbsp;there&nbsp;is&nbsp;an&nbsp;in-scope&nbsp;restriction
</c41><br/><ln>&nbsp;&nbsp;206</ln><a id="206">&nbsp;</a>&nbsp;<c41>&nbsp;&nbsp;against&nbsp;freezing&nbsp;`lv`.
</c41><br/><ln>&nbsp;&nbsp;207</ln><a id="207">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;208</ln><a id="208">&nbsp;</a>&nbsp;<c41>##&nbsp;Formal&nbsp;rules
</c41><br/><ln>&nbsp;&nbsp;209</ln><a id="209">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;210</ln><a id="210">&nbsp;</a>&nbsp;<c41>Now&nbsp;that&nbsp;we&nbsp;hopefully&nbsp;have&nbsp;some&nbsp;kind&nbsp;of&nbsp;intuitive&nbsp;feeling&nbsp;for&nbsp;how&nbsp;the
</c41><br/><ln>&nbsp;&nbsp;211</ln><a id="211">&nbsp;</a>&nbsp;<c41>borrow&nbsp;checker&nbsp;works,&nbsp;let's&nbsp;look&nbsp;a&nbsp;bit&nbsp;more&nbsp;closely&nbsp;now&nbsp;at&nbsp;the&nbsp;precise
</c41><br/><ln>&nbsp;&nbsp;212</ln><a id="212">&nbsp;</a>&nbsp;<c41>conditions&nbsp;that&nbsp;it&nbsp;uses.&nbsp;For&nbsp;simplicity&nbsp;I&nbsp;will&nbsp;ignore&nbsp;const&nbsp;loans.
</c41><br/><ln>&nbsp;&nbsp;213</ln><a id="213">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;214</ln><a id="214">&nbsp;</a>&nbsp;<c41>I&nbsp;will&nbsp;present&nbsp;the&nbsp;rules&nbsp;in&nbsp;a&nbsp;modified&nbsp;form&nbsp;of&nbsp;standard&nbsp;inference
</c41><br/><ln>&nbsp;&nbsp;215</ln><a id="215">&nbsp;</a>&nbsp;<c41>rules,&nbsp;which&nbsp;looks&nbsp;as&nbsp;follows:
</c41><br/><ln>&nbsp;&nbsp;216</ln><a id="216">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;217</ln><a id="217">&nbsp;</a>&nbsp;<c41>```notrust
</c41><br/><ln>&nbsp;&nbsp;218</ln><a id="218">&nbsp;</a>&nbsp;<c41>PREDICATE(X,&nbsp;Y,&nbsp;Z)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Rule-Name
</c41><br/><ln>&nbsp;&nbsp;219</ln><a id="219">&nbsp;</a>&nbsp;<c41>&nbsp;&nbsp;Condition&nbsp;1
</c41><br/><ln>&nbsp;&nbsp;220</ln><a id="220">&nbsp;</a>&nbsp;<c41>&nbsp;&nbsp;Condition&nbsp;2
</c41><br/><ln>&nbsp;&nbsp;221</ln><a id="221">&nbsp;</a>&nbsp;<c41>&nbsp;&nbsp;Condition&nbsp;3
</c41><br/><ln>&nbsp;&nbsp;222</ln><a id="222">&nbsp;</a>&nbsp;<c41>```
</c41><br/><ln>&nbsp;&nbsp;223</ln><a id="223">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;224</ln><a id="224">&nbsp;</a>&nbsp;<c41>The&nbsp;initial&nbsp;line&nbsp;states&nbsp;the&nbsp;predicate&nbsp;that&nbsp;is&nbsp;to&nbsp;be&nbsp;satisfied.&nbsp;&nbsp;The
</c41><br/><ln>&nbsp;&nbsp;225</ln><a id="225">&nbsp;</a>&nbsp;<c41>indented&nbsp;lines&nbsp;indicate&nbsp;the&nbsp;conditions&nbsp;that&nbsp;must&nbsp;be&nbsp;met&nbsp;for&nbsp;the
</c41><br/><ln>&nbsp;&nbsp;226</ln><a id="226">&nbsp;</a>&nbsp;<c41>predicate&nbsp;to&nbsp;be&nbsp;satisfied.&nbsp;The&nbsp;right-justified&nbsp;comment&nbsp;states&nbsp;the&nbsp;name
</c41><br/><ln>&nbsp;&nbsp;227</ln><a id="227">&nbsp;</a>&nbsp;<c41>of&nbsp;this&nbsp;rule:&nbsp;there&nbsp;are&nbsp;comments&nbsp;in&nbsp;the&nbsp;borrowck&nbsp;source&nbsp;referencing
</c41><br/><ln>&nbsp;&nbsp;228</ln><a id="228">&nbsp;</a>&nbsp;<c41>these&nbsp;names,&nbsp;so&nbsp;that&nbsp;you&nbsp;can&nbsp;cross&nbsp;reference&nbsp;to&nbsp;find&nbsp;the&nbsp;actual&nbsp;code
</c41><br/><ln>&nbsp;&nbsp;229</ln><a id="229">&nbsp;</a>&nbsp;<c41>that&nbsp;corresponds&nbsp;to&nbsp;the&nbsp;formal&nbsp;rule.
</c41><br/><ln>&nbsp;&nbsp;230</ln><a id="230">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;231</ln><a id="231">&nbsp;</a>&nbsp;<c41>###&nbsp;Invariants
</c41><br/><ln>&nbsp;&nbsp;232</ln><a id="232">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;233</ln><a id="233">&nbsp;</a>&nbsp;<c41>I&nbsp;want&nbsp;to&nbsp;collect,&nbsp;at&nbsp;a&nbsp;high-level,&nbsp;the&nbsp;invariants&nbsp;the&nbsp;borrow&nbsp;checker
</c41><br/><ln>&nbsp;&nbsp;234</ln><a id="234">&nbsp;</a>&nbsp;<c41>maintains.&nbsp;I&nbsp;will&nbsp;give&nbsp;them&nbsp;names&nbsp;and&nbsp;refer&nbsp;to&nbsp;them&nbsp;throughout&nbsp;the
</c41><br/><ln>&nbsp;&nbsp;235</ln><a id="235">&nbsp;</a>&nbsp;<c41>text.&nbsp;Together&nbsp;these&nbsp;invariants&nbsp;are&nbsp;crucial&nbsp;for&nbsp;the&nbsp;overall&nbsp;soundness
</c41><br/><ln>&nbsp;&nbsp;236</ln><a id="236">&nbsp;</a>&nbsp;<c41>of&nbsp;the&nbsp;system.
</c41><br/><ln>&nbsp;&nbsp;237</ln><a id="237">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;238</ln><a id="238">&nbsp;</a>&nbsp;<c41>**Mutability&nbsp;requires&nbsp;uniqueness.**&nbsp;To&nbsp;mutate&nbsp;a&nbsp;path
</c41><br/><ln>&nbsp;&nbsp;239</ln><a id="239">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;240</ln><a id="240">&nbsp;</a>&nbsp;<c41>**Unique&nbsp;mutability.**&nbsp;There&nbsp;is&nbsp;only&nbsp;one&nbsp;*usable*&nbsp;mutable&nbsp;path&nbsp;to&nbsp;any
</c41><br/><ln>&nbsp;&nbsp;241</ln><a id="241">&nbsp;</a>&nbsp;<c41>given&nbsp;memory&nbsp;at&nbsp;any&nbsp;given&nbsp;time.&nbsp;This&nbsp;implies&nbsp;that&nbsp;when&nbsp;claiming&nbsp;memory
</c41><br/><ln>&nbsp;&nbsp;242</ln><a id="242">&nbsp;</a>&nbsp;<c41>with&nbsp;an&nbsp;expression&nbsp;like&nbsp;`p&nbsp;=&nbsp;&amp;mut&nbsp;x`,&nbsp;the&nbsp;compiler&nbsp;must&nbsp;guarantee&nbsp;that
</c41><br/><ln>&nbsp;&nbsp;243</ln><a id="243">&nbsp;</a>&nbsp;<c41>the&nbsp;borrowed&nbsp;value&nbsp;`x`&nbsp;can&nbsp;no&nbsp;longer&nbsp;be&nbsp;mutated&nbsp;so&nbsp;long&nbsp;as&nbsp;`p`&nbsp;is
</c41><br/><ln>&nbsp;&nbsp;244</ln><a id="244">&nbsp;</a>&nbsp;<c41>live.&nbsp;(This&nbsp;is&nbsp;done&nbsp;via&nbsp;restrictions,&nbsp;read&nbsp;on.)
</c41><br/><ln>&nbsp;&nbsp;245</ln><a id="245">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;246</ln><a id="246">&nbsp;</a>&nbsp;<c41>**.**
</c41><br/><ln>&nbsp;&nbsp;247</ln><a id="247">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;248</ln><a id="248">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;249</ln><a id="249">&nbsp;</a>&nbsp;<c41>###&nbsp;The&nbsp;`gather_loans`&nbsp;pass
</c41><br/><ln>&nbsp;&nbsp;250</ln><a id="250">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;251</ln><a id="251">&nbsp;</a>&nbsp;<c41>We&nbsp;start&nbsp;with&nbsp;the&nbsp;`gather_loans`&nbsp;pass,&nbsp;which&nbsp;walks&nbsp;the&nbsp;AST&nbsp;looking&nbsp;for
</c41><br/><ln>&nbsp;&nbsp;252</ln><a id="252">&nbsp;</a>&nbsp;<c41>borrows.&nbsp;&nbsp;For&nbsp;each&nbsp;borrow,&nbsp;there&nbsp;are&nbsp;three&nbsp;bits&nbsp;of&nbsp;information:&nbsp;the
</c41><br/><ln>&nbsp;&nbsp;253</ln><a id="253">&nbsp;</a>&nbsp;<c41>lvalue&nbsp;`LV`&nbsp;being&nbsp;borrowed&nbsp;and&nbsp;the&nbsp;mutability&nbsp;`MQ`&nbsp;and&nbsp;lifetime&nbsp;`LT`
</c41><br/><ln>&nbsp;&nbsp;254</ln><a id="254">&nbsp;</a>&nbsp;<c41>of&nbsp;the&nbsp;resulting&nbsp;pointer.&nbsp;Given&nbsp;those,&nbsp;`gather_loans`&nbsp;applies&nbsp;four
</c41><br/><ln>&nbsp;&nbsp;255</ln><a id="255">&nbsp;</a>&nbsp;<c41>validity&nbsp;tests:
</c41><br/><ln>&nbsp;&nbsp;256</ln><a id="256">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;257</ln><a id="257">&nbsp;</a>&nbsp;<c41>1.&nbsp;`MUTABILITY(LV,&nbsp;MQ)`:&nbsp;The&nbsp;mutability&nbsp;of&nbsp;the&nbsp;reference&nbsp;is
</c41><br/><ln>&nbsp;&nbsp;258</ln><a id="258">&nbsp;</a>&nbsp;<c41>compatible&nbsp;with&nbsp;the&nbsp;mutability&nbsp;of&nbsp;`LV`&nbsp;(i.e.,&nbsp;not&nbsp;borrowing&nbsp;immutable
</c41><br/><ln>&nbsp;&nbsp;259</ln><a id="259">&nbsp;</a>&nbsp;<c41>data&nbsp;as&nbsp;mutable).
</c41><br/><ln>&nbsp;&nbsp;260</ln><a id="260">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;261</ln><a id="261">&nbsp;</a>&nbsp;<c41>2.&nbsp;`ALIASABLE(LV,&nbsp;MQ)`:&nbsp;The&nbsp;aliasability&nbsp;of&nbsp;the&nbsp;reference&nbsp;is
</c41><br/><ln>&nbsp;&nbsp;262</ln><a id="262">&nbsp;</a>&nbsp;<c41>compatible&nbsp;with&nbsp;the&nbsp;aliasability&nbsp;of&nbsp;`LV`.&nbsp;The&nbsp;goal&nbsp;is&nbsp;to&nbsp;prevent
</c41><br/><ln>&nbsp;&nbsp;263</ln><a id="263">&nbsp;</a>&nbsp;<c41>`&amp;mut`&nbsp;borrows&nbsp;of&nbsp;aliasability&nbsp;data.
</c41><br/><ln>&nbsp;&nbsp;264</ln><a id="264">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;265</ln><a id="265">&nbsp;</a>&nbsp;<c41>3.&nbsp;`LIFETIME(LV,&nbsp;LT,&nbsp;MQ)`:&nbsp;The&nbsp;lifetime&nbsp;of&nbsp;the&nbsp;borrow&nbsp;does&nbsp;not&nbsp;exceed
</c41><br/><ln>&nbsp;&nbsp;266</ln><a id="266">&nbsp;</a>&nbsp;<c41>the&nbsp;lifetime&nbsp;of&nbsp;the&nbsp;value&nbsp;being&nbsp;borrowed.&nbsp;This&nbsp;pass&nbsp;is&nbsp;also
</c41><br/><ln>&nbsp;&nbsp;267</ln><a id="267">&nbsp;</a>&nbsp;<c41>responsible&nbsp;for&nbsp;inserting&nbsp;root&nbsp;annotations&nbsp;to&nbsp;keep&nbsp;managed&nbsp;values
</c41><br/><ln>&nbsp;&nbsp;268</ln><a id="268">&nbsp;</a>&nbsp;<c41>alive.
</c41><br/><ln>&nbsp;&nbsp;269</ln><a id="269">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;270</ln><a id="270">&nbsp;</a>&nbsp;<c41>4.&nbsp;`RESTRICTIONS(LV,&nbsp;LT,&nbsp;ACTIONS)&nbsp;=&nbsp;RS`:&nbsp;This&nbsp;pass&nbsp;checks&nbsp;and&nbsp;computes&nbsp;the
</c41><br/><ln>&nbsp;&nbsp;271</ln><a id="271">&nbsp;</a>&nbsp;<c41>restrictions&nbsp;to&nbsp;maintain&nbsp;memory&nbsp;safety.&nbsp;These&nbsp;are&nbsp;the&nbsp;restrictions
</c41><br/><ln>&nbsp;&nbsp;272</ln><a id="272">&nbsp;</a>&nbsp;<c41>that&nbsp;will&nbsp;go&nbsp;into&nbsp;the&nbsp;final&nbsp;loan.&nbsp;We'll&nbsp;discuss&nbsp;in&nbsp;more&nbsp;detail&nbsp;below.
</c41><br/><ln>&nbsp;&nbsp;273</ln><a id="273">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;274</ln><a id="274">&nbsp;</a>&nbsp;<c41>##&nbsp;Checking&nbsp;mutability
</c41><br/><ln>&nbsp;&nbsp;275</ln><a id="275">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;276</ln><a id="276">&nbsp;</a>&nbsp;<c41>Checking&nbsp;mutability&nbsp;is&nbsp;fairly&nbsp;straightforward.&nbsp;We&nbsp;just&nbsp;want&nbsp;to&nbsp;prevent
</c41><br/><ln>&nbsp;&nbsp;277</ln><a id="277">&nbsp;</a>&nbsp;<c41>immutable&nbsp;data&nbsp;from&nbsp;being&nbsp;borrowed&nbsp;as&nbsp;mutable.&nbsp;Note&nbsp;that&nbsp;it&nbsp;is&nbsp;ok&nbsp;to
</c41><br/><ln>&nbsp;&nbsp;278</ln><a id="278">&nbsp;</a>&nbsp;<c41>borrow&nbsp;mutable&nbsp;data&nbsp;as&nbsp;immutable,&nbsp;since&nbsp;that&nbsp;is&nbsp;simply&nbsp;a
</c41><br/><ln>&nbsp;&nbsp;279</ln><a id="279">&nbsp;</a>&nbsp;<c41>freeze.&nbsp;Formally&nbsp;we&nbsp;define&nbsp;a&nbsp;predicate&nbsp;`MUTABLE(LV,&nbsp;MQ)`&nbsp;which,&nbsp;if
</c41><br/><ln>&nbsp;&nbsp;280</ln><a id="280">&nbsp;</a>&nbsp;<c41>defined,&nbsp;means&nbsp;that&nbsp;"borrowing&nbsp;`LV`&nbsp;with&nbsp;mutability&nbsp;`MQ`&nbsp;is&nbsp;ok.&nbsp;The
</c41><br/><ln>&nbsp;&nbsp;281</ln><a id="281">&nbsp;</a>&nbsp;<c41>Rust&nbsp;code&nbsp;corresponding&nbsp;to&nbsp;this&nbsp;predicate&nbsp;is&nbsp;the&nbsp;function
</c41><br/><ln>&nbsp;&nbsp;282</ln><a id="282">&nbsp;</a>&nbsp;<c41>`check_mutability`&nbsp;in&nbsp;`middle::borrowck::gather_loans`.
</c41><br/><ln>&nbsp;&nbsp;283</ln><a id="283">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;284</ln><a id="284">&nbsp;</a>&nbsp;<c41>###&nbsp;Checking&nbsp;mutability&nbsp;of&nbsp;variables
</c41><br/><ln>&nbsp;&nbsp;285</ln><a id="285">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;286</ln><a id="286">&nbsp;</a>&nbsp;<c41>*Code&nbsp;pointer:*&nbsp;Function&nbsp;`check_mutability()`&nbsp;in&nbsp;`gather_loans/mod.rs`,
</c41><br/><ln>&nbsp;&nbsp;287</ln><a id="287">&nbsp;</a>&nbsp;<c41>but&nbsp;also&nbsp;the&nbsp;code&nbsp;in&nbsp;`mem_categorization`.
</c41><br/><ln>&nbsp;&nbsp;288</ln><a id="288">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;289</ln><a id="289">&nbsp;</a>&nbsp;<c41>Let's&nbsp;begin&nbsp;with&nbsp;the&nbsp;rules&nbsp;for&nbsp;variables,&nbsp;which&nbsp;state&nbsp;that&nbsp;if&nbsp;a
</c41><br/><ln>&nbsp;&nbsp;290</ln><a id="290">&nbsp;</a>&nbsp;<c41>variable&nbsp;is&nbsp;declared&nbsp;as&nbsp;mutable,&nbsp;it&nbsp;may&nbsp;be&nbsp;borrowed&nbsp;any&nbsp;which&nbsp;way,&nbsp;but
</c41><br/><ln>&nbsp;&nbsp;291</ln><a id="291">&nbsp;</a>&nbsp;<c41>otherwise&nbsp;the&nbsp;variable&nbsp;must&nbsp;be&nbsp;borrowed&nbsp;as&nbsp;immutable&nbsp;or&nbsp;const:
</c41><br/><ln>&nbsp;&nbsp;292</ln><a id="292">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;293</ln><a id="293">&nbsp;</a>&nbsp;<c41>```notrust
</c41><br/><ln>&nbsp;&nbsp;294</ln><a id="294">&nbsp;</a>&nbsp;<c41>MUTABILITY(X,&nbsp;MQ)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;M-Var-Mut
</c41><br/><ln>&nbsp;&nbsp;295</ln><a id="295">&nbsp;</a>&nbsp;<c41>&nbsp;&nbsp;DECL(X)&nbsp;=&nbsp;mut
</c41><br/><ln>&nbsp;&nbsp;296</ln><a id="296">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;297</ln><a id="297">&nbsp;</a>&nbsp;<c41>MUTABILITY(X,&nbsp;MQ)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;M-Var-Imm
</c41><br/><ln>&nbsp;&nbsp;298</ln><a id="298">&nbsp;</a>&nbsp;<c41>&nbsp;&nbsp;DECL(X)&nbsp;=&nbsp;imm
</c41><br/><ln>&nbsp;&nbsp;299</ln><a id="299">&nbsp;</a>&nbsp;<c41>&nbsp;&nbsp;MQ&nbsp;=&nbsp;imm&nbsp;|&nbsp;const
</c41><br/><ln>&nbsp;&nbsp;300</ln><a id="300">&nbsp;</a>&nbsp;<c41>```
</c41><br/><ln>&nbsp;&nbsp;301</ln><a id="301">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;302</ln><a id="302">&nbsp;</a>&nbsp;<c41>###&nbsp;Checking&nbsp;mutability&nbsp;of&nbsp;owned&nbsp;content
</c41><br/><ln>&nbsp;&nbsp;303</ln><a id="303">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;304</ln><a id="304">&nbsp;</a>&nbsp;<c41>Fields&nbsp;and&nbsp;owned&nbsp;pointers&nbsp;inherit&nbsp;their&nbsp;mutability&nbsp;from
</c41><br/><ln>&nbsp;&nbsp;305</ln><a id="305">&nbsp;</a>&nbsp;<c41>their&nbsp;base&nbsp;expressions,&nbsp;so&nbsp;both&nbsp;of&nbsp;their&nbsp;rules&nbsp;basically
</c41><br/><ln>&nbsp;&nbsp;306</ln><a id="306">&nbsp;</a>&nbsp;<c41>delegate&nbsp;the&nbsp;check&nbsp;to&nbsp;the&nbsp;base&nbsp;expression&nbsp;`LV`:
</c41><br/><ln>&nbsp;&nbsp;307</ln><a id="307">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;308</ln><a id="308">&nbsp;</a>&nbsp;<c41>```notrust
</c41><br/><ln>&nbsp;&nbsp;309</ln><a id="309">&nbsp;</a>&nbsp;<c41>MUTABILITY(LV.f,&nbsp;MQ)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;M-Field
</c41><br/><ln>&nbsp;&nbsp;310</ln><a id="310">&nbsp;</a>&nbsp;<c41>&nbsp;&nbsp;MUTABILITY(LV,&nbsp;MQ)
</c41><br/><ln>&nbsp;&nbsp;311</ln><a id="311">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;312</ln><a id="312">&nbsp;</a>&nbsp;<c41>MUTABILITY(*LV,&nbsp;MQ)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;M-Deref-Unique
</c41><br/><ln>&nbsp;&nbsp;313</ln><a id="313">&nbsp;</a>&nbsp;<c41>&nbsp;&nbsp;TYPE(LV)&nbsp;=&nbsp;Box&lt;Ty&gt;
</c41><br/><ln>&nbsp;&nbsp;314</ln><a id="314">&nbsp;</a>&nbsp;<c41>&nbsp;&nbsp;MUTABILITY(LV,&nbsp;MQ)
</c41><br/><ln>&nbsp;&nbsp;315</ln><a id="315">&nbsp;</a>&nbsp;<c41>```
</c41><br/><ln>&nbsp;&nbsp;316</ln><a id="316">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;317</ln><a id="317">&nbsp;</a>&nbsp;<c41>###&nbsp;Checking&nbsp;mutability&nbsp;of&nbsp;immutable&nbsp;pointer&nbsp;types
</c41><br/><ln>&nbsp;&nbsp;318</ln><a id="318">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;319</ln><a id="319">&nbsp;</a>&nbsp;<c41>Immutable&nbsp;pointer&nbsp;types&nbsp;like&nbsp;`&amp;T`&nbsp;and&nbsp;`@T`&nbsp;can&nbsp;only
</c41><br/><ln>&nbsp;&nbsp;320</ln><a id="320">&nbsp;</a>&nbsp;<c41>be&nbsp;borrowed&nbsp;if&nbsp;MQ&nbsp;is&nbsp;immutable&nbsp;or&nbsp;const:
</c41><br/><ln>&nbsp;&nbsp;321</ln><a id="321">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;322</ln><a id="322">&nbsp;</a>&nbsp;<c41>```notrust
</c41><br/><ln>&nbsp;&nbsp;323</ln><a id="323">&nbsp;</a>&nbsp;<c41>MUTABILITY(*LV,&nbsp;MQ)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;M-Deref-Borrowed-Imm
</c41><br/><ln>&nbsp;&nbsp;324</ln><a id="324">&nbsp;</a>&nbsp;<c41>&nbsp;&nbsp;TYPE(LV)&nbsp;=&nbsp;&amp;Ty
</c41><br/><ln>&nbsp;&nbsp;325</ln><a id="325">&nbsp;</a>&nbsp;<c41>&nbsp;&nbsp;MQ&nbsp;==&nbsp;imm&nbsp;|&nbsp;const
</c41><br/><ln>&nbsp;&nbsp;326</ln><a id="326">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;327</ln><a id="327">&nbsp;</a>&nbsp;<c41>MUTABILITY(*LV,&nbsp;MQ)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;M-Deref-Managed-Imm
</c41><br/><ln>&nbsp;&nbsp;328</ln><a id="328">&nbsp;</a>&nbsp;<c41>&nbsp;&nbsp;TYPE(LV)&nbsp;=&nbsp;@Ty
</c41><br/><ln>&nbsp;&nbsp;329</ln><a id="329">&nbsp;</a>&nbsp;<c41>&nbsp;&nbsp;MQ&nbsp;==&nbsp;imm&nbsp;|&nbsp;const
</c41><br/><ln>&nbsp;&nbsp;330</ln><a id="330">&nbsp;</a>&nbsp;<c41>```
</c41><br/><ln>&nbsp;&nbsp;331</ln><a id="331">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;332</ln><a id="332">&nbsp;</a>&nbsp;<c41>###&nbsp;Checking&nbsp;mutability&nbsp;of&nbsp;mutable&nbsp;pointer&nbsp;types
</c41><br/><ln>&nbsp;&nbsp;333</ln><a id="333">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;334</ln><a id="334">&nbsp;</a>&nbsp;<c41>`&amp;mut&nbsp;T`&nbsp;can&nbsp;be&nbsp;frozen,&nbsp;so&nbsp;it&nbsp;is&nbsp;acceptable&nbsp;to&nbsp;borrow&nbsp;it&nbsp;as&nbsp;either&nbsp;imm&nbsp;or&nbsp;mut:
</c41><br/><ln>&nbsp;&nbsp;335</ln><a id="335">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;336</ln><a id="336">&nbsp;</a>&nbsp;<c41>```notrust
</c41><br/><ln>&nbsp;&nbsp;337</ln><a id="337">&nbsp;</a>&nbsp;<c41>MUTABILITY(*LV,&nbsp;MQ)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;M-Deref-Borrowed-Mut
</c41><br/><ln>&nbsp;&nbsp;338</ln><a id="338">&nbsp;</a>&nbsp;<c41>&nbsp;&nbsp;TYPE(LV)&nbsp;=&nbsp;&amp;mut&nbsp;Ty
</c41><br/><ln>&nbsp;&nbsp;339</ln><a id="339">&nbsp;</a>&nbsp;<c41>```
</c41><br/><ln>&nbsp;&nbsp;340</ln><a id="340">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;341</ln><a id="341">&nbsp;</a>&nbsp;<c41>##&nbsp;Checking&nbsp;aliasability
</c41><br/><ln>&nbsp;&nbsp;342</ln><a id="342">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;343</ln><a id="343">&nbsp;</a>&nbsp;<c41>The&nbsp;goal&nbsp;of&nbsp;the&nbsp;aliasability&nbsp;check&nbsp;is&nbsp;to&nbsp;ensure&nbsp;that&nbsp;we&nbsp;never&nbsp;permit
</c41><br/><ln>&nbsp;&nbsp;344</ln><a id="344">&nbsp;</a>&nbsp;<c41>`&amp;mut`&nbsp;borrows&nbsp;of&nbsp;aliasable&nbsp;data.&nbsp;Formally&nbsp;we&nbsp;define&nbsp;a&nbsp;predicate
</c41><br/><ln>&nbsp;&nbsp;345</ln><a id="345">&nbsp;</a>&nbsp;<c41>`ALIASABLE(LV,&nbsp;MQ)`&nbsp;which&nbsp;if&nbsp;defined&nbsp;means&nbsp;that
</c41><br/><ln>&nbsp;&nbsp;346</ln><a id="346">&nbsp;</a>&nbsp;<c41>"borrowing&nbsp;`LV`&nbsp;with&nbsp;mutability&nbsp;`MQ`&nbsp;is&nbsp;ok".&nbsp;The
</c41><br/><ln>&nbsp;&nbsp;347</ln><a id="347">&nbsp;</a>&nbsp;<c41>Rust&nbsp;code&nbsp;corresponding&nbsp;to&nbsp;this&nbsp;predicate&nbsp;is&nbsp;the&nbsp;function
</c41><br/><ln>&nbsp;&nbsp;348</ln><a id="348">&nbsp;</a>&nbsp;<c41>`check_aliasability()`&nbsp;in&nbsp;`middle::borrowck::gather_loans`.
</c41><br/><ln>&nbsp;&nbsp;349</ln><a id="349">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;350</ln><a id="350">&nbsp;</a>&nbsp;<c41>###&nbsp;Checking&nbsp;aliasability&nbsp;of&nbsp;variables
</c41><br/><ln>&nbsp;&nbsp;351</ln><a id="351">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;352</ln><a id="352">&nbsp;</a>&nbsp;<c41>Local&nbsp;variables&nbsp;are&nbsp;never&nbsp;aliasable&nbsp;as&nbsp;they&nbsp;are&nbsp;accessible&nbsp;only&nbsp;within
</c41><br/><ln>&nbsp;&nbsp;353</ln><a id="353">&nbsp;</a>&nbsp;<c41>the&nbsp;stack&nbsp;frame.
</c41><br/><ln>&nbsp;&nbsp;354</ln><a id="354">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;355</ln><a id="355">&nbsp;</a>&nbsp;<c41>```notrust
</c41><br/><ln>&nbsp;&nbsp;356</ln><a id="356">&nbsp;</a>&nbsp;<c41>&nbsp;&nbsp;&nbsp;&nbsp;ALIASABLE(X,&nbsp;MQ)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;M-Var-Mut
</c41><br/><ln>&nbsp;&nbsp;357</ln><a id="357">&nbsp;</a>&nbsp;<c41>```
</c41><br/><ln>&nbsp;&nbsp;358</ln><a id="358">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;359</ln><a id="359">&nbsp;</a>&nbsp;<c41>###&nbsp;Checking&nbsp;aliasable&nbsp;of&nbsp;owned&nbsp;content
</c41><br/><ln>&nbsp;&nbsp;360</ln><a id="360">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;361</ln><a id="361">&nbsp;</a>&nbsp;<c41>Owned&nbsp;content&nbsp;is&nbsp;aliasable&nbsp;if&nbsp;it&nbsp;is&nbsp;found&nbsp;in&nbsp;an&nbsp;aliasable&nbsp;location:
</c41><br/><ln>&nbsp;&nbsp;362</ln><a id="362">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;363</ln><a id="363">&nbsp;</a>&nbsp;<c41>```notrust
</c41><br/><ln>&nbsp;&nbsp;364</ln><a id="364">&nbsp;</a>&nbsp;<c41>ALIASABLE(LV.f,&nbsp;MQ)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;M-Field
</c41><br/><ln>&nbsp;&nbsp;365</ln><a id="365">&nbsp;</a>&nbsp;<c41>&nbsp;&nbsp;ALIASABLE(LV,&nbsp;MQ)
</c41><br/><ln>&nbsp;&nbsp;366</ln><a id="366">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;367</ln><a id="367">&nbsp;</a>&nbsp;<c41>ALIASABLE(*LV,&nbsp;MQ)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;M-Deref-Unique
</c41><br/><ln>&nbsp;&nbsp;368</ln><a id="368">&nbsp;</a>&nbsp;<c41>&nbsp;&nbsp;ALIASABLE(LV,&nbsp;MQ)
</c41><br/><ln>&nbsp;&nbsp;369</ln><a id="369">&nbsp;</a>&nbsp;<c41>```
</c41><br/><ln>&nbsp;&nbsp;370</ln><a id="370">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;371</ln><a id="371">&nbsp;</a>&nbsp;<c41>###&nbsp;Checking&nbsp;mutability&nbsp;of&nbsp;immutable&nbsp;pointer&nbsp;types
</c41><br/><ln>&nbsp;&nbsp;372</ln><a id="372">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;373</ln><a id="373">&nbsp;</a>&nbsp;<c41>Immutable&nbsp;pointer&nbsp;types&nbsp;like&nbsp;`&amp;T`&nbsp;are&nbsp;aliasable,&nbsp;and&nbsp;hence&nbsp;can&nbsp;only&nbsp;be
</c41><br/><ln>&nbsp;&nbsp;374</ln><a id="374">&nbsp;</a>&nbsp;<c41>borrowed&nbsp;immutably:
</c41><br/><ln>&nbsp;&nbsp;375</ln><a id="375">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;376</ln><a id="376">&nbsp;</a>&nbsp;<c41>```notrust
</c41><br/><ln>&nbsp;&nbsp;377</ln><a id="377">&nbsp;</a>&nbsp;<c41>ALIASABLE(*LV,&nbsp;imm)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;M-Deref-Borrowed-Imm
</c41><br/><ln>&nbsp;&nbsp;378</ln><a id="378">&nbsp;</a>&nbsp;<c41>&nbsp;&nbsp;TYPE(LV)&nbsp;=&nbsp;&amp;Ty
</c41><br/><ln>&nbsp;&nbsp;379</ln><a id="379">&nbsp;</a>&nbsp;<c41>```
</c41><br/><ln>&nbsp;&nbsp;380</ln><a id="380">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;381</ln><a id="381">&nbsp;</a>&nbsp;<c41>###&nbsp;Checking&nbsp;mutability&nbsp;of&nbsp;mutable&nbsp;pointer&nbsp;types
</c41><br/><ln>&nbsp;&nbsp;382</ln><a id="382">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;383</ln><a id="383">&nbsp;</a>&nbsp;<c41>`&amp;mut&nbsp;T`&nbsp;can&nbsp;be&nbsp;frozen,&nbsp;so&nbsp;it&nbsp;is&nbsp;acceptable&nbsp;to&nbsp;borrow&nbsp;it&nbsp;as&nbsp;either&nbsp;imm&nbsp;or&nbsp;mut:
</c41><br/><ln>&nbsp;&nbsp;384</ln><a id="384">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;385</ln><a id="385">&nbsp;</a>&nbsp;<c41>```notrust
</c41><br/><ln>&nbsp;&nbsp;386</ln><a id="386">&nbsp;</a>&nbsp;<c41>ALIASABLE(*LV,&nbsp;MQ)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;M-Deref-Borrowed-Mut
</c41><br/><ln>&nbsp;&nbsp;387</ln><a id="387">&nbsp;</a>&nbsp;<c41>&nbsp;&nbsp;TYPE(LV)&nbsp;=&nbsp;&amp;mut&nbsp;Ty
</c41><br/><ln>&nbsp;&nbsp;388</ln><a id="388">&nbsp;</a>&nbsp;<c41>```
</c41><br/><ln>&nbsp;&nbsp;389</ln><a id="389">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;390</ln><a id="390">&nbsp;</a>&nbsp;<c41>##&nbsp;Checking&nbsp;lifetime
</c41><br/><ln>&nbsp;&nbsp;391</ln><a id="391">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;392</ln><a id="392">&nbsp;</a>&nbsp;<c41>These&nbsp;rules&nbsp;aim&nbsp;to&nbsp;ensure&nbsp;that&nbsp;no&nbsp;data&nbsp;is&nbsp;borrowed&nbsp;for&nbsp;a&nbsp;scope&nbsp;that&nbsp;exceeds
</c41><br/><ln>&nbsp;&nbsp;393</ln><a id="393">&nbsp;</a>&nbsp;<c41>its&nbsp;lifetime.&nbsp;In&nbsp;addition,&nbsp;these&nbsp;rules&nbsp;manage&nbsp;the&nbsp;rooting&nbsp;of&nbsp;`@`&nbsp;values.
</c41><br/><ln>&nbsp;&nbsp;394</ln><a id="394">&nbsp;</a>&nbsp;<c41>These&nbsp;two&nbsp;computations&nbsp;wind&nbsp;up&nbsp;being&nbsp;intimately&nbsp;related.&nbsp;Formally,&nbsp;we&nbsp;define
</c41><br/><ln>&nbsp;&nbsp;395</ln><a id="395">&nbsp;</a>&nbsp;<c41>a&nbsp;predicate&nbsp;`LIFETIME(LV,&nbsp;LT,&nbsp;MQ)`,&nbsp;which&nbsp;states&nbsp;that&nbsp;"the&nbsp;lvalue&nbsp;`LV`&nbsp;can&nbsp;be
</c41><br/><ln>&nbsp;&nbsp;396</ln><a id="396">&nbsp;</a>&nbsp;<c41>safely&nbsp;borrowed&nbsp;for&nbsp;the&nbsp;lifetime&nbsp;`LT`&nbsp;with&nbsp;mutability&nbsp;`MQ`".&nbsp;The&nbsp;Rust
</c41><br/><ln>&nbsp;&nbsp;397</ln><a id="397">&nbsp;</a>&nbsp;<c41>code&nbsp;corresponding&nbsp;to&nbsp;this&nbsp;predicate&nbsp;is&nbsp;the&nbsp;module
</c41><br/><ln>&nbsp;&nbsp;398</ln><a id="398">&nbsp;</a>&nbsp;<c41>`middle::borrowck::gather_loans::lifetime`.
</c41><br/><ln>&nbsp;&nbsp;399</ln><a id="399">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;400</ln><a id="400">&nbsp;</a>&nbsp;<c41>###&nbsp;The&nbsp;Scope&nbsp;function
</c41><br/><ln>&nbsp;&nbsp;401</ln><a id="401">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;402</ln><a id="402">&nbsp;</a>&nbsp;<c41>Several&nbsp;of&nbsp;the&nbsp;rules&nbsp;refer&nbsp;to&nbsp;a&nbsp;helper&nbsp;function&nbsp;`SCOPE(LV)=LT`.&nbsp;&nbsp;The
</c41><br/><ln>&nbsp;&nbsp;403</ln><a id="403">&nbsp;</a>&nbsp;<c41>`SCOPE(LV)`&nbsp;yields&nbsp;the&nbsp;lifetime&nbsp;`LT`&nbsp;for&nbsp;which&nbsp;the&nbsp;lvalue&nbsp;`LV`&nbsp;is
</c41><br/><ln>&nbsp;&nbsp;404</ln><a id="404">&nbsp;</a>&nbsp;<c41>guaranteed&nbsp;to&nbsp;exist,&nbsp;presuming&nbsp;that&nbsp;no&nbsp;mutations&nbsp;occur.
</c41><br/><ln>&nbsp;&nbsp;405</ln><a id="405">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;406</ln><a id="406">&nbsp;</a>&nbsp;<c41>The&nbsp;scope&nbsp;of&nbsp;a&nbsp;local&nbsp;variable&nbsp;is&nbsp;the&nbsp;block&nbsp;where&nbsp;it&nbsp;is&nbsp;declared:
</c41><br/><ln>&nbsp;&nbsp;407</ln><a id="407">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;408</ln><a id="408">&nbsp;</a>&nbsp;<c41>```notrust
</c41><br/><ln>&nbsp;&nbsp;409</ln><a id="409">&nbsp;</a>&nbsp;<c41>&nbsp;&nbsp;SCOPE(X)&nbsp;=&nbsp;block&nbsp;where&nbsp;X&nbsp;is&nbsp;declared
</c41><br/><ln>&nbsp;&nbsp;410</ln><a id="410">&nbsp;</a>&nbsp;<c41>```
</c41><br/><ln>&nbsp;&nbsp;411</ln><a id="411">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;412</ln><a id="412">&nbsp;</a>&nbsp;<c41>The&nbsp;scope&nbsp;of&nbsp;a&nbsp;field&nbsp;is&nbsp;the&nbsp;scope&nbsp;of&nbsp;the&nbsp;struct:
</c41><br/><ln>&nbsp;&nbsp;413</ln><a id="413">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;414</ln><a id="414">&nbsp;</a>&nbsp;<c41>```notrust
</c41><br/><ln>&nbsp;&nbsp;415</ln><a id="415">&nbsp;</a>&nbsp;<c41>&nbsp;&nbsp;SCOPE(LV.f)&nbsp;=&nbsp;SCOPE(LV)
</c41><br/><ln>&nbsp;&nbsp;416</ln><a id="416">&nbsp;</a>&nbsp;<c41>```
</c41><br/><ln>&nbsp;&nbsp;417</ln><a id="417">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;418</ln><a id="418">&nbsp;</a>&nbsp;<c41>The&nbsp;scope&nbsp;of&nbsp;a&nbsp;unique&nbsp;referent&nbsp;is&nbsp;the&nbsp;scope&nbsp;of&nbsp;the&nbsp;pointer,&nbsp;since
</c41><br/><ln>&nbsp;&nbsp;419</ln><a id="419">&nbsp;</a>&nbsp;<c41>(barring&nbsp;mutation&nbsp;or&nbsp;moves)&nbsp;the&nbsp;pointer&nbsp;will&nbsp;not&nbsp;be&nbsp;freed&nbsp;until
</c41><br/><ln>&nbsp;&nbsp;420</ln><a id="420">&nbsp;</a>&nbsp;<c41>the&nbsp;pointer&nbsp;itself&nbsp;`LV`&nbsp;goes&nbsp;out&nbsp;of&nbsp;scope:
</c41><br/><ln>&nbsp;&nbsp;421</ln><a id="421">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;422</ln><a id="422">&nbsp;</a>&nbsp;<c41>```notrust
</c41><br/><ln>&nbsp;&nbsp;423</ln><a id="423">&nbsp;</a>&nbsp;<c41>&nbsp;&nbsp;SCOPE(*LV)&nbsp;=&nbsp;SCOPE(LV)&nbsp;if&nbsp;LV&nbsp;has&nbsp;type&nbsp;Box&lt;T&gt;
</c41><br/><ln>&nbsp;&nbsp;424</ln><a id="424">&nbsp;</a>&nbsp;<c41>```
</c41><br/><ln>&nbsp;&nbsp;425</ln><a id="425">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;426</ln><a id="426">&nbsp;</a>&nbsp;<c41>The&nbsp;scope&nbsp;of&nbsp;a&nbsp;managed&nbsp;referent&nbsp;is&nbsp;also&nbsp;the&nbsp;scope&nbsp;of&nbsp;the&nbsp;pointer.&nbsp;&nbsp;This
</c41><br/><ln>&nbsp;&nbsp;427</ln><a id="427">&nbsp;</a>&nbsp;<c41>is&nbsp;a&nbsp;conservative&nbsp;approximation,&nbsp;since&nbsp;there&nbsp;may&nbsp;be&nbsp;other&nbsp;aliases&nbsp;fo
</c41><br/><ln>&nbsp;&nbsp;428</ln><a id="428">&nbsp;</a>&nbsp;<c41>that&nbsp;same&nbsp;managed&nbsp;box&nbsp;that&nbsp;would&nbsp;cause&nbsp;it&nbsp;to&nbsp;live&nbsp;longer:
</c41><br/><ln>&nbsp;&nbsp;429</ln><a id="429">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;430</ln><a id="430">&nbsp;</a>&nbsp;<c41>```notrust
</c41><br/><ln>&nbsp;&nbsp;431</ln><a id="431">&nbsp;</a>&nbsp;<c41>&nbsp;&nbsp;SCOPE(*LV)&nbsp;=&nbsp;SCOPE(LV)&nbsp;if&nbsp;LV&nbsp;has&nbsp;type&nbsp;@T
</c41><br/><ln>&nbsp;&nbsp;432</ln><a id="432">&nbsp;</a>&nbsp;<c41>```
</c41><br/><ln>&nbsp;&nbsp;433</ln><a id="433">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;434</ln><a id="434">&nbsp;</a>&nbsp;<c41>The&nbsp;scope&nbsp;of&nbsp;a&nbsp;borrowed&nbsp;referent&nbsp;is&nbsp;the&nbsp;scope&nbsp;associated&nbsp;with&nbsp;the
</c41><br/><ln>&nbsp;&nbsp;435</ln><a id="435">&nbsp;</a>&nbsp;<c41>pointer.&nbsp;&nbsp;This&nbsp;is&nbsp;a&nbsp;conservative&nbsp;approximation,&nbsp;since&nbsp;the&nbsp;data&nbsp;that
</c41><br/><ln>&nbsp;&nbsp;436</ln><a id="436">&nbsp;</a>&nbsp;<c41>the&nbsp;pointer&nbsp;points&nbsp;at&nbsp;may&nbsp;actually&nbsp;live&nbsp;longer:
</c41><br/><ln>&nbsp;&nbsp;437</ln><a id="437">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;438</ln><a id="438">&nbsp;</a>&nbsp;<c41>```notrust
</c41><br/><ln>&nbsp;&nbsp;439</ln><a id="439">&nbsp;</a>&nbsp;<c41>&nbsp;&nbsp;SCOPE(*LV)&nbsp;=&nbsp;LT&nbsp;if&nbsp;LV&nbsp;has&nbsp;type&nbsp;&amp;'LT&nbsp;T&nbsp;or&nbsp;&amp;'LT&nbsp;mut&nbsp;T
</c41><br/><ln>&nbsp;&nbsp;440</ln><a id="440">&nbsp;</a>&nbsp;<c41>```
</c41><br/><ln>&nbsp;&nbsp;441</ln><a id="441">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;442</ln><a id="442">&nbsp;</a>&nbsp;<c41>###&nbsp;Checking&nbsp;lifetime&nbsp;of&nbsp;variables
</c41><br/><ln>&nbsp;&nbsp;443</ln><a id="443">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;444</ln><a id="444">&nbsp;</a>&nbsp;<c41>The&nbsp;rule&nbsp;for&nbsp;variables&nbsp;states&nbsp;that&nbsp;a&nbsp;variable&nbsp;can&nbsp;only&nbsp;be&nbsp;borrowed&nbsp;a
</c41><br/><ln>&nbsp;&nbsp;445</ln><a id="445">&nbsp;</a>&nbsp;<c41>lifetime&nbsp;`LT`&nbsp;that&nbsp;is&nbsp;a&nbsp;subregion&nbsp;of&nbsp;the&nbsp;variable's&nbsp;scope:
</c41><br/><ln>&nbsp;&nbsp;446</ln><a id="446">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;447</ln><a id="447">&nbsp;</a>&nbsp;<c41>```notrust
</c41><br/><ln>&nbsp;&nbsp;448</ln><a id="448">&nbsp;</a>&nbsp;<c41>LIFETIME(X,&nbsp;LT,&nbsp;MQ)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;L-Local
</c41><br/><ln>&nbsp;&nbsp;449</ln><a id="449">&nbsp;</a>&nbsp;<c41>&nbsp;&nbsp;LT&nbsp;&lt;=&nbsp;SCOPE(X)
</c41><br/><ln>&nbsp;&nbsp;450</ln><a id="450">&nbsp;</a>&nbsp;<c41>```
</c41><br/><ln>&nbsp;&nbsp;451</ln><a id="451">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;452</ln><a id="452">&nbsp;</a>&nbsp;<c41>###&nbsp;Checking&nbsp;lifetime&nbsp;for&nbsp;owned&nbsp;content
</c41><br/><ln>&nbsp;&nbsp;453</ln><a id="453">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;454</ln><a id="454">&nbsp;</a>&nbsp;<c41>The&nbsp;lifetime&nbsp;of&nbsp;a&nbsp;field&nbsp;or&nbsp;owned&nbsp;pointer&nbsp;is&nbsp;the&nbsp;same&nbsp;as&nbsp;the&nbsp;lifetime
</c41><br/><ln>&nbsp;&nbsp;455</ln><a id="455">&nbsp;</a>&nbsp;<c41>of&nbsp;its&nbsp;owner:
</c41><br/><ln>&nbsp;&nbsp;456</ln><a id="456">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;457</ln><a id="457">&nbsp;</a>&nbsp;<c41>```notrust
</c41><br/><ln>&nbsp;&nbsp;458</ln><a id="458">&nbsp;</a>&nbsp;<c41>LIFETIME(LV.f,&nbsp;LT,&nbsp;MQ)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;L-Field
</c41><br/><ln>&nbsp;&nbsp;459</ln><a id="459">&nbsp;</a>&nbsp;<c41>&nbsp;&nbsp;LIFETIME(LV,&nbsp;LT,&nbsp;MQ)
</c41><br/><ln>&nbsp;&nbsp;460</ln><a id="460">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;461</ln><a id="461">&nbsp;</a>&nbsp;<c41>LIFETIME(*LV,&nbsp;LT,&nbsp;MQ)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;L-Deref-Send
</c41><br/><ln>&nbsp;&nbsp;462</ln><a id="462">&nbsp;</a>&nbsp;<c41>&nbsp;&nbsp;TYPE(LV)&nbsp;=&nbsp;Box&lt;Ty&gt;
</c41><br/><ln>&nbsp;&nbsp;463</ln><a id="463">&nbsp;</a>&nbsp;<c41>&nbsp;&nbsp;LIFETIME(LV,&nbsp;LT,&nbsp;MQ)
</c41><br/><ln>&nbsp;&nbsp;464</ln><a id="464">&nbsp;</a>&nbsp;<c41>```
</c41><br/><ln>&nbsp;&nbsp;465</ln><a id="465">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;466</ln><a id="466">&nbsp;</a>&nbsp;<c41>###&nbsp;Checking&nbsp;lifetime&nbsp;for&nbsp;derefs&nbsp;of&nbsp;references
</c41><br/><ln>&nbsp;&nbsp;467</ln><a id="467">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;468</ln><a id="468">&nbsp;</a>&nbsp;<c41>References&nbsp;have&nbsp;a&nbsp;lifetime&nbsp;`LT'`&nbsp;associated&nbsp;with&nbsp;them.&nbsp;&nbsp;The
</c41><br/><ln>&nbsp;&nbsp;469</ln><a id="469">&nbsp;</a>&nbsp;<c41>data&nbsp;they&nbsp;point&nbsp;at&nbsp;has&nbsp;been&nbsp;guaranteed&nbsp;to&nbsp;be&nbsp;valid&nbsp;for&nbsp;at&nbsp;least&nbsp;this
</c41><br/><ln>&nbsp;&nbsp;470</ln><a id="470">&nbsp;</a>&nbsp;<c41>lifetime.&nbsp;Therefore,&nbsp;the&nbsp;borrow&nbsp;is&nbsp;valid&nbsp;so&nbsp;long&nbsp;as&nbsp;the&nbsp;lifetime&nbsp;`LT`
</c41><br/><ln>&nbsp;&nbsp;471</ln><a id="471">&nbsp;</a>&nbsp;<c41>of&nbsp;the&nbsp;borrow&nbsp;is&nbsp;shorter&nbsp;than&nbsp;the&nbsp;lifetime&nbsp;`LT'`&nbsp;of&nbsp;the&nbsp;pointer
</c41><br/><ln>&nbsp;&nbsp;472</ln><a id="472">&nbsp;</a>&nbsp;<c41>itself:
</c41><br/><ln>&nbsp;&nbsp;473</ln><a id="473">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;474</ln><a id="474">&nbsp;</a>&nbsp;<c41>```notrust
</c41><br/><ln>&nbsp;&nbsp;475</ln><a id="475">&nbsp;</a>&nbsp;<c41>LIFETIME(*LV,&nbsp;LT,&nbsp;MQ)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;L-Deref-Borrowed
</c41><br/><ln>&nbsp;&nbsp;476</ln><a id="476">&nbsp;</a>&nbsp;<c41>&nbsp;&nbsp;TYPE(LV)&nbsp;=&nbsp;&amp;LT'&nbsp;Ty&nbsp;OR&nbsp;&amp;LT'&nbsp;mut&nbsp;Ty
</c41><br/><ln>&nbsp;&nbsp;477</ln><a id="477">&nbsp;</a>&nbsp;<c41>&nbsp;&nbsp;LT&nbsp;&lt;=&nbsp;LT'
</c41><br/><ln>&nbsp;&nbsp;478</ln><a id="478">&nbsp;</a>&nbsp;<c41>```
</c41><br/><ln>&nbsp;&nbsp;479</ln><a id="479">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;480</ln><a id="480">&nbsp;</a>&nbsp;<c41>###&nbsp;Checking&nbsp;lifetime&nbsp;for&nbsp;derefs&nbsp;of&nbsp;managed,&nbsp;immutable&nbsp;pointers
</c41><br/><ln>&nbsp;&nbsp;481</ln><a id="481">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;482</ln><a id="482">&nbsp;</a>&nbsp;<c41>Managed&nbsp;pointers&nbsp;are&nbsp;valid&nbsp;so&nbsp;long&nbsp;as&nbsp;the&nbsp;data&nbsp;within&nbsp;them&nbsp;is
</c41><br/><ln>&nbsp;&nbsp;483</ln><a id="483">&nbsp;</a>&nbsp;<c41>*rooted*.&nbsp;There&nbsp;are&nbsp;two&nbsp;ways&nbsp;that&nbsp;this&nbsp;can&nbsp;be&nbsp;achieved.&nbsp;The&nbsp;first&nbsp;is
</c41><br/><ln>&nbsp;&nbsp;484</ln><a id="484">&nbsp;</a>&nbsp;<c41>when&nbsp;the&nbsp;user&nbsp;guarantees&nbsp;such&nbsp;a&nbsp;root&nbsp;will&nbsp;exist.&nbsp;For&nbsp;this&nbsp;to&nbsp;be&nbsp;true,
</c41><br/><ln>&nbsp;&nbsp;485</ln><a id="485">&nbsp;</a>&nbsp;<c41>three&nbsp;conditions&nbsp;must&nbsp;be&nbsp;met:
</c41><br/><ln>&nbsp;&nbsp;486</ln><a id="486">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;487</ln><a id="487">&nbsp;</a>&nbsp;<c41>```notrust
</c41><br/><ln>&nbsp;&nbsp;488</ln><a id="488">&nbsp;</a>&nbsp;<c41>LIFETIME(*LV,&nbsp;LT,&nbsp;MQ)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;L-Deref-Managed-Imm-User-Root
</c41><br/><ln>&nbsp;&nbsp;489</ln><a id="489">&nbsp;</a>&nbsp;<c41>&nbsp;&nbsp;TYPE(LV)&nbsp;=&nbsp;@Ty
</c41><br/><ln>&nbsp;&nbsp;490</ln><a id="490">&nbsp;</a>&nbsp;<c41>&nbsp;&nbsp;LT&nbsp;&lt;=&nbsp;SCOPE(LV)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;(1)
</c41><br/><ln>&nbsp;&nbsp;491</ln><a id="491">&nbsp;</a>&nbsp;<c41>&nbsp;&nbsp;LV&nbsp;is&nbsp;immutable&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;(2)
</c41><br/><ln>&nbsp;&nbsp;492</ln><a id="492">&nbsp;</a>&nbsp;<c41>&nbsp;&nbsp;LV&nbsp;is&nbsp;not&nbsp;moved&nbsp;or&nbsp;not&nbsp;movable&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;(3)
</c41><br/><ln>&nbsp;&nbsp;493</ln><a id="493">&nbsp;</a>&nbsp;<c41>```
</c41><br/><ln>&nbsp;&nbsp;494</ln><a id="494">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;495</ln><a id="495">&nbsp;</a>&nbsp;<c41>Condition&nbsp;(1)&nbsp;guarantees&nbsp;that&nbsp;the&nbsp;managed&nbsp;box&nbsp;will&nbsp;be&nbsp;rooted&nbsp;for&nbsp;at
</c41><br/><ln>&nbsp;&nbsp;496</ln><a id="496">&nbsp;</a>&nbsp;<c41>least&nbsp;the&nbsp;lifetime&nbsp;`LT`&nbsp;of&nbsp;the&nbsp;borrow,&nbsp;presuming&nbsp;that&nbsp;no&nbsp;mutation&nbsp;or
</c41><br/><ln>&nbsp;&nbsp;497</ln><a id="497">&nbsp;</a>&nbsp;<c41>moves&nbsp;occur.&nbsp;Conditions&nbsp;(2)&nbsp;and&nbsp;(3)&nbsp;then&nbsp;serve&nbsp;to&nbsp;guarantee&nbsp;that&nbsp;the
</c41><br/><ln>&nbsp;&nbsp;498</ln><a id="498">&nbsp;</a>&nbsp;<c41>value&nbsp;is&nbsp;not&nbsp;mutated&nbsp;or&nbsp;moved.&nbsp;Note&nbsp;that&nbsp;lvalues&nbsp;are&nbsp;either
</c41><br/><ln>&nbsp;&nbsp;499</ln><a id="499">&nbsp;</a>&nbsp;<c41>(ultimately)&nbsp;owned&nbsp;by&nbsp;a&nbsp;local&nbsp;variable,&nbsp;in&nbsp;which&nbsp;case&nbsp;we&nbsp;can&nbsp;check
</c41><br/><ln>&nbsp;&nbsp;500</ln><a id="500">&nbsp;</a>&nbsp;<c41>whether&nbsp;that&nbsp;local&nbsp;variable&nbsp;is&nbsp;ever&nbsp;moved&nbsp;in&nbsp;its&nbsp;scope,&nbsp;or&nbsp;they&nbsp;are
</c41><br/><ln>&nbsp;&nbsp;501</ln><a id="501">&nbsp;</a>&nbsp;<c41>owned&nbsp;by&nbsp;the&nbsp;referent&nbsp;of&nbsp;an&nbsp;(immutable,&nbsp;due&nbsp;to&nbsp;condition&nbsp;2)&nbsp;managed&nbsp;or
</c41><br/><ln>&nbsp;&nbsp;502</ln><a id="502">&nbsp;</a>&nbsp;<c41>references,&nbsp;in&nbsp;which&nbsp;case&nbsp;moves&nbsp;are&nbsp;not&nbsp;permitted&nbsp;because&nbsp;the
</c41><br/><ln>&nbsp;&nbsp;503</ln><a id="503">&nbsp;</a>&nbsp;<c41>location&nbsp;is&nbsp;aliasable.
</c41><br/><ln>&nbsp;&nbsp;504</ln><a id="504">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;505</ln><a id="505">&nbsp;</a>&nbsp;<c41>If&nbsp;the&nbsp;conditions&nbsp;of&nbsp;`L-Deref-Managed-Imm-User-Root`&nbsp;are&nbsp;not&nbsp;met,&nbsp;then
</c41><br/><ln>&nbsp;&nbsp;506</ln><a id="506">&nbsp;</a>&nbsp;<c41>there&nbsp;is&nbsp;a&nbsp;second&nbsp;alternative.&nbsp;The&nbsp;compiler&nbsp;can&nbsp;attempt&nbsp;to&nbsp;root&nbsp;the
</c41><br/><ln>&nbsp;&nbsp;507</ln><a id="507">&nbsp;</a>&nbsp;<c41>managed&nbsp;pointer&nbsp;itself.&nbsp;This&nbsp;permits&nbsp;great&nbsp;flexibility,&nbsp;because&nbsp;the
</c41><br/><ln>&nbsp;&nbsp;508</ln><a id="508">&nbsp;</a>&nbsp;<c41>location&nbsp;`LV`&nbsp;where&nbsp;the&nbsp;managed&nbsp;pointer&nbsp;is&nbsp;found&nbsp;does&nbsp;not&nbsp;matter,&nbsp;but
</c41><br/><ln>&nbsp;&nbsp;509</ln><a id="509">&nbsp;</a>&nbsp;<c41>there&nbsp;are&nbsp;some&nbsp;limitations.&nbsp;The&nbsp;lifetime&nbsp;of&nbsp;the&nbsp;borrow&nbsp;can&nbsp;only&nbsp;extend
</c41><br/><ln>&nbsp;&nbsp;510</ln><a id="510">&nbsp;</a>&nbsp;<c41>to&nbsp;the&nbsp;innermost&nbsp;enclosing&nbsp;loop&nbsp;or&nbsp;function&nbsp;body.&nbsp;This&nbsp;guarantees&nbsp;that
</c41><br/><ln>&nbsp;&nbsp;511</ln><a id="511">&nbsp;</a>&nbsp;<c41>the&nbsp;compiler&nbsp;never&nbsp;requires&nbsp;an&nbsp;unbounded&nbsp;amount&nbsp;of&nbsp;stack&nbsp;space&nbsp;to
</c41><br/><ln>&nbsp;&nbsp;512</ln><a id="512">&nbsp;</a>&nbsp;<c41>perform&nbsp;the&nbsp;rooting;&nbsp;if&nbsp;this&nbsp;condition&nbsp;were&nbsp;violated,&nbsp;the&nbsp;compiler
</c41><br/><ln>&nbsp;&nbsp;513</ln><a id="513">&nbsp;</a>&nbsp;<c41>might&nbsp;have&nbsp;to&nbsp;accumulate&nbsp;a&nbsp;list&nbsp;of&nbsp;rooted&nbsp;objects,&nbsp;for&nbsp;example&nbsp;if&nbsp;the
</c41><br/><ln>&nbsp;&nbsp;514</ln><a id="514">&nbsp;</a>&nbsp;<c41>borrow&nbsp;occurred&nbsp;inside&nbsp;the&nbsp;body&nbsp;of&nbsp;a&nbsp;loop&nbsp;but&nbsp;the&nbsp;scope&nbsp;of&nbsp;the&nbsp;borrow
</c41><br/><ln>&nbsp;&nbsp;515</ln><a id="515">&nbsp;</a>&nbsp;<c41>extended&nbsp;outside&nbsp;the&nbsp;loop.&nbsp;More&nbsp;formally,&nbsp;the&nbsp;requirement&nbsp;is&nbsp;that
</c41><br/><ln>&nbsp;&nbsp;516</ln><a id="516">&nbsp;</a>&nbsp;<c41>there&nbsp;is&nbsp;no&nbsp;path&nbsp;starting&nbsp;from&nbsp;the&nbsp;borrow&nbsp;that&nbsp;leads&nbsp;back&nbsp;to&nbsp;the
</c41><br/><ln>&nbsp;&nbsp;517</ln><a id="517">&nbsp;</a>&nbsp;<c41>borrow&nbsp;without&nbsp;crossing&nbsp;the&nbsp;exit&nbsp;from&nbsp;the&nbsp;scope&nbsp;`LT`.
</c41><br/><ln>&nbsp;&nbsp;518</ln><a id="518">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;519</ln><a id="519">&nbsp;</a>&nbsp;<c41>The&nbsp;rule&nbsp;for&nbsp;compiler&nbsp;rooting&nbsp;is&nbsp;as&nbsp;follows:
</c41><br/><ln>&nbsp;&nbsp;520</ln><a id="520">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;521</ln><a id="521">&nbsp;</a>&nbsp;<c41>```notrust
</c41><br/><ln>&nbsp;&nbsp;522</ln><a id="522">&nbsp;</a>&nbsp;<c41>LIFETIME(*LV,&nbsp;LT,&nbsp;MQ)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;L-Deref-Managed-Imm-Compiler-Root
</c41><br/><ln>&nbsp;&nbsp;523</ln><a id="523">&nbsp;</a>&nbsp;<c41>&nbsp;&nbsp;TYPE(LV)&nbsp;=&nbsp;@Ty
</c41><br/><ln>&nbsp;&nbsp;524</ln><a id="524">&nbsp;</a>&nbsp;<c41>&nbsp;&nbsp;LT&nbsp;&lt;=&nbsp;innermost&nbsp;enclosing&nbsp;loop/func
</c41><br/><ln>&nbsp;&nbsp;525</ln><a id="525">&nbsp;</a>&nbsp;<c41>&nbsp;&nbsp;ROOT&nbsp;LV&nbsp;at&nbsp;*LV&nbsp;for&nbsp;LT
</c41><br/><ln>&nbsp;&nbsp;526</ln><a id="526">&nbsp;</a>&nbsp;<c41>```
</c41><br/><ln>&nbsp;&nbsp;527</ln><a id="527">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;528</ln><a id="528">&nbsp;</a>&nbsp;<c41>Here&nbsp;I&nbsp;have&nbsp;written&nbsp;`ROOT&nbsp;LV&nbsp;at&nbsp;*LV&nbsp;FOR&nbsp;LT`&nbsp;to&nbsp;indicate&nbsp;that&nbsp;the&nbsp;code
</c41><br/><ln>&nbsp;&nbsp;529</ln><a id="529">&nbsp;</a>&nbsp;<c41>makes&nbsp;a&nbsp;note&nbsp;in&nbsp;a&nbsp;side-table&nbsp;that&nbsp;the&nbsp;box&nbsp;`LV`&nbsp;must&nbsp;be&nbsp;rooted&nbsp;into&nbsp;the
</c41><br/><ln>&nbsp;&nbsp;530</ln><a id="530">&nbsp;</a>&nbsp;<c41>stack&nbsp;when&nbsp;`*LV`&nbsp;is&nbsp;evaluated,&nbsp;and&nbsp;that&nbsp;this&nbsp;root&nbsp;can&nbsp;be&nbsp;released&nbsp;when
</c41><br/><ln>&nbsp;&nbsp;531</ln><a id="531">&nbsp;</a>&nbsp;<c41>the&nbsp;scope&nbsp;`LT`&nbsp;exits.
</c41><br/><ln>&nbsp;&nbsp;532</ln><a id="532">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;533</ln><a id="533">&nbsp;</a>&nbsp;<c41>##&nbsp;Computing&nbsp;the&nbsp;restrictions
</c41><br/><ln>&nbsp;&nbsp;534</ln><a id="534">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;535</ln><a id="535">&nbsp;</a>&nbsp;<c41>The&nbsp;final&nbsp;rules&nbsp;govern&nbsp;the&nbsp;computation&nbsp;of&nbsp;*restrictions*,&nbsp;meaning&nbsp;that
</c41><br/><ln>&nbsp;&nbsp;536</ln><a id="536">&nbsp;</a>&nbsp;<c41>we&nbsp;compute&nbsp;the&nbsp;set&nbsp;of&nbsp;actions&nbsp;that&nbsp;will&nbsp;be&nbsp;illegal&nbsp;for&nbsp;the&nbsp;life&nbsp;of&nbsp;the
</c41><br/><ln>&nbsp;&nbsp;537</ln><a id="537">&nbsp;</a>&nbsp;<c41>loan.&nbsp;The&nbsp;predicate&nbsp;is&nbsp;written&nbsp;`RESTRICTIONS(LV,&nbsp;LT,&nbsp;ACTIONS)&nbsp;=
</c41><br/><ln>&nbsp;&nbsp;538</ln><a id="538">&nbsp;</a>&nbsp;<c41>RESTRICTION*`,&nbsp;which&nbsp;can&nbsp;be&nbsp;read&nbsp;"in&nbsp;order&nbsp;to&nbsp;prevent&nbsp;`ACTIONS`&nbsp;from
</c41><br/><ln>&nbsp;&nbsp;539</ln><a id="539">&nbsp;</a>&nbsp;<c41>occuring&nbsp;on&nbsp;`LV`,&nbsp;the&nbsp;restrictions&nbsp;`RESTRICTION*`&nbsp;must&nbsp;be&nbsp;respected
</c41><br/><ln>&nbsp;&nbsp;540</ln><a id="540">&nbsp;</a>&nbsp;<c41>for&nbsp;the&nbsp;lifetime&nbsp;of&nbsp;the&nbsp;loan".
</c41><br/><ln>&nbsp;&nbsp;541</ln><a id="541">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;542</ln><a id="542">&nbsp;</a>&nbsp;<c41>Note&nbsp;that&nbsp;there&nbsp;is&nbsp;an&nbsp;initial&nbsp;set&nbsp;of&nbsp;restrictions:&nbsp;these&nbsp;restrictions
</c41><br/><ln>&nbsp;&nbsp;543</ln><a id="543">&nbsp;</a>&nbsp;<c41>are&nbsp;computed&nbsp;based&nbsp;on&nbsp;the&nbsp;kind&nbsp;of&nbsp;borrow:
</c41><br/><ln>&nbsp;&nbsp;544</ln><a id="544">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;545</ln><a id="545">&nbsp;</a>&nbsp;<c41>```notrust
</c41><br/><ln>&nbsp;&nbsp;546</ln><a id="546">&nbsp;</a>&nbsp;<c41>&amp;mut&nbsp;LV&nbsp;=&gt;&nbsp;&nbsp;&nbsp;RESTRICTIONS(LV,&nbsp;LT,&nbsp;MUTATE|CLAIM|FREEZE)
</c41><br/><ln>&nbsp;&nbsp;547</ln><a id="547">&nbsp;</a>&nbsp;<c41>&amp;LV&nbsp;=&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RESTRICTIONS(LV,&nbsp;LT,&nbsp;MUTATE|CLAIM)
</c41><br/><ln>&nbsp;&nbsp;548</ln><a id="548">&nbsp;</a>&nbsp;<c41>&amp;const&nbsp;LV&nbsp;=&gt;&nbsp;RESTRICTIONS(LV,&nbsp;LT,&nbsp;[])
</c41><br/><ln>&nbsp;&nbsp;549</ln><a id="549">&nbsp;</a>&nbsp;<c41>```
</c41><br/><ln>&nbsp;&nbsp;550</ln><a id="550">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;551</ln><a id="551">&nbsp;</a>&nbsp;<c41>The&nbsp;reasoning&nbsp;here&nbsp;is&nbsp;that&nbsp;a&nbsp;mutable&nbsp;borrow&nbsp;must&nbsp;be&nbsp;the&nbsp;only&nbsp;writer,
</c41><br/><ln>&nbsp;&nbsp;552</ln><a id="552">&nbsp;</a>&nbsp;<c41>therefore&nbsp;it&nbsp;prevents&nbsp;other&nbsp;writes&nbsp;(`MUTATE`),&nbsp;mutable&nbsp;borrows
</c41><br/><ln>&nbsp;&nbsp;553</ln><a id="553">&nbsp;</a>&nbsp;<c41>(`CLAIM`),&nbsp;and&nbsp;immutable&nbsp;borrows&nbsp;(`FREEZE`).&nbsp;An&nbsp;immutable&nbsp;borrow
</c41><br/><ln>&nbsp;&nbsp;554</ln><a id="554">&nbsp;</a>&nbsp;<c41>permits&nbsp;other&nbsp;immutable&nbsp;borows&nbsp;but&nbsp;forbids&nbsp;writes&nbsp;and&nbsp;mutable&nbsp;borows.
</c41><br/><ln>&nbsp;&nbsp;555</ln><a id="555">&nbsp;</a>&nbsp;<c41>Finally,&nbsp;a&nbsp;const&nbsp;borrow&nbsp;just&nbsp;wants&nbsp;to&nbsp;be&nbsp;sure&nbsp;that&nbsp;the&nbsp;value&nbsp;is&nbsp;not
</c41><br/><ln>&nbsp;&nbsp;556</ln><a id="556">&nbsp;</a>&nbsp;<c41>moved&nbsp;out&nbsp;from&nbsp;under&nbsp;it,&nbsp;so&nbsp;no&nbsp;actions&nbsp;are&nbsp;forbidden.
</c41><br/><ln>&nbsp;&nbsp;557</ln><a id="557">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;558</ln><a id="558">&nbsp;</a>&nbsp;<c41>###&nbsp;Restrictions&nbsp;for&nbsp;loans&nbsp;of&nbsp;a&nbsp;local&nbsp;variable
</c41><br/><ln>&nbsp;&nbsp;559</ln><a id="559">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;560</ln><a id="560">&nbsp;</a>&nbsp;<c41>The&nbsp;simplest&nbsp;case&nbsp;is&nbsp;a&nbsp;borrow&nbsp;of&nbsp;a&nbsp;local&nbsp;variable&nbsp;`X`:
</c41><br/><ln>&nbsp;&nbsp;561</ln><a id="561">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;562</ln><a id="562">&nbsp;</a>&nbsp;<c41>```notrust
</c41><br/><ln>&nbsp;&nbsp;563</ln><a id="563">&nbsp;</a>&nbsp;<c41>RESTRICTIONS(X,&nbsp;LT,&nbsp;ACTIONS)&nbsp;=&nbsp;(X,&nbsp;ACTIONS)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;R-Variable
</c41><br/><ln>&nbsp;&nbsp;564</ln><a id="564">&nbsp;</a>&nbsp;<c41>```
</c41><br/><ln>&nbsp;&nbsp;565</ln><a id="565">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;566</ln><a id="566">&nbsp;</a>&nbsp;<c41>In&nbsp;such&nbsp;cases&nbsp;we&nbsp;just&nbsp;record&nbsp;the&nbsp;actions&nbsp;that&nbsp;are&nbsp;not&nbsp;permitted.
</c41><br/><ln>&nbsp;&nbsp;567</ln><a id="567">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;568</ln><a id="568">&nbsp;</a>&nbsp;<c41>###&nbsp;Restrictions&nbsp;for&nbsp;loans&nbsp;of&nbsp;fields
</c41><br/><ln>&nbsp;&nbsp;569</ln><a id="569">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;570</ln><a id="570">&nbsp;</a>&nbsp;<c41>Restricting&nbsp;a&nbsp;field&nbsp;is&nbsp;the&nbsp;same&nbsp;as&nbsp;restricting&nbsp;the&nbsp;owner&nbsp;of&nbsp;that
</c41><br/><ln>&nbsp;&nbsp;571</ln><a id="571">&nbsp;</a>&nbsp;<c41>field:
</c41><br/><ln>&nbsp;&nbsp;572</ln><a id="572">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;573</ln><a id="573">&nbsp;</a>&nbsp;<c41>```notrust
</c41><br/><ln>&nbsp;&nbsp;574</ln><a id="574">&nbsp;</a>&nbsp;<c41>RESTRICTIONS(LV.f,&nbsp;LT,&nbsp;ACTIONS)&nbsp;=&nbsp;RS,&nbsp;(LV.f,&nbsp;ACTIONS)&nbsp;&nbsp;//&nbsp;R-Field
</c41><br/><ln>&nbsp;&nbsp;575</ln><a id="575">&nbsp;</a>&nbsp;<c41>&nbsp;&nbsp;RESTRICTIONS(LV,&nbsp;LT,&nbsp;ACTIONS)&nbsp;=&nbsp;RS
</c41><br/><ln>&nbsp;&nbsp;576</ln><a id="576">&nbsp;</a>&nbsp;<c41>```
</c41><br/><ln>&nbsp;&nbsp;577</ln><a id="577">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;578</ln><a id="578">&nbsp;</a>&nbsp;<c41>The&nbsp;reasoning&nbsp;here&nbsp;is&nbsp;as&nbsp;follows.&nbsp;If&nbsp;the&nbsp;field&nbsp;must&nbsp;not&nbsp;be&nbsp;mutated,
</c41><br/><ln>&nbsp;&nbsp;579</ln><a id="579">&nbsp;</a>&nbsp;<c41>then&nbsp;you&nbsp;must&nbsp;not&nbsp;mutate&nbsp;the&nbsp;owner&nbsp;of&nbsp;the&nbsp;field&nbsp;either,&nbsp;since&nbsp;that
</c41><br/><ln>&nbsp;&nbsp;580</ln><a id="580">&nbsp;</a>&nbsp;<c41>would&nbsp;indirectly&nbsp;modify&nbsp;the&nbsp;field.&nbsp;Similarly,&nbsp;if&nbsp;the&nbsp;field&nbsp;cannot&nbsp;be
</c41><br/><ln>&nbsp;&nbsp;581</ln><a id="581">&nbsp;</a>&nbsp;<c41>frozen&nbsp;or&nbsp;aliased,&nbsp;we&nbsp;cannot&nbsp;allow&nbsp;the&nbsp;owner&nbsp;to&nbsp;be&nbsp;frozen&nbsp;or&nbsp;aliased,
</c41><br/><ln>&nbsp;&nbsp;582</ln><a id="582">&nbsp;</a>&nbsp;<c41>since&nbsp;doing&nbsp;so&nbsp;indirectly&nbsp;freezes/aliases&nbsp;the&nbsp;field.&nbsp;This&nbsp;is&nbsp;the
</c41><br/><ln>&nbsp;&nbsp;583</ln><a id="583">&nbsp;</a>&nbsp;<c41>origin&nbsp;of&nbsp;inherited&nbsp;mutability.
</c41><br/><ln>&nbsp;&nbsp;584</ln><a id="584">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;585</ln><a id="585">&nbsp;</a>&nbsp;<c41>###&nbsp;Restrictions&nbsp;for&nbsp;loans&nbsp;of&nbsp;owned&nbsp;referents
</c41><br/><ln>&nbsp;&nbsp;586</ln><a id="586">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;587</ln><a id="587">&nbsp;</a>&nbsp;<c41>Because&nbsp;the&nbsp;mutability&nbsp;of&nbsp;owned&nbsp;referents&nbsp;is&nbsp;inherited,&nbsp;restricting&nbsp;an
</c41><br/><ln>&nbsp;&nbsp;588</ln><a id="588">&nbsp;</a>&nbsp;<c41>owned&nbsp;referent&nbsp;is&nbsp;similar&nbsp;to&nbsp;restricting&nbsp;a&nbsp;field,&nbsp;in&nbsp;that&nbsp;it&nbsp;implies
</c41><br/><ln>&nbsp;&nbsp;589</ln><a id="589">&nbsp;</a>&nbsp;<c41>restrictions&nbsp;on&nbsp;the&nbsp;pointer.&nbsp;However,&nbsp;owned&nbsp;pointers&nbsp;have&nbsp;an&nbsp;important
</c41><br/><ln>&nbsp;&nbsp;590</ln><a id="590">&nbsp;</a>&nbsp;<c41>twist:&nbsp;if&nbsp;the&nbsp;owner&nbsp;`LV`&nbsp;is&nbsp;mutated,&nbsp;that&nbsp;causes&nbsp;the&nbsp;owned&nbsp;referent
</c41><br/><ln>&nbsp;&nbsp;591</ln><a id="591">&nbsp;</a>&nbsp;<c41>`*LV`&nbsp;to&nbsp;be&nbsp;freed!&nbsp;So&nbsp;whenever&nbsp;an&nbsp;owned&nbsp;referent&nbsp;`*LV`&nbsp;is&nbsp;borrowed,&nbsp;we
</c41><br/><ln>&nbsp;&nbsp;592</ln><a id="592">&nbsp;</a>&nbsp;<c41>must&nbsp;prevent&nbsp;the&nbsp;owned&nbsp;pointer&nbsp;`LV`&nbsp;from&nbsp;being&nbsp;mutated,&nbsp;which&nbsp;means
</c41><br/><ln>&nbsp;&nbsp;593</ln><a id="593">&nbsp;</a>&nbsp;<c41>that&nbsp;we&nbsp;always&nbsp;add&nbsp;`MUTATE`&nbsp;and&nbsp;`CLAIM`&nbsp;to&nbsp;the&nbsp;restriction&nbsp;set&nbsp;imposed
</c41><br/><ln>&nbsp;&nbsp;594</ln><a id="594">&nbsp;</a>&nbsp;<c41>on&nbsp;`LV`:
</c41><br/><ln>&nbsp;&nbsp;595</ln><a id="595">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;596</ln><a id="596">&nbsp;</a>&nbsp;<c41>```notrust
</c41><br/><ln>&nbsp;&nbsp;597</ln><a id="597">&nbsp;</a>&nbsp;<c41>RESTRICTIONS(*LV,&nbsp;LT,&nbsp;ACTIONS)&nbsp;=&nbsp;RS,&nbsp;(*LV,&nbsp;ACTIONS)&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;R-Deref-Send-Pointer
</c41><br/><ln>&nbsp;&nbsp;598</ln><a id="598">&nbsp;</a>&nbsp;<c41>&nbsp;&nbsp;TYPE(LV)&nbsp;=&nbsp;Box&lt;Ty&gt;
</c41><br/><ln>&nbsp;&nbsp;599</ln><a id="599">&nbsp;</a>&nbsp;<c41>&nbsp;&nbsp;RESTRICTIONS(LV,&nbsp;LT,&nbsp;ACTIONS|MUTATE|CLAIM)&nbsp;=&nbsp;RS
</c41><br/><ln>&nbsp;&nbsp;600</ln><a id="600">&nbsp;</a>&nbsp;<c41>```
</c41><br/><ln>&nbsp;&nbsp;601</ln><a id="601">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;602</ln><a id="602">&nbsp;</a>&nbsp;<c41>###&nbsp;Restrictions&nbsp;for&nbsp;loans&nbsp;of&nbsp;immutable&nbsp;managed/borrowed&nbsp;referents
</c41><br/><ln>&nbsp;&nbsp;603</ln><a id="603">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;604</ln><a id="604">&nbsp;</a>&nbsp;<c41>Immutable&nbsp;managed/borrowed&nbsp;referents&nbsp;are&nbsp;freely&nbsp;aliasable,&nbsp;meaning&nbsp;that
</c41><br/><ln>&nbsp;&nbsp;605</ln><a id="605">&nbsp;</a>&nbsp;<c41>the&nbsp;compiler&nbsp;does&nbsp;not&nbsp;prevent&nbsp;you&nbsp;from&nbsp;copying&nbsp;the&nbsp;pointer.&nbsp;&nbsp;This
</c41><br/><ln>&nbsp;&nbsp;606</ln><a id="606">&nbsp;</a>&nbsp;<c41>implies&nbsp;that&nbsp;issuing&nbsp;restrictions&nbsp;is&nbsp;useless.&nbsp;We&nbsp;might&nbsp;prevent&nbsp;the
</c41><br/><ln>&nbsp;&nbsp;607</ln><a id="607">&nbsp;</a>&nbsp;<c41>user&nbsp;from&nbsp;acting&nbsp;on&nbsp;`*LV`&nbsp;itself,&nbsp;but&nbsp;there&nbsp;could&nbsp;be&nbsp;another&nbsp;path
</c41><br/><ln>&nbsp;&nbsp;608</ln><a id="608">&nbsp;</a>&nbsp;<c41>`*LV1`&nbsp;that&nbsp;refers&nbsp;to&nbsp;the&nbsp;exact&nbsp;same&nbsp;memory,&nbsp;and&nbsp;we&nbsp;would&nbsp;not&nbsp;be
</c41><br/><ln>&nbsp;&nbsp;609</ln><a id="609">&nbsp;</a>&nbsp;<c41>restricting&nbsp;that&nbsp;path.&nbsp;Therefore,&nbsp;the&nbsp;rule&nbsp;for&nbsp;`&amp;Ty`&nbsp;and&nbsp;`@Ty`
</c41><br/><ln>&nbsp;&nbsp;610</ln><a id="610">&nbsp;</a>&nbsp;<c41>pointers&nbsp;always&nbsp;returns&nbsp;an&nbsp;empty&nbsp;set&nbsp;of&nbsp;restrictions,&nbsp;and&nbsp;it&nbsp;only
</c41><br/><ln>&nbsp;&nbsp;611</ln><a id="611">&nbsp;</a>&nbsp;<c41>permits&nbsp;restricting&nbsp;`MUTATE`&nbsp;and&nbsp;`CLAIM`&nbsp;actions:
</c41><br/><ln>&nbsp;&nbsp;612</ln><a id="612">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;613</ln><a id="613">&nbsp;</a>&nbsp;<c41>```notrust
</c41><br/><ln>&nbsp;&nbsp;614</ln><a id="614">&nbsp;</a>&nbsp;<c41>RESTRICTIONS(*LV,&nbsp;LT,&nbsp;ACTIONS)&nbsp;=&nbsp;[]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;R-Deref-Imm-Managed
</c41><br/><ln>&nbsp;&nbsp;615</ln><a id="615">&nbsp;</a>&nbsp;<c41>&nbsp;&nbsp;TYPE(LV)&nbsp;=&nbsp;@Ty
</c41><br/><ln>&nbsp;&nbsp;616</ln><a id="616">&nbsp;</a>&nbsp;<c41>&nbsp;&nbsp;ACTIONS&nbsp;subset&nbsp;of&nbsp;[MUTATE,&nbsp;CLAIM]
</c41><br/><ln>&nbsp;&nbsp;617</ln><a id="617">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;618</ln><a id="618">&nbsp;</a>&nbsp;<c41>RESTRICTIONS(*LV,&nbsp;LT,&nbsp;ACTIONS)&nbsp;=&nbsp;[]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;R-Deref-Imm-Borrowed
</c41><br/><ln>&nbsp;&nbsp;619</ln><a id="619">&nbsp;</a>&nbsp;<c41>&nbsp;&nbsp;TYPE(LV)&nbsp;=&nbsp;&amp;LT'&nbsp;Ty
</c41><br/><ln>&nbsp;&nbsp;620</ln><a id="620">&nbsp;</a>&nbsp;<c41>&nbsp;&nbsp;LT&nbsp;&lt;=&nbsp;LT'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;(1)
</c41><br/><ln>&nbsp;&nbsp;621</ln><a id="621">&nbsp;</a>&nbsp;<c41>&nbsp;&nbsp;ACTIONS&nbsp;subset&nbsp;of&nbsp;[MUTATE,&nbsp;CLAIM]
</c41><br/><ln>&nbsp;&nbsp;622</ln><a id="622">&nbsp;</a>&nbsp;<c41>```
</c41><br/><ln>&nbsp;&nbsp;623</ln><a id="623">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;624</ln><a id="624">&nbsp;</a>&nbsp;<c41>The&nbsp;reason&nbsp;that&nbsp;we&nbsp;can&nbsp;restrict&nbsp;`MUTATE`&nbsp;and&nbsp;`CLAIM`&nbsp;actions&nbsp;even
</c41><br/><ln>&nbsp;&nbsp;625</ln><a id="625">&nbsp;</a>&nbsp;<c41>without&nbsp;a&nbsp;restrictions&nbsp;list&nbsp;is&nbsp;that&nbsp;it&nbsp;is&nbsp;never&nbsp;legal&nbsp;to&nbsp;mutate&nbsp;nor&nbsp;to
</c41><br/><ln>&nbsp;&nbsp;626</ln><a id="626">&nbsp;</a>&nbsp;<c41>borrow&nbsp;mutably&nbsp;the&nbsp;contents&nbsp;of&nbsp;a&nbsp;`&amp;Ty`&nbsp;or&nbsp;`@Ty`&nbsp;pointer.&nbsp;In&nbsp;other
</c41><br/><ln>&nbsp;&nbsp;627</ln><a id="627">&nbsp;</a>&nbsp;<c41>words,&nbsp;those&nbsp;restrictions&nbsp;are&nbsp;already&nbsp;inherent&nbsp;in&nbsp;the&nbsp;type.
</c41><br/><ln>&nbsp;&nbsp;628</ln><a id="628">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;629</ln><a id="629">&nbsp;</a>&nbsp;<c41>Clause&nbsp;(1)&nbsp;in&nbsp;the&nbsp;rule&nbsp;for&nbsp;`&amp;Ty`&nbsp;deserves&nbsp;mention.&nbsp;Here&nbsp;I
</c41><br/><ln>&nbsp;&nbsp;630</ln><a id="630">&nbsp;</a>&nbsp;<c41>specify&nbsp;that&nbsp;the&nbsp;lifetime&nbsp;of&nbsp;the&nbsp;loan&nbsp;must&nbsp;be&nbsp;less&nbsp;than&nbsp;the&nbsp;lifetime
</c41><br/><ln>&nbsp;&nbsp;631</ln><a id="631">&nbsp;</a>&nbsp;<c41>of&nbsp;the&nbsp;`&amp;Ty`&nbsp;pointer.&nbsp;In&nbsp;simple&nbsp;cases,&nbsp;this&nbsp;clause&nbsp;is&nbsp;redundant,&nbsp;since
</c41><br/><ln>&nbsp;&nbsp;632</ln><a id="632">&nbsp;</a>&nbsp;<c41>the&nbsp;`LIFETIME()`&nbsp;function&nbsp;will&nbsp;already&nbsp;enforce&nbsp;the&nbsp;required&nbsp;rule:
</c41><br/><ln>&nbsp;&nbsp;633</ln><a id="633">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;634</ln><a id="634">&nbsp;</a>&nbsp;<c41>```
</c41><br/><ln>&nbsp;&nbsp;635</ln><a id="635">&nbsp;</a>&nbsp;<c41>fn&nbsp;foo(point:&nbsp;&amp;'a&nbsp;Point)&nbsp;-&gt;&nbsp;&amp;'static&nbsp;f32&nbsp;{
</c41><br/><ln>&nbsp;&nbsp;636</ln><a id="636">&nbsp;</a>&nbsp;<c41>&nbsp;&nbsp;&nbsp;&nbsp;&amp;point.x&nbsp;//&nbsp;Error
</c41><br/><ln>&nbsp;&nbsp;637</ln><a id="637">&nbsp;</a>&nbsp;<c41>}
</c41><br/><ln>&nbsp;&nbsp;638</ln><a id="638">&nbsp;</a>&nbsp;<c41>```
</c41><br/><ln>&nbsp;&nbsp;639</ln><a id="639">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;640</ln><a id="640">&nbsp;</a>&nbsp;<c41>The&nbsp;above&nbsp;example&nbsp;fails&nbsp;to&nbsp;compile&nbsp;both&nbsp;because&nbsp;of&nbsp;clause&nbsp;(1)&nbsp;above
</c41><br/><ln>&nbsp;&nbsp;641</ln><a id="641">&nbsp;</a>&nbsp;<c41>but&nbsp;also&nbsp;by&nbsp;the&nbsp;basic&nbsp;`LIFETIME()`&nbsp;check.&nbsp;However,&nbsp;in&nbsp;more&nbsp;advanced
</c41><br/><ln>&nbsp;&nbsp;642</ln><a id="642">&nbsp;</a>&nbsp;<c41>examples&nbsp;involving&nbsp;multiple&nbsp;nested&nbsp;pointers,&nbsp;clause&nbsp;(1)&nbsp;is&nbsp;needed:
</c41><br/><ln>&nbsp;&nbsp;643</ln><a id="643">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;644</ln><a id="644">&nbsp;</a>&nbsp;<c41>```
</c41><br/><ln>&nbsp;&nbsp;645</ln><a id="645">&nbsp;</a>&nbsp;<c41>fn&nbsp;foo(point:&nbsp;&amp;'a&nbsp;&amp;'b&nbsp;mut&nbsp;Point)&nbsp;-&gt;&nbsp;&amp;'b&nbsp;f32&nbsp;{
</c41><br/><ln>&nbsp;&nbsp;646</ln><a id="646">&nbsp;</a>&nbsp;<c41>&nbsp;&nbsp;&nbsp;&nbsp;&amp;point.x&nbsp;//&nbsp;Error
</c41><br/><ln>&nbsp;&nbsp;647</ln><a id="647">&nbsp;</a>&nbsp;<c41>}
</c41><br/><ln>&nbsp;&nbsp;648</ln><a id="648">&nbsp;</a>&nbsp;<c41>```
</c41><br/><ln>&nbsp;&nbsp;649</ln><a id="649">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;650</ln><a id="650">&nbsp;</a>&nbsp;<c41>The&nbsp;`LIFETIME`&nbsp;rule&nbsp;here&nbsp;would&nbsp;accept&nbsp;`'b`&nbsp;because,&nbsp;in&nbsp;fact,&nbsp;the
</c41><br/><ln>&nbsp;&nbsp;651</ln><a id="651">&nbsp;</a>&nbsp;<c41>*memory&nbsp;is*&nbsp;guaranteed&nbsp;to&nbsp;remain&nbsp;valid&nbsp;(i.e.,&nbsp;not&nbsp;be&nbsp;freed)&nbsp;for&nbsp;the
</c41><br/><ln>&nbsp;&nbsp;652</ln><a id="652">&nbsp;</a>&nbsp;<c41>lifetime&nbsp;`'b`,&nbsp;since&nbsp;the&nbsp;`&amp;mut`&nbsp;pointer&nbsp;is&nbsp;valid&nbsp;for&nbsp;`'b`.&nbsp;However,&nbsp;we
</c41><br/><ln>&nbsp;&nbsp;653</ln><a id="653">&nbsp;</a>&nbsp;<c41>are&nbsp;returning&nbsp;an&nbsp;immutable&nbsp;reference,&nbsp;so&nbsp;we&nbsp;need&nbsp;the&nbsp;memory&nbsp;to&nbsp;be&nbsp;both
</c41><br/><ln>&nbsp;&nbsp;654</ln><a id="654">&nbsp;</a>&nbsp;<c41>valid&nbsp;and&nbsp;immutable.&nbsp;Even&nbsp;though&nbsp;`point.x`&nbsp;is&nbsp;referenced&nbsp;by&nbsp;an&nbsp;`&amp;mut`
</c41><br/><ln>&nbsp;&nbsp;655</ln><a id="655">&nbsp;</a>&nbsp;<c41>pointer,&nbsp;it&nbsp;can&nbsp;still&nbsp;be&nbsp;considered&nbsp;immutable&nbsp;so&nbsp;long&nbsp;as&nbsp;that&nbsp;`&amp;mut`
</c41><br/><ln>&nbsp;&nbsp;656</ln><a id="656">&nbsp;</a>&nbsp;<c41>pointer&nbsp;is&nbsp;found&nbsp;in&nbsp;an&nbsp;aliased&nbsp;location.&nbsp;That&nbsp;means&nbsp;the&nbsp;memory&nbsp;is
</c41><br/><ln>&nbsp;&nbsp;657</ln><a id="657">&nbsp;</a>&nbsp;<c41>guaranteed&nbsp;to&nbsp;be&nbsp;*immutable*&nbsp;for&nbsp;the&nbsp;lifetime&nbsp;of&nbsp;the&nbsp;`&amp;`&nbsp;pointer,
</c41><br/><ln>&nbsp;&nbsp;658</ln><a id="658">&nbsp;</a>&nbsp;<c41>which&nbsp;is&nbsp;only&nbsp;`'a`,&nbsp;not&nbsp;`'b`.&nbsp;Hence&nbsp;this&nbsp;example&nbsp;yields&nbsp;an&nbsp;error.
</c41><br/><ln>&nbsp;&nbsp;659</ln><a id="659">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;660</ln><a id="660">&nbsp;</a>&nbsp;<c41>As&nbsp;a&nbsp;final&nbsp;twist,&nbsp;consider&nbsp;the&nbsp;case&nbsp;of&nbsp;two&nbsp;nested&nbsp;*immutable*
</c41><br/><ln>&nbsp;&nbsp;661</ln><a id="661">&nbsp;</a>&nbsp;<c41>pointers,&nbsp;rather&nbsp;than&nbsp;a&nbsp;mutable&nbsp;pointer&nbsp;within&nbsp;an&nbsp;immutable&nbsp;one:
</c41><br/><ln>&nbsp;&nbsp;662</ln><a id="662">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;663</ln><a id="663">&nbsp;</a>&nbsp;<c41>```
</c41><br/><ln>&nbsp;&nbsp;664</ln><a id="664">&nbsp;</a>&nbsp;<c41>fn&nbsp;foo(point:&nbsp;&amp;'a&nbsp;&amp;'b&nbsp;Point)&nbsp;-&gt;&nbsp;&amp;'b&nbsp;f32&nbsp;{
</c41><br/><ln>&nbsp;&nbsp;665</ln><a id="665">&nbsp;</a>&nbsp;<c41>&nbsp;&nbsp;&nbsp;&nbsp;&amp;point.x&nbsp;//&nbsp;OK
</c41><br/><ln>&nbsp;&nbsp;666</ln><a id="666">&nbsp;</a>&nbsp;<c41>}
</c41><br/><ln>&nbsp;&nbsp;667</ln><a id="667">&nbsp;</a>&nbsp;<c41>```
</c41><br/><ln>&nbsp;&nbsp;668</ln><a id="668">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;669</ln><a id="669">&nbsp;</a>&nbsp;<c41>This&nbsp;function&nbsp;is&nbsp;legal.&nbsp;The&nbsp;reason&nbsp;for&nbsp;this&nbsp;is&nbsp;that&nbsp;the&nbsp;inner&nbsp;pointer
</c41><br/><ln>&nbsp;&nbsp;670</ln><a id="670">&nbsp;</a>&nbsp;<c41>(`*point&nbsp;:&nbsp;&amp;'b&nbsp;Point`)&nbsp;is&nbsp;enough&nbsp;to&nbsp;guarantee&nbsp;the&nbsp;memory&nbsp;is&nbsp;immutable
</c41><br/><ln>&nbsp;&nbsp;671</ln><a id="671">&nbsp;</a>&nbsp;<c41>and&nbsp;valid&nbsp;for&nbsp;the&nbsp;lifetime&nbsp;`'b`.&nbsp;&nbsp;This&nbsp;is&nbsp;reflected&nbsp;in
</c41><br/><ln>&nbsp;&nbsp;672</ln><a id="672">&nbsp;</a>&nbsp;<c41>`RESTRICTIONS()`&nbsp;by&nbsp;the&nbsp;fact&nbsp;that&nbsp;we&nbsp;do&nbsp;not&nbsp;recurse&nbsp;(i.e.,&nbsp;we&nbsp;impose
</c41><br/><ln>&nbsp;&nbsp;673</ln><a id="673">&nbsp;</a>&nbsp;<c41>no&nbsp;restrictions&nbsp;on&nbsp;`LV`,&nbsp;which&nbsp;in&nbsp;this&nbsp;particular&nbsp;case&nbsp;is&nbsp;the&nbsp;pointer
</c41><br/><ln>&nbsp;&nbsp;674</ln><a id="674">&nbsp;</a>&nbsp;<c41>`point&nbsp;:&nbsp;&amp;'a&nbsp;&amp;'b&nbsp;Point`).
</c41><br/><ln>&nbsp;&nbsp;675</ln><a id="675">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;676</ln><a id="676">&nbsp;</a>&nbsp;<c41>####&nbsp;Why&nbsp;both&nbsp;`LIFETIME()`&nbsp;and&nbsp;`RESTRICTIONS()`?
</c41><br/><ln>&nbsp;&nbsp;677</ln><a id="677">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;678</ln><a id="678">&nbsp;</a>&nbsp;<c41>Given&nbsp;the&nbsp;previous&nbsp;text,&nbsp;it&nbsp;might&nbsp;seem&nbsp;that&nbsp;`LIFETIME`&nbsp;and
</c41><br/><ln>&nbsp;&nbsp;679</ln><a id="679">&nbsp;</a>&nbsp;<c41>`RESTRICTIONS`&nbsp;should&nbsp;be&nbsp;folded&nbsp;together&nbsp;into&nbsp;one&nbsp;check,&nbsp;but&nbsp;there&nbsp;is
</c41><br/><ln>&nbsp;&nbsp;680</ln><a id="680">&nbsp;</a>&nbsp;<c41>a&nbsp;reason&nbsp;that&nbsp;they&nbsp;are&nbsp;separated.&nbsp;They&nbsp;answer&nbsp;separate&nbsp;concerns.
</c41><br/><ln>&nbsp;&nbsp;681</ln><a id="681">&nbsp;</a>&nbsp;<c41>The&nbsp;rules&nbsp;pertaining&nbsp;to&nbsp;`LIFETIME`&nbsp;exist&nbsp;to&nbsp;ensure&nbsp;that&nbsp;we&nbsp;don't
</c41><br/><ln>&nbsp;&nbsp;682</ln><a id="682">&nbsp;</a>&nbsp;<c41>create&nbsp;a&nbsp;borrowed&nbsp;pointer&nbsp;that&nbsp;outlives&nbsp;the&nbsp;memory&nbsp;it&nbsp;points&nbsp;at.&nbsp;So
</c41><br/><ln>&nbsp;&nbsp;683</ln><a id="683">&nbsp;</a>&nbsp;<c41>`LIFETIME`&nbsp;prevents&nbsp;a&nbsp;function&nbsp;like&nbsp;this:
</c41><br/><ln>&nbsp;&nbsp;684</ln><a id="684">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;685</ln><a id="685">&nbsp;</a>&nbsp;<c41>```
</c41><br/><ln>&nbsp;&nbsp;686</ln><a id="686">&nbsp;</a>&nbsp;<c41>fn&nbsp;get_1&lt;'a&gt;()&nbsp;-&gt;&nbsp;&amp;'a&nbsp;int&nbsp;{
</c41><br/><ln>&nbsp;&nbsp;687</ln><a id="687">&nbsp;</a>&nbsp;<c41>&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;x&nbsp;=&nbsp;1;
</c41><br/><ln>&nbsp;&nbsp;688</ln><a id="688">&nbsp;</a>&nbsp;<c41>&nbsp;&nbsp;&nbsp;&nbsp;&amp;x
</c41><br/><ln>&nbsp;&nbsp;689</ln><a id="689">&nbsp;</a>&nbsp;<c41>}
</c41><br/><ln>&nbsp;&nbsp;690</ln><a id="690">&nbsp;</a>&nbsp;<c41>```
</c41><br/><ln>&nbsp;&nbsp;691</ln><a id="691">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;692</ln><a id="692">&nbsp;</a>&nbsp;<c41>Here&nbsp;we&nbsp;would&nbsp;be&nbsp;returning&nbsp;a&nbsp;pointer&nbsp;into&nbsp;the&nbsp;stack.&nbsp;Clearly&nbsp;bad.
</c41><br/><ln>&nbsp;&nbsp;693</ln><a id="693">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;694</ln><a id="694">&nbsp;</a>&nbsp;<c41>However,&nbsp;the&nbsp;`RESTRICTIONS`&nbsp;rules&nbsp;are&nbsp;more&nbsp;concerned&nbsp;with&nbsp;how&nbsp;memory
</c41><br/><ln>&nbsp;&nbsp;695</ln><a id="695">&nbsp;</a>&nbsp;<c41>is&nbsp;used.&nbsp;The&nbsp;example&nbsp;above&nbsp;doesn't&nbsp;generate&nbsp;an&nbsp;error&nbsp;according&nbsp;to
</c41><br/><ln>&nbsp;&nbsp;696</ln><a id="696">&nbsp;</a>&nbsp;<c41>`RESTRICTIONS`&nbsp;because,&nbsp;for&nbsp;local&nbsp;variables,&nbsp;we&nbsp;don't&nbsp;require&nbsp;that&nbsp;the
</c41><br/><ln>&nbsp;&nbsp;697</ln><a id="697">&nbsp;</a>&nbsp;<c41>loan&nbsp;lifetime&nbsp;be&nbsp;a&nbsp;subset&nbsp;of&nbsp;the&nbsp;local&nbsp;variable&nbsp;lifetime.&nbsp;The&nbsp;idea
</c41><br/><ln>&nbsp;&nbsp;698</ln><a id="698">&nbsp;</a>&nbsp;<c41>here&nbsp;is&nbsp;that&nbsp;we&nbsp;*can*&nbsp;guarantee&nbsp;that&nbsp;`x`&nbsp;is&nbsp;not&nbsp;(e.g.)&nbsp;mutated&nbsp;for&nbsp;the
</c41><br/><ln>&nbsp;&nbsp;699</ln><a id="699">&nbsp;</a>&nbsp;<c41>lifetime&nbsp;`'a`,&nbsp;even&nbsp;though&nbsp;`'a`&nbsp;exceeds&nbsp;the&nbsp;function&nbsp;body&nbsp;and&nbsp;thus
</c41><br/><ln>&nbsp;&nbsp;700</ln><a id="700">&nbsp;</a>&nbsp;<c41>involves&nbsp;unknown&nbsp;code&nbsp;in&nbsp;the&nbsp;caller&nbsp;--&nbsp;after&nbsp;all,&nbsp;`x`&nbsp;ceases&nbsp;to&nbsp;exist
</c41><br/><ln>&nbsp;&nbsp;701</ln><a id="701">&nbsp;</a>&nbsp;<c41>after&nbsp;we&nbsp;return&nbsp;and&nbsp;hence&nbsp;the&nbsp;remaining&nbsp;code&nbsp;in&nbsp;`'a`&nbsp;cannot&nbsp;possibly
</c41><br/><ln>&nbsp;&nbsp;702</ln><a id="702">&nbsp;</a>&nbsp;<c41>mutate&nbsp;it.&nbsp;This&nbsp;distinction&nbsp;is&nbsp;important&nbsp;for&nbsp;type&nbsp;checking&nbsp;functions
</c41><br/><ln>&nbsp;&nbsp;703</ln><a id="703">&nbsp;</a>&nbsp;<c41>like&nbsp;this&nbsp;one:
</c41><br/><ln>&nbsp;&nbsp;704</ln><a id="704">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;705</ln><a id="705">&nbsp;</a>&nbsp;<c41>```
</c41><br/><ln>&nbsp;&nbsp;706</ln><a id="706">&nbsp;</a>&nbsp;<c41>fn&nbsp;inc_and_get&lt;'a&gt;(p:&nbsp;&amp;'a&nbsp;mut&nbsp;Point)&nbsp;-&gt;&nbsp;&amp;'a&nbsp;int&nbsp;{
</c41><br/><ln>&nbsp;&nbsp;707</ln><a id="707">&nbsp;</a>&nbsp;<c41>&nbsp;&nbsp;&nbsp;&nbsp;p.x&nbsp;+=&nbsp;1;
</c41><br/><ln>&nbsp;&nbsp;708</ln><a id="708">&nbsp;</a>&nbsp;<c41>&nbsp;&nbsp;&nbsp;&nbsp;&amp;p.x
</c41><br/><ln>&nbsp;&nbsp;709</ln><a id="709">&nbsp;</a>&nbsp;<c41>}
</c41><br/><ln>&nbsp;&nbsp;710</ln><a id="710">&nbsp;</a>&nbsp;<c41>```
</c41><br/><ln>&nbsp;&nbsp;711</ln><a id="711">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;712</ln><a id="712">&nbsp;</a>&nbsp;<c41>In&nbsp;this&nbsp;case,&nbsp;we&nbsp;take&nbsp;in&nbsp;a&nbsp;`&amp;mut`&nbsp;and&nbsp;return&nbsp;a&nbsp;frozen&nbsp;borrowed&nbsp;pointer
</c41><br/><ln>&nbsp;&nbsp;713</ln><a id="713">&nbsp;</a>&nbsp;<c41>with&nbsp;the&nbsp;same&nbsp;lifetime.&nbsp;So&nbsp;long&nbsp;as&nbsp;the&nbsp;lifetime&nbsp;of&nbsp;the&nbsp;returned&nbsp;value
</c41><br/><ln>&nbsp;&nbsp;714</ln><a id="714">&nbsp;</a>&nbsp;<c41>doesn't&nbsp;exceed&nbsp;the&nbsp;lifetime&nbsp;of&nbsp;the&nbsp;`&amp;mut`&nbsp;we&nbsp;receive&nbsp;as&nbsp;input,&nbsp;this&nbsp;is
</c41><br/><ln>&nbsp;&nbsp;715</ln><a id="715">&nbsp;</a>&nbsp;<c41>fine,&nbsp;though&nbsp;it&nbsp;may&nbsp;seem&nbsp;surprising&nbsp;at&nbsp;first&nbsp;(it&nbsp;surprised&nbsp;me&nbsp;when&nbsp;I
</c41><br/><ln>&nbsp;&nbsp;716</ln><a id="716">&nbsp;</a>&nbsp;<c41>first&nbsp;worked&nbsp;it&nbsp;through).&nbsp;After&nbsp;all,&nbsp;we're&nbsp;guaranteeing&nbsp;that&nbsp;`*p`
</c41><br/><ln>&nbsp;&nbsp;717</ln><a id="717">&nbsp;</a>&nbsp;<c41>won't&nbsp;be&nbsp;mutated&nbsp;for&nbsp;the&nbsp;lifetime&nbsp;`'a`,&nbsp;even&nbsp;though&nbsp;we&nbsp;can't&nbsp;"see"&nbsp;the
</c41><br/><ln>&nbsp;&nbsp;718</ln><a id="718">&nbsp;</a>&nbsp;<c41>entirety&nbsp;of&nbsp;the&nbsp;code&nbsp;during&nbsp;that&nbsp;lifetime,&nbsp;since&nbsp;some&nbsp;of&nbsp;it&nbsp;occurs&nbsp;in
</c41><br/><ln>&nbsp;&nbsp;719</ln><a id="719">&nbsp;</a>&nbsp;<c41>our&nbsp;caller.&nbsp;But&nbsp;we&nbsp;*do*&nbsp;know&nbsp;that&nbsp;nobody&nbsp;can&nbsp;mutate&nbsp;`*p`&nbsp;except
</c41><br/><ln>&nbsp;&nbsp;720</ln><a id="720">&nbsp;</a>&nbsp;<c41>through&nbsp;`p`.&nbsp;So&nbsp;if&nbsp;we&nbsp;don't&nbsp;mutate&nbsp;`*p`&nbsp;and&nbsp;we&nbsp;don't&nbsp;return&nbsp;`p`,&nbsp;then
</c41><br/><ln>&nbsp;&nbsp;721</ln><a id="721">&nbsp;</a>&nbsp;<c41>we&nbsp;know&nbsp;that&nbsp;the&nbsp;right&nbsp;to&nbsp;mutate&nbsp;`*p`&nbsp;has&nbsp;been&nbsp;lost&nbsp;to&nbsp;our&nbsp;caller&nbsp;--
</c41><br/><ln>&nbsp;&nbsp;722</ln><a id="722">&nbsp;</a>&nbsp;<c41>in&nbsp;terms&nbsp;of&nbsp;capability,&nbsp;the&nbsp;caller&nbsp;passed&nbsp;in&nbsp;the&nbsp;ability&nbsp;to&nbsp;mutate
</c41><br/><ln>&nbsp;&nbsp;723</ln><a id="723">&nbsp;</a>&nbsp;<c41>`*p`,&nbsp;and&nbsp;we&nbsp;never&nbsp;gave&nbsp;it&nbsp;back.&nbsp;(Note&nbsp;that&nbsp;we&nbsp;can't&nbsp;return&nbsp;`p`&nbsp;while
</c41><br/><ln>&nbsp;&nbsp;724</ln><a id="724">&nbsp;</a>&nbsp;<c41>`*p`&nbsp;is&nbsp;borrowed&nbsp;since&nbsp;that&nbsp;would&nbsp;be&nbsp;a&nbsp;move&nbsp;of&nbsp;`p`,&nbsp;as&nbsp;`&amp;mut`&nbsp;pointers
</c41><br/><ln>&nbsp;&nbsp;725</ln><a id="725">&nbsp;</a>&nbsp;<c41>are&nbsp;affine.)
</c41><br/><ln>&nbsp;&nbsp;726</ln><a id="726">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;727</ln><a id="727">&nbsp;</a>&nbsp;<c41>###&nbsp;Restrictions&nbsp;for&nbsp;loans&nbsp;of&nbsp;const&nbsp;aliasable&nbsp;referents
</c41><br/><ln>&nbsp;&nbsp;728</ln><a id="728">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;729</ln><a id="729">&nbsp;</a>&nbsp;<c41>Freeze&nbsp;pointers&nbsp;are&nbsp;read-only.&nbsp;There&nbsp;may&nbsp;be&nbsp;`&amp;mut`&nbsp;or&nbsp;`&amp;`&nbsp;aliases,&nbsp;and
</c41><br/><ln>&nbsp;&nbsp;730</ln><a id="730">&nbsp;</a>&nbsp;<c41>we&nbsp;can&nbsp;not&nbsp;prevent&nbsp;*anything*&nbsp;but&nbsp;moves&nbsp;in&nbsp;that&nbsp;case.&nbsp;So&nbsp;the
</c41><br/><ln>&nbsp;&nbsp;731</ln><a id="731">&nbsp;</a>&nbsp;<c41>`RESTRICTIONS`&nbsp;function&nbsp;is&nbsp;only&nbsp;defined&nbsp;if&nbsp;`ACTIONS`&nbsp;is&nbsp;the&nbsp;empty&nbsp;set.
</c41><br/><ln>&nbsp;&nbsp;732</ln><a id="732">&nbsp;</a>&nbsp;<c41>Because&nbsp;moves&nbsp;from&nbsp;a&nbsp;`&amp;const`&nbsp;or&nbsp;`@const`&nbsp;lvalue&nbsp;are&nbsp;never&nbsp;legal,&nbsp;it
</c41><br/><ln>&nbsp;&nbsp;733</ln><a id="733">&nbsp;</a>&nbsp;<c41>is&nbsp;not&nbsp;necessary&nbsp;to&nbsp;add&nbsp;any&nbsp;restrictions&nbsp;at&nbsp;all&nbsp;to&nbsp;the&nbsp;final
</c41><br/><ln>&nbsp;&nbsp;734</ln><a id="734">&nbsp;</a>&nbsp;<c41>result.
</c41><br/><ln>&nbsp;&nbsp;735</ln><a id="735">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;736</ln><a id="736">&nbsp;</a>&nbsp;<c41>```notrust
</c41><br/><ln>&nbsp;&nbsp;737</ln><a id="737">&nbsp;</a>&nbsp;<c41>&nbsp;&nbsp;&nbsp;&nbsp;RESTRICTIONS(*LV,&nbsp;LT,&nbsp;[])&nbsp;=&nbsp;[]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;R-Deref-Freeze-Borrowed
</c41><br/><ln>&nbsp;&nbsp;738</ln><a id="738">&nbsp;</a>&nbsp;<c41>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TYPE(LV)&nbsp;=&nbsp;&amp;const&nbsp;Ty&nbsp;or&nbsp;@const&nbsp;Ty
</c41><br/><ln>&nbsp;&nbsp;739</ln><a id="739">&nbsp;</a>&nbsp;<c41>```
</c41><br/><ln>&nbsp;&nbsp;740</ln><a id="740">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;741</ln><a id="741">&nbsp;</a>&nbsp;<c41>###&nbsp;Restrictions&nbsp;for&nbsp;loans&nbsp;of&nbsp;mutable&nbsp;borrowed&nbsp;referents
</c41><br/><ln>&nbsp;&nbsp;742</ln><a id="742">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;743</ln><a id="743">&nbsp;</a>&nbsp;<c41>Mutable&nbsp;borrowed&nbsp;pointers&nbsp;are&nbsp;guaranteed&nbsp;to&nbsp;be&nbsp;the&nbsp;only&nbsp;way&nbsp;to&nbsp;mutate
</c41><br/><ln>&nbsp;&nbsp;744</ln><a id="744">&nbsp;</a>&nbsp;<c41>their&nbsp;referent.&nbsp;This&nbsp;permits&nbsp;us&nbsp;to&nbsp;take&nbsp;greater&nbsp;license&nbsp;with&nbsp;them;&nbsp;for
</c41><br/><ln>&nbsp;&nbsp;745</ln><a id="745">&nbsp;</a>&nbsp;<c41>example,&nbsp;the&nbsp;referent&nbsp;can&nbsp;be&nbsp;frozen&nbsp;simply&nbsp;be&nbsp;ensuring&nbsp;that&nbsp;we&nbsp;do&nbsp;not
</c41><br/><ln>&nbsp;&nbsp;746</ln><a id="746">&nbsp;</a>&nbsp;<c41>use&nbsp;the&nbsp;original&nbsp;pointer&nbsp;to&nbsp;perform&nbsp;mutate.&nbsp;Similarly,&nbsp;we&nbsp;can&nbsp;allow
</c41><br/><ln>&nbsp;&nbsp;747</ln><a id="747">&nbsp;</a>&nbsp;<c41>the&nbsp;referent&nbsp;to&nbsp;be&nbsp;claimed,&nbsp;so&nbsp;long&nbsp;as&nbsp;the&nbsp;original&nbsp;pointer&nbsp;is&nbsp;unused
</c41><br/><ln>&nbsp;&nbsp;748</ln><a id="748">&nbsp;</a>&nbsp;<c41>while&nbsp;the&nbsp;new&nbsp;claimant&nbsp;is&nbsp;live.
</c41><br/><ln>&nbsp;&nbsp;749</ln><a id="749">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;750</ln><a id="750">&nbsp;</a>&nbsp;<c41>The&nbsp;rule&nbsp;for&nbsp;mutable&nbsp;borrowed&nbsp;pointers&nbsp;is&nbsp;as&nbsp;follows:
</c41><br/><ln>&nbsp;&nbsp;751</ln><a id="751">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;752</ln><a id="752">&nbsp;</a>&nbsp;<c41>```notrust
</c41><br/><ln>&nbsp;&nbsp;753</ln><a id="753">&nbsp;</a>&nbsp;<c41>RESTRICTIONS(*LV,&nbsp;LT,&nbsp;ACTIONS)&nbsp;=&nbsp;RS,&nbsp;(*LV,&nbsp;ACTIONS)&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;R-Deref-Mut-Borrowed
</c41><br/><ln>&nbsp;&nbsp;754</ln><a id="754">&nbsp;</a>&nbsp;<c41>&nbsp;&nbsp;TYPE(LV)&nbsp;=&nbsp;&amp;LT'&nbsp;mut&nbsp;Ty
</c41><br/><ln>&nbsp;&nbsp;755</ln><a id="755">&nbsp;</a>&nbsp;<c41>&nbsp;&nbsp;LT&nbsp;&lt;=&nbsp;LT'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;(1)
</c41><br/><ln>&nbsp;&nbsp;756</ln><a id="756">&nbsp;</a>&nbsp;<c41>&nbsp;&nbsp;RESTRICTIONS(LV,&nbsp;LT,&nbsp;ACTIONS)&nbsp;=&nbsp;RS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;(2)
</c41><br/><ln>&nbsp;&nbsp;757</ln><a id="757">&nbsp;</a>&nbsp;<c41>```
</c41><br/><ln>&nbsp;&nbsp;758</ln><a id="758">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;759</ln><a id="759">&nbsp;</a>&nbsp;<c41>Let's&nbsp;examine&nbsp;the&nbsp;two&nbsp;numbered&nbsp;clauses:
</c41><br/><ln>&nbsp;&nbsp;760</ln><a id="760">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;761</ln><a id="761">&nbsp;</a>&nbsp;<c41>Clause&nbsp;(1)&nbsp;specifies&nbsp;that&nbsp;the&nbsp;lifetime&nbsp;of&nbsp;the&nbsp;loan&nbsp;(`LT`)&nbsp;cannot
</c41><br/><ln>&nbsp;&nbsp;762</ln><a id="762">&nbsp;</a>&nbsp;<c41>exceed&nbsp;the&nbsp;lifetime&nbsp;of&nbsp;the&nbsp;`&amp;mut`&nbsp;pointer&nbsp;(`LT'`).&nbsp;The&nbsp;reason&nbsp;for&nbsp;this
</c41><br/><ln>&nbsp;&nbsp;763</ln><a id="763">&nbsp;</a>&nbsp;<c41>is&nbsp;that&nbsp;the&nbsp;`&amp;mut`&nbsp;pointer&nbsp;is&nbsp;guaranteed&nbsp;to&nbsp;be&nbsp;the&nbsp;only&nbsp;legal&nbsp;way&nbsp;to
</c41><br/><ln>&nbsp;&nbsp;764</ln><a id="764">&nbsp;</a>&nbsp;<c41>mutate&nbsp;its&nbsp;referent&nbsp;--&nbsp;but&nbsp;only&nbsp;for&nbsp;the&nbsp;lifetime&nbsp;`LT'`.&nbsp;&nbsp;After&nbsp;that
</c41><br/><ln>&nbsp;&nbsp;765</ln><a id="765">&nbsp;</a>&nbsp;<c41>lifetime,&nbsp;the&nbsp;loan&nbsp;on&nbsp;the&nbsp;referent&nbsp;expires&nbsp;and&nbsp;hence&nbsp;the&nbsp;data&nbsp;may&nbsp;be
</c41><br/><ln>&nbsp;&nbsp;766</ln><a id="766">&nbsp;</a>&nbsp;<c41>modified&nbsp;by&nbsp;its&nbsp;owner&nbsp;again.&nbsp;This&nbsp;implies&nbsp;that&nbsp;we&nbsp;are&nbsp;only&nbsp;able&nbsp;to
</c41><br/><ln>&nbsp;&nbsp;767</ln><a id="767">&nbsp;</a>&nbsp;<c41>guarantee&nbsp;that&nbsp;the&nbsp;referent&nbsp;will&nbsp;not&nbsp;be&nbsp;modified&nbsp;or&nbsp;aliased&nbsp;for&nbsp;a
</c41><br/><ln>&nbsp;&nbsp;768</ln><a id="768">&nbsp;</a>&nbsp;<c41>maximum&nbsp;of&nbsp;`LT'`.
</c41><br/><ln>&nbsp;&nbsp;769</ln><a id="769">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;770</ln><a id="770">&nbsp;</a>&nbsp;<c41>Here&nbsp;is&nbsp;a&nbsp;concrete&nbsp;example&nbsp;of&nbsp;a&nbsp;bug&nbsp;this&nbsp;rule&nbsp;prevents:
</c41><br/><ln>&nbsp;&nbsp;771</ln><a id="771">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;772</ln><a id="772">&nbsp;</a>&nbsp;<c41>```
</c41><br/><ln>&nbsp;&nbsp;773</ln><a id="773">&nbsp;</a>&nbsp;<c41>//&nbsp;Test&nbsp;region-reborrow-from-shorter-mut-ref.rs:
</c41><br/><ln>&nbsp;&nbsp;774</ln><a id="774">&nbsp;</a>&nbsp;<c41>fn&nbsp;copy_pointer&lt;'a,'b,T&gt;(x:&nbsp;&amp;'a&nbsp;mut&nbsp;&amp;'b&nbsp;mut&nbsp;T)&nbsp;-&gt;&nbsp;&amp;'b&nbsp;mut&nbsp;T&nbsp;{
</c41><br/><ln>&nbsp;&nbsp;775</ln><a id="775">&nbsp;</a>&nbsp;<c41>&nbsp;&nbsp;&nbsp;&nbsp;&amp;mut&nbsp;**p&nbsp;//&nbsp;ERROR&nbsp;due&nbsp;to&nbsp;clause&nbsp;(1)
</c41><br/><ln>&nbsp;&nbsp;776</ln><a id="776">&nbsp;</a>&nbsp;<c41>}
</c41><br/><ln>&nbsp;&nbsp;777</ln><a id="777">&nbsp;</a>&nbsp;<c41>fn&nbsp;main()&nbsp;{
</c41><br/><ln>&nbsp;&nbsp;778</ln><a id="778">&nbsp;</a>&nbsp;<c41>&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;mut&nbsp;x&nbsp;=&nbsp;1;
</c41><br/><ln>&nbsp;&nbsp;779</ln><a id="779">&nbsp;</a>&nbsp;<c41>&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;mut&nbsp;y&nbsp;=&nbsp;&amp;mut&nbsp;x;&nbsp;//&nbsp;&lt;-'b-----------------------------+
</c41><br/><ln>&nbsp;&nbsp;780</ln><a id="780">&nbsp;</a>&nbsp;<c41>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+-'a--------------------+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|
</c41><br/><ln>&nbsp;&nbsp;781</ln><a id="781">&nbsp;</a>&nbsp;<c41>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|
</c41><br/><ln>&nbsp;&nbsp;782</ln><a id="782">&nbsp;</a>&nbsp;<c41>&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;z&nbsp;=&nbsp;copy_borrowed_ptr(&amp;mut&nbsp;y);&nbsp;//&nbsp;y&nbsp;is&nbsp;lent&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|
</c41><br/><ln>&nbsp;&nbsp;783</ln><a id="783">&nbsp;</a>&nbsp;<c41>&nbsp;&nbsp;&nbsp;&nbsp;*y&nbsp;+=&nbsp;1;&nbsp;//&nbsp;Here&nbsp;y==z,&nbsp;so&nbsp;both&nbsp;should&nbsp;not&nbsp;be&nbsp;usable...&nbsp;&nbsp;|
</c41><br/><ln>&nbsp;&nbsp;784</ln><a id="784">&nbsp;</a>&nbsp;<c41>&nbsp;&nbsp;&nbsp;&nbsp;*z&nbsp;+=&nbsp;1;&nbsp;//&nbsp;...and&nbsp;yet&nbsp;they&nbsp;would&nbsp;be,&nbsp;but&nbsp;for&nbsp;clause&nbsp;1.&nbsp;|
</c41><br/><ln>&nbsp;&nbsp;785</ln><a id="785">&nbsp;</a>&nbsp;<c42>}&nbsp;//&nbsp;&lt;------------------------------------------------------+
</c42><br/><ln>&nbsp;&nbsp;786</ln><a id="786">&nbsp;</a>&nbsp;<c41>```
</c41><br/><ln>&nbsp;&nbsp;787</ln><a id="787">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;788</ln><a id="788">&nbsp;</a>&nbsp;<c41>Clause&nbsp;(2)&nbsp;propagates&nbsp;the&nbsp;restrictions&nbsp;on&nbsp;the&nbsp;referent&nbsp;to&nbsp;the&nbsp;pointer
</c41><br/><ln>&nbsp;&nbsp;789</ln><a id="789">&nbsp;</a>&nbsp;<c41>itself.&nbsp;This&nbsp;is&nbsp;the&nbsp;same&nbsp;as&nbsp;with&nbsp;an&nbsp;owned&nbsp;pointer,&nbsp;though&nbsp;the
</c41><br/><ln>&nbsp;&nbsp;790</ln><a id="790">&nbsp;</a>&nbsp;<c41>reasoning&nbsp;is&nbsp;mildly&nbsp;different.&nbsp;The&nbsp;basic&nbsp;goal&nbsp;in&nbsp;all&nbsp;cases&nbsp;is&nbsp;to
</c41><br/><ln>&nbsp;&nbsp;791</ln><a id="791">&nbsp;</a>&nbsp;<c41>prevent&nbsp;the&nbsp;user&nbsp;from&nbsp;establishing&nbsp;another&nbsp;route&nbsp;to&nbsp;the&nbsp;same&nbsp;data.&nbsp;To
</c41><br/><ln>&nbsp;&nbsp;792</ln><a id="792">&nbsp;</a>&nbsp;<c41>see&nbsp;what&nbsp;I&nbsp;mean,&nbsp;let's&nbsp;examine&nbsp;various&nbsp;cases&nbsp;of&nbsp;what&nbsp;can&nbsp;go&nbsp;wrong&nbsp;and
</c41><br/><ln>&nbsp;&nbsp;793</ln><a id="793">&nbsp;</a>&nbsp;<c41>show&nbsp;how&nbsp;it&nbsp;is&nbsp;prevented.
</c41><br/><ln>&nbsp;&nbsp;794</ln><a id="794">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;795</ln><a id="795">&nbsp;</a>&nbsp;<c41>**Example&nbsp;danger&nbsp;1:&nbsp;Moving&nbsp;the&nbsp;base&nbsp;pointer.**&nbsp;One&nbsp;of&nbsp;the&nbsp;simplest
</c41><br/><ln>&nbsp;&nbsp;796</ln><a id="796">&nbsp;</a>&nbsp;<c41>ways&nbsp;to&nbsp;violate&nbsp;the&nbsp;rules&nbsp;is&nbsp;to&nbsp;move&nbsp;the&nbsp;base&nbsp;pointer&nbsp;to&nbsp;a&nbsp;new&nbsp;name
</c41><br/><ln>&nbsp;&nbsp;797</ln><a id="797">&nbsp;</a>&nbsp;<c41>and&nbsp;access&nbsp;it&nbsp;via&nbsp;that&nbsp;new&nbsp;name,&nbsp;thus&nbsp;bypassing&nbsp;the&nbsp;restrictions&nbsp;on
</c41><br/><ln>&nbsp;&nbsp;798</ln><a id="798">&nbsp;</a>&nbsp;<c41>the&nbsp;old&nbsp;name.&nbsp;Here&nbsp;is&nbsp;an&nbsp;example:
</c41><br/><ln>&nbsp;&nbsp;799</ln><a id="799">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;800</ln><a id="800">&nbsp;</a>&nbsp;<c41>```
</c41><br/><ln>&nbsp;&nbsp;801</ln><a id="801">&nbsp;</a>&nbsp;<c41>//&nbsp;src/test/compile-fail/borrowck-move-mut-base-ptr.rs
</c41><br/><ln>&nbsp;&nbsp;802</ln><a id="802">&nbsp;</a>&nbsp;<c41>fn&nbsp;foo(t0:&nbsp;&amp;mut&nbsp;int)&nbsp;{
</c41><br/><ln>&nbsp;&nbsp;803</ln><a id="803">&nbsp;</a>&nbsp;<c41>&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;p:&nbsp;&amp;int&nbsp;=&nbsp;&amp;*t0;&nbsp;//&nbsp;Freezes&nbsp;`*t0`
</c41><br/><ln>&nbsp;&nbsp;804</ln><a id="804">&nbsp;</a>&nbsp;<c41>&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;t1&nbsp;=&nbsp;t0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//~&nbsp;ERROR&nbsp;cannot&nbsp;move&nbsp;out&nbsp;of&nbsp;`t0`
</c41><br/><ln>&nbsp;&nbsp;805</ln><a id="805">&nbsp;</a>&nbsp;<c41>&nbsp;&nbsp;&nbsp;&nbsp;*t1&nbsp;=&nbsp;22;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;OK,&nbsp;not&nbsp;a&nbsp;write&nbsp;through&nbsp;`*t0`
</c41><br/><ln>&nbsp;&nbsp;806</ln><a id="806">&nbsp;</a>&nbsp;<c41>}
</c41><br/><ln>&nbsp;&nbsp;807</ln><a id="807">&nbsp;</a>&nbsp;<c41>```
</c41><br/><ln>&nbsp;&nbsp;808</ln><a id="808">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;809</ln><a id="809">&nbsp;</a>&nbsp;<c41>Remember&nbsp;that&nbsp;`&amp;mut`&nbsp;pointers&nbsp;are&nbsp;linear,&nbsp;and&nbsp;hence&nbsp;`let&nbsp;t1&nbsp;=&nbsp;t0`&nbsp;is&nbsp;a
</c41><br/><ln>&nbsp;&nbsp;810</ln><a id="810">&nbsp;</a>&nbsp;<c41>move&nbsp;of&nbsp;`t0`&nbsp;--&nbsp;or&nbsp;would&nbsp;be,&nbsp;if&nbsp;it&nbsp;were&nbsp;legal.&nbsp;Instead,&nbsp;we&nbsp;get&nbsp;an
</c41><br/><ln>&nbsp;&nbsp;811</ln><a id="811">&nbsp;</a>&nbsp;<c41>error,&nbsp;because&nbsp;clause&nbsp;(2)&nbsp;imposes&nbsp;restrictions&nbsp;on&nbsp;`LV`&nbsp;(`t0`,&nbsp;here),
</c41><br/><ln>&nbsp;&nbsp;812</ln><a id="812">&nbsp;</a>&nbsp;<c41>and&nbsp;any&nbsp;restrictions&nbsp;on&nbsp;a&nbsp;path&nbsp;make&nbsp;it&nbsp;impossible&nbsp;to&nbsp;move&nbsp;from&nbsp;that
</c41><br/><ln>&nbsp;&nbsp;813</ln><a id="813">&nbsp;</a>&nbsp;<c41>path.
</c41><br/><ln>&nbsp;&nbsp;814</ln><a id="814">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;815</ln><a id="815">&nbsp;</a>&nbsp;<c41>**Example&nbsp;danger&nbsp;2:&nbsp;Claiming&nbsp;the&nbsp;base&nbsp;pointer.**&nbsp;Another&nbsp;possible
</c41><br/><ln>&nbsp;&nbsp;816</ln><a id="816">&nbsp;</a>&nbsp;<c41>danger&nbsp;is&nbsp;to&nbsp;mutably&nbsp;borrow&nbsp;the&nbsp;base&nbsp;path.&nbsp;This&nbsp;can&nbsp;lead&nbsp;to&nbsp;two&nbsp;bad
</c41><br/><ln>&nbsp;&nbsp;817</ln><a id="817">&nbsp;</a>&nbsp;<c41>scenarios.&nbsp;The&nbsp;most&nbsp;obvious&nbsp;is&nbsp;that&nbsp;the&nbsp;mutable&nbsp;borrow&nbsp;itself&nbsp;becomes
</c41><br/><ln>&nbsp;&nbsp;818</ln><a id="818">&nbsp;</a>&nbsp;<c41>another&nbsp;path&nbsp;to&nbsp;access&nbsp;the&nbsp;same&nbsp;data,&nbsp;as&nbsp;shown&nbsp;here:
</c41><br/><ln>&nbsp;&nbsp;819</ln><a id="819">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;820</ln><a id="820">&nbsp;</a>&nbsp;<c41>```
</c41><br/><ln>&nbsp;&nbsp;821</ln><a id="821">&nbsp;</a>&nbsp;<c41>//&nbsp;src/test/compile-fail/borrowck-mut-borrow-of-mut-base-ptr.rs
</c41><br/><ln>&nbsp;&nbsp;822</ln><a id="822">&nbsp;</a>&nbsp;<c41>fn&nbsp;foo&lt;'a&gt;(mut&nbsp;t0:&nbsp;&amp;'a&nbsp;mut&nbsp;int,
</c41><br/><ln>&nbsp;&nbsp;823</ln><a id="823">&nbsp;</a>&nbsp;<c41>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mut&nbsp;t1:&nbsp;&amp;'a&nbsp;mut&nbsp;int)&nbsp;{
</c41><br/><ln>&nbsp;&nbsp;824</ln><a id="824">&nbsp;</a>&nbsp;<c41>&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;p:&nbsp;&amp;int&nbsp;=&nbsp;&amp;*t0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Freezes&nbsp;`*t0`
</c41><br/><ln>&nbsp;&nbsp;825</ln><a id="825">&nbsp;</a>&nbsp;<c41>&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;mut&nbsp;t2&nbsp;=&nbsp;&amp;mut&nbsp;t0;&nbsp;&nbsp;&nbsp;//~&nbsp;ERROR&nbsp;cannot&nbsp;borrow&nbsp;`t0`
</c41><br/><ln>&nbsp;&nbsp;826</ln><a id="826">&nbsp;</a>&nbsp;<c41>&nbsp;&nbsp;&nbsp;&nbsp;**t2&nbsp;+=&nbsp;1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Mutates&nbsp;`*t0`
</c41><br/><ln>&nbsp;&nbsp;827</ln><a id="827">&nbsp;</a>&nbsp;<c41>}
</c41><br/><ln>&nbsp;&nbsp;828</ln><a id="828">&nbsp;</a>&nbsp;<c41>```
</c41><br/><ln>&nbsp;&nbsp;829</ln><a id="829">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;830</ln><a id="830">&nbsp;</a>&nbsp;<c41>In&nbsp;this&nbsp;example,&nbsp;`**t2`&nbsp;is&nbsp;the&nbsp;same&nbsp;memory&nbsp;as&nbsp;`*t0`.&nbsp;Because&nbsp;`t2`&nbsp;is
</c41><br/><ln>&nbsp;&nbsp;831</ln><a id="831">&nbsp;</a>&nbsp;<c41>an&nbsp;`&amp;mut`&nbsp;pointer,&nbsp;`**t2`&nbsp;is&nbsp;a&nbsp;unique&nbsp;path&nbsp;and&nbsp;hence&nbsp;it&nbsp;would&nbsp;be
</c41><br/><ln>&nbsp;&nbsp;832</ln><a id="832">&nbsp;</a>&nbsp;<c41>possible&nbsp;to&nbsp;mutate&nbsp;`**t2`&nbsp;even&nbsp;though&nbsp;that&nbsp;memory&nbsp;was&nbsp;supposed&nbsp;to&nbsp;be
</c41><br/><ln>&nbsp;&nbsp;833</ln><a id="833">&nbsp;</a>&nbsp;<c41>frozen&nbsp;by&nbsp;the&nbsp;creation&nbsp;of&nbsp;`p`.&nbsp;However,&nbsp;an&nbsp;error&nbsp;is&nbsp;reported&nbsp;--&nbsp;the
</c41><br/><ln>&nbsp;&nbsp;834</ln><a id="834">&nbsp;</a>&nbsp;<c41>reason&nbsp;is&nbsp;that&nbsp;the&nbsp;freeze&nbsp;`&amp;*t0`&nbsp;will&nbsp;restrict&nbsp;claims&nbsp;and&nbsp;mutation
</c41><br/><ln>&nbsp;&nbsp;835</ln><a id="835">&nbsp;</a>&nbsp;<c41>against&nbsp;`*t0`&nbsp;which,&nbsp;by&nbsp;clause&nbsp;2,&nbsp;in&nbsp;turn&nbsp;prevents&nbsp;claims&nbsp;and&nbsp;mutation
</c41><br/><ln>&nbsp;&nbsp;836</ln><a id="836">&nbsp;</a>&nbsp;<c41>of&nbsp;`t0`.&nbsp;Hence&nbsp;the&nbsp;claim&nbsp;`&amp;mut&nbsp;t0`&nbsp;is&nbsp;illegal.
</c41><br/><ln>&nbsp;&nbsp;837</ln><a id="837">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;838</ln><a id="838">&nbsp;</a>&nbsp;<c41>Another&nbsp;danger&nbsp;with&nbsp;an&nbsp;`&amp;mut`&nbsp;pointer&nbsp;is&nbsp;that&nbsp;we&nbsp;could&nbsp;swap&nbsp;the&nbsp;`t0`
</c41><br/><ln>&nbsp;&nbsp;839</ln><a id="839">&nbsp;</a>&nbsp;<c41>value&nbsp;away&nbsp;to&nbsp;create&nbsp;a&nbsp;new&nbsp;path:
</c41><br/><ln>&nbsp;&nbsp;840</ln><a id="840">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;841</ln><a id="841">&nbsp;</a>&nbsp;<c41>```
</c41><br/><ln>&nbsp;&nbsp;842</ln><a id="842">&nbsp;</a>&nbsp;<c41>//&nbsp;src/test/compile-fail/borrowck-swap-mut-base-ptr.rs
</c41><br/><ln>&nbsp;&nbsp;843</ln><a id="843">&nbsp;</a>&nbsp;<c41>fn&nbsp;foo&lt;'a&gt;(mut&nbsp;t0:&nbsp;&amp;'a&nbsp;mut&nbsp;int,
</c41><br/><ln>&nbsp;&nbsp;844</ln><a id="844">&nbsp;</a>&nbsp;<c41>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mut&nbsp;t1:&nbsp;&amp;'a&nbsp;mut&nbsp;int)&nbsp;{
</c41><br/><ln>&nbsp;&nbsp;845</ln><a id="845">&nbsp;</a>&nbsp;<c41>&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;p:&nbsp;&amp;int&nbsp;=&nbsp;&amp;*t0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Freezes&nbsp;`*t0`
</c41><br/><ln>&nbsp;&nbsp;846</ln><a id="846">&nbsp;</a>&nbsp;<c41>&nbsp;&nbsp;&nbsp;&nbsp;swap(&amp;mut&nbsp;t0,&nbsp;&amp;mut&nbsp;t1);&nbsp;//~&nbsp;ERROR&nbsp;cannot&nbsp;borrow&nbsp;`t0`
</c41><br/><ln>&nbsp;&nbsp;847</ln><a id="847">&nbsp;</a>&nbsp;<c41>&nbsp;&nbsp;&nbsp;&nbsp;*t1&nbsp;=&nbsp;22;
</c41><br/><ln>&nbsp;&nbsp;848</ln><a id="848">&nbsp;</a>&nbsp;<c41>}
</c41><br/><ln>&nbsp;&nbsp;849</ln><a id="849">&nbsp;</a>&nbsp;<c41>```
</c41><br/><ln>&nbsp;&nbsp;850</ln><a id="850">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;851</ln><a id="851">&nbsp;</a>&nbsp;<c41>This&nbsp;is&nbsp;illegal&nbsp;for&nbsp;the&nbsp;same&nbsp;reason&nbsp;as&nbsp;above.&nbsp;Note&nbsp;that&nbsp;if&nbsp;we&nbsp;added
</c41><br/><ln>&nbsp;&nbsp;852</ln><a id="852">&nbsp;</a>&nbsp;<c41>back&nbsp;a&nbsp;swap&nbsp;operator&nbsp;--&nbsp;as&nbsp;we&nbsp;used&nbsp;to&nbsp;have&nbsp;--&nbsp;we&nbsp;would&nbsp;want&nbsp;to&nbsp;be&nbsp;very
</c41><br/><ln>&nbsp;&nbsp;853</ln><a id="853">&nbsp;</a>&nbsp;<c41>careful&nbsp;to&nbsp;ensure&nbsp;this&nbsp;example&nbsp;is&nbsp;still&nbsp;illegal.
</c41><br/><ln>&nbsp;&nbsp;854</ln><a id="854">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;855</ln><a id="855">&nbsp;</a>&nbsp;<c41>**Example&nbsp;danger&nbsp;3:&nbsp;Freeze&nbsp;the&nbsp;base&nbsp;pointer.**&nbsp;In&nbsp;the&nbsp;case&nbsp;where&nbsp;the
</c41><br/><ln>&nbsp;&nbsp;856</ln><a id="856">&nbsp;</a>&nbsp;<c41>referent&nbsp;is&nbsp;claimed,&nbsp;even&nbsp;freezing&nbsp;the&nbsp;base&nbsp;pointer&nbsp;can&nbsp;be&nbsp;dangerous,
</c41><br/><ln>&nbsp;&nbsp;857</ln><a id="857">&nbsp;</a>&nbsp;<c41>as&nbsp;shown&nbsp;in&nbsp;the&nbsp;following&nbsp;example:
</c41><br/><ln>&nbsp;&nbsp;858</ln><a id="858">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;859</ln><a id="859">&nbsp;</a>&nbsp;<c41>```
</c41><br/><ln>&nbsp;&nbsp;860</ln><a id="860">&nbsp;</a>&nbsp;<c41>//&nbsp;src/test/compile-fail/borrowck-borrow-of-mut-base-ptr.rs
</c41><br/><ln>&nbsp;&nbsp;861</ln><a id="861">&nbsp;</a>&nbsp;<c41>fn&nbsp;foo&lt;'a&gt;(mut&nbsp;t0:&nbsp;&amp;'a&nbsp;mut&nbsp;int,
</c41><br/><ln>&nbsp;&nbsp;862</ln><a id="862">&nbsp;</a>&nbsp;<c41>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mut&nbsp;t1:&nbsp;&amp;'a&nbsp;mut&nbsp;int)&nbsp;{
</c41><br/><ln>&nbsp;&nbsp;863</ln><a id="863">&nbsp;</a>&nbsp;<c41>&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;p:&nbsp;&amp;mut&nbsp;int&nbsp;=&nbsp;&amp;mut&nbsp;*t0;&nbsp;//&nbsp;Claims&nbsp;`*t0`
</c41><br/><ln>&nbsp;&nbsp;864</ln><a id="864">&nbsp;</a>&nbsp;<c41>&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;mut&nbsp;t2&nbsp;=&nbsp;&amp;t0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//~&nbsp;ERROR&nbsp;cannot&nbsp;borrow&nbsp;`t0`
</c41><br/><ln>&nbsp;&nbsp;865</ln><a id="865">&nbsp;</a>&nbsp;<c41>&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;q:&nbsp;&amp;int&nbsp;=&nbsp;&amp;*t2;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Freezes&nbsp;`*t0`&nbsp;but&nbsp;not&nbsp;through&nbsp;`*p`
</c41><br/><ln>&nbsp;&nbsp;866</ln><a id="866">&nbsp;</a>&nbsp;<c41>&nbsp;&nbsp;&nbsp;&nbsp;*p&nbsp;+=&nbsp;1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;violates&nbsp;type&nbsp;of&nbsp;`*q`
</c41><br/><ln>&nbsp;&nbsp;867</ln><a id="867">&nbsp;</a>&nbsp;<c41>}
</c41><br/><ln>&nbsp;&nbsp;868</ln><a id="868">&nbsp;</a>&nbsp;<c41>```
</c41><br/><ln>&nbsp;&nbsp;869</ln><a id="869">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;870</ln><a id="870">&nbsp;</a>&nbsp;<c41>Here&nbsp;the&nbsp;problem&nbsp;is&nbsp;that&nbsp;`*t0`&nbsp;is&nbsp;claimed&nbsp;by&nbsp;`p`,&nbsp;and&nbsp;hence&nbsp;`p`&nbsp;wants
</c41><br/><ln>&nbsp;&nbsp;871</ln><a id="871">&nbsp;</a>&nbsp;<c41>to&nbsp;be&nbsp;the&nbsp;controlling&nbsp;pointer&nbsp;through&nbsp;which&nbsp;mutation&nbsp;or&nbsp;freezes&nbsp;occur.
</c41><br/><ln>&nbsp;&nbsp;872</ln><a id="872">&nbsp;</a>&nbsp;<c41>But&nbsp;`t2`&nbsp;would&nbsp;--&nbsp;if&nbsp;it&nbsp;were&nbsp;legal&nbsp;--&nbsp;have&nbsp;the&nbsp;type&nbsp;`&amp;&nbsp;&amp;mut&nbsp;int`,&nbsp;and
</c41><br/><ln>&nbsp;&nbsp;873</ln><a id="873">&nbsp;</a>&nbsp;<c41>hence&nbsp;would&nbsp;be&nbsp;a&nbsp;mutable&nbsp;pointer&nbsp;in&nbsp;an&nbsp;aliasable&nbsp;location,&nbsp;which&nbsp;is
</c41><br/><ln>&nbsp;&nbsp;874</ln><a id="874">&nbsp;</a>&nbsp;<c41>considered&nbsp;frozen&nbsp;(since&nbsp;no&nbsp;one&nbsp;can&nbsp;write&nbsp;to&nbsp;`**t2`&nbsp;as&nbsp;it&nbsp;is&nbsp;not&nbsp;a
</c41><br/><ln>&nbsp;&nbsp;875</ln><a id="875">&nbsp;</a>&nbsp;<c41>unique&nbsp;path).&nbsp;Therefore,&nbsp;we&nbsp;could&nbsp;reasonably&nbsp;create&nbsp;a&nbsp;frozen&nbsp;`&amp;int`
</c41><br/><ln>&nbsp;&nbsp;876</ln><a id="876">&nbsp;</a>&nbsp;<c41>pointer&nbsp;pointing&nbsp;at&nbsp;`*t0`&nbsp;that&nbsp;coexists&nbsp;with&nbsp;the&nbsp;mutable&nbsp;pointer&nbsp;`p`,
</c41><br/><ln>&nbsp;&nbsp;877</ln><a id="877">&nbsp;</a>&nbsp;<c41>which&nbsp;is&nbsp;clearly&nbsp;unsound.
</c41><br/><ln>&nbsp;&nbsp;878</ln><a id="878">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;879</ln><a id="879">&nbsp;</a>&nbsp;<c41>However,&nbsp;it&nbsp;is&nbsp;not&nbsp;always&nbsp;unsafe&nbsp;to&nbsp;freeze&nbsp;the&nbsp;base&nbsp;pointer.&nbsp;In
</c41><br/><ln>&nbsp;&nbsp;880</ln><a id="880">&nbsp;</a>&nbsp;<c41>particular,&nbsp;if&nbsp;the&nbsp;referent&nbsp;is&nbsp;frozen,&nbsp;there&nbsp;is&nbsp;no&nbsp;harm&nbsp;in&nbsp;it:
</c41><br/><ln>&nbsp;&nbsp;881</ln><a id="881">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;882</ln><a id="882">&nbsp;</a>&nbsp;<c41>```
</c41><br/><ln>&nbsp;&nbsp;883</ln><a id="883">&nbsp;</a>&nbsp;<c41>//&nbsp;src/test/run-pass/borrowck-borrow-of-mut-base-ptr-safe.rs
</c41><br/><ln>&nbsp;&nbsp;884</ln><a id="884">&nbsp;</a>&nbsp;<c41>fn&nbsp;foo&lt;'a&gt;(mut&nbsp;t0:&nbsp;&amp;'a&nbsp;mut&nbsp;int,
</c41><br/><ln>&nbsp;&nbsp;885</ln><a id="885">&nbsp;</a>&nbsp;<c41>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mut&nbsp;t1:&nbsp;&amp;'a&nbsp;mut&nbsp;int)&nbsp;{
</c41><br/><ln>&nbsp;&nbsp;886</ln><a id="886">&nbsp;</a>&nbsp;<c41>&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;p:&nbsp;&amp;int&nbsp;=&nbsp;&amp;*t0;&nbsp;//&nbsp;Freezes&nbsp;`*t0`
</c41><br/><ln>&nbsp;&nbsp;887</ln><a id="887">&nbsp;</a>&nbsp;<c41>&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;mut&nbsp;t2&nbsp;=&nbsp;&amp;t0;
</c41><br/><ln>&nbsp;&nbsp;888</ln><a id="888">&nbsp;</a>&nbsp;<c41>&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;q:&nbsp;&amp;int&nbsp;=&nbsp;&amp;*t2;&nbsp;//&nbsp;Freezes&nbsp;`*t0`,&nbsp;but&nbsp;that's&nbsp;ok...
</c41><br/><ln>&nbsp;&nbsp;889</ln><a id="889">&nbsp;</a>&nbsp;<c41>&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;r:&nbsp;&amp;int&nbsp;=&nbsp;&amp;*t0;&nbsp;//&nbsp;...after&nbsp;all,&nbsp;could&nbsp;do&nbsp;same&nbsp;thing&nbsp;directly.
</c41><br/><ln>&nbsp;&nbsp;890</ln><a id="890">&nbsp;</a>&nbsp;<c41>}
</c41><br/><ln>&nbsp;&nbsp;891</ln><a id="891">&nbsp;</a>&nbsp;<c41>```
</c41><br/><ln>&nbsp;&nbsp;892</ln><a id="892">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;893</ln><a id="893">&nbsp;</a>&nbsp;<c41>In&nbsp;this&nbsp;case,&nbsp;creating&nbsp;the&nbsp;alias&nbsp;`t2`&nbsp;of&nbsp;`t0`&nbsp;is&nbsp;safe&nbsp;because&nbsp;the&nbsp;only
</c41><br/><ln>&nbsp;&nbsp;894</ln><a id="894">&nbsp;</a>&nbsp;<c41>thing&nbsp;`t2`&nbsp;can&nbsp;be&nbsp;used&nbsp;for&nbsp;is&nbsp;to&nbsp;further&nbsp;freeze&nbsp;`*t0`,&nbsp;which&nbsp;is
</c41><br/><ln>&nbsp;&nbsp;895</ln><a id="895">&nbsp;</a>&nbsp;<c41>already&nbsp;frozen.&nbsp;In&nbsp;particular,&nbsp;we&nbsp;cannot&nbsp;assign&nbsp;to&nbsp;`*t0`&nbsp;through&nbsp;the
</c41><br/><ln>&nbsp;&nbsp;896</ln><a id="896">&nbsp;</a>&nbsp;<c41>new&nbsp;alias&nbsp;`t2`,&nbsp;as&nbsp;demonstrated&nbsp;in&nbsp;this&nbsp;test&nbsp;case:
</c41><br/><ln>&nbsp;&nbsp;897</ln><a id="897">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;898</ln><a id="898">&nbsp;</a>&nbsp;<c41>```
</c41><br/><ln>&nbsp;&nbsp;899</ln><a id="899">&nbsp;</a>&nbsp;<c41>//&nbsp;src/test/run-pass/borrowck-borrow-mut-base-ptr-in-aliasable-loc.rs
</c41><br/><ln>&nbsp;&nbsp;900</ln><a id="900">&nbsp;</a>&nbsp;<c41>fn&nbsp;foo(t0:&nbsp;&amp;&nbsp;&amp;mut&nbsp;int)&nbsp;{
</c41><br/><ln>&nbsp;&nbsp;901</ln><a id="901">&nbsp;</a>&nbsp;<c41>&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;t1&nbsp;=&nbsp;t0;
</c41><br/><ln>&nbsp;&nbsp;902</ln><a id="902">&nbsp;</a>&nbsp;<c41>&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;p:&nbsp;&amp;int&nbsp;=&nbsp;&amp;**t0;
</c41><br/><ln>&nbsp;&nbsp;903</ln><a id="903">&nbsp;</a>&nbsp;<c41>&nbsp;&nbsp;&nbsp;&nbsp;**t1&nbsp;=&nbsp;22;&nbsp;//~&nbsp;ERROR&nbsp;cannot&nbsp;assign
</c41><br/><ln>&nbsp;&nbsp;904</ln><a id="904">&nbsp;</a>&nbsp;<c41>}
</c41><br/><ln>&nbsp;&nbsp;905</ln><a id="905">&nbsp;</a>&nbsp;<c41>```
</c41><br/><ln>&nbsp;&nbsp;906</ln><a id="906">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;907</ln><a id="907">&nbsp;</a>&nbsp;<c41>This&nbsp;distinction&nbsp;is&nbsp;reflected&nbsp;in&nbsp;the&nbsp;rules.&nbsp;When&nbsp;doing&nbsp;an&nbsp;`&amp;mut`
</c41><br/><ln>&nbsp;&nbsp;908</ln><a id="908">&nbsp;</a>&nbsp;<c41>borrow&nbsp;--&nbsp;as&nbsp;in&nbsp;the&nbsp;first&nbsp;example&nbsp;--&nbsp;the&nbsp;set&nbsp;`ACTIONS`&nbsp;will&nbsp;be
</c41><br/><ln>&nbsp;&nbsp;909</ln><a id="909">&nbsp;</a>&nbsp;<c41>`CLAIM|MUTATE|FREEZE`,&nbsp;because&nbsp;claiming&nbsp;the&nbsp;referent&nbsp;implies&nbsp;that&nbsp;it
</c41><br/><ln>&nbsp;&nbsp;910</ln><a id="910">&nbsp;</a>&nbsp;<c41>cannot&nbsp;be&nbsp;claimed,&nbsp;mutated,&nbsp;or&nbsp;frozen&nbsp;by&nbsp;anyone&nbsp;else.&nbsp;These
</c41><br/><ln>&nbsp;&nbsp;911</ln><a id="911">&nbsp;</a>&nbsp;<c41>restrictions&nbsp;are&nbsp;propagated&nbsp;back&nbsp;to&nbsp;the&nbsp;base&nbsp;path&nbsp;and&nbsp;hence&nbsp;the&nbsp;base
</c41><br/><ln>&nbsp;&nbsp;912</ln><a id="912">&nbsp;</a>&nbsp;<c41>path&nbsp;is&nbsp;considered&nbsp;unfreezable.
</c41><br/><ln>&nbsp;&nbsp;913</ln><a id="913">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;914</ln><a id="914">&nbsp;</a>&nbsp;<c41>In&nbsp;contrast,&nbsp;when&nbsp;the&nbsp;referent&nbsp;is&nbsp;merely&nbsp;frozen&nbsp;--&nbsp;as&nbsp;in&nbsp;the&nbsp;second
</c41><br/><ln>&nbsp;&nbsp;915</ln><a id="915">&nbsp;</a>&nbsp;<c41>example&nbsp;--&nbsp;the&nbsp;set&nbsp;`ACTIONS`&nbsp;will&nbsp;be&nbsp;`CLAIM|MUTATE`,&nbsp;because&nbsp;freezing
</c41><br/><ln>&nbsp;&nbsp;916</ln><a id="916">&nbsp;</a>&nbsp;<c41>the&nbsp;referent&nbsp;implies&nbsp;that&nbsp;it&nbsp;cannot&nbsp;be&nbsp;claimed&nbsp;or&nbsp;mutated&nbsp;but&nbsp;permits
</c41><br/><ln>&nbsp;&nbsp;917</ln><a id="917">&nbsp;</a>&nbsp;<c41>others&nbsp;to&nbsp;freeze.&nbsp;Hence&nbsp;when&nbsp;these&nbsp;restrictions&nbsp;are&nbsp;propagated&nbsp;back&nbsp;to
</c41><br/><ln>&nbsp;&nbsp;918</ln><a id="918">&nbsp;</a>&nbsp;<c41>the&nbsp;base&nbsp;path,&nbsp;it&nbsp;will&nbsp;still&nbsp;be&nbsp;considered&nbsp;freezable.
</c41><br/><ln>&nbsp;&nbsp;919</ln><a id="919">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;920</ln><a id="920">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;921</ln><a id="921">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;922</ln><a id="922">&nbsp;</a>&nbsp;<c41>**FIXME&nbsp;#10520:&nbsp;Restrictions&nbsp;against&nbsp;mutating&nbsp;the&nbsp;base&nbsp;pointer.**&nbsp;When
</c41><br/><ln>&nbsp;&nbsp;923</ln><a id="923">&nbsp;</a>&nbsp;<c41>an&nbsp;`&amp;mut`&nbsp;pointer&nbsp;is&nbsp;frozen&nbsp;or&nbsp;claimed,&nbsp;we&nbsp;currently&nbsp;pass&nbsp;along&nbsp;the
</c41><br/><ln>&nbsp;&nbsp;924</ln><a id="924">&nbsp;</a>&nbsp;<c41>restriction&nbsp;against&nbsp;MUTATE&nbsp;to&nbsp;the&nbsp;base&nbsp;pointer.&nbsp;I&nbsp;do&nbsp;not&nbsp;believe&nbsp;this
</c41><br/><ln>&nbsp;&nbsp;925</ln><a id="925">&nbsp;</a>&nbsp;<c41>restriction&nbsp;is&nbsp;needed.&nbsp;It&nbsp;dates&nbsp;from&nbsp;the&nbsp;days&nbsp;when&nbsp;we&nbsp;had&nbsp;a&nbsp;way&nbsp;to
</c41><br/><ln>&nbsp;&nbsp;926</ln><a id="926">&nbsp;</a>&nbsp;<c41>mutate&nbsp;that&nbsp;preserved&nbsp;the&nbsp;value&nbsp;being&nbsp;mutated&nbsp;(i.e.,&nbsp;swap).&nbsp;Nowadays
</c41><br/><ln>&nbsp;&nbsp;927</ln><a id="927">&nbsp;</a>&nbsp;<c41>the&nbsp;only&nbsp;form&nbsp;of&nbsp;mutation&nbsp;is&nbsp;assignment,&nbsp;which&nbsp;destroys&nbsp;the&nbsp;pointer
</c41><br/><ln>&nbsp;&nbsp;928</ln><a id="928">&nbsp;</a>&nbsp;<c41>being&nbsp;mutated&nbsp;--&nbsp;therefore,&nbsp;a&nbsp;mutation&nbsp;cannot&nbsp;create&nbsp;a&nbsp;new&nbsp;path&nbsp;to&nbsp;the
</c41><br/><ln>&nbsp;&nbsp;929</ln><a id="929">&nbsp;</a>&nbsp;<c41>same&nbsp;data.&nbsp;Rather,&nbsp;it&nbsp;removes&nbsp;an&nbsp;existing&nbsp;path.&nbsp;This&nbsp;implies&nbsp;that&nbsp;not
</c41><br/><ln>&nbsp;&nbsp;930</ln><a id="930">&nbsp;</a>&nbsp;<c41>only&nbsp;can&nbsp;we&nbsp;permit&nbsp;mutation,&nbsp;we&nbsp;can&nbsp;have&nbsp;mutation&nbsp;kill&nbsp;restrictions&nbsp;in
</c41><br/><ln>&nbsp;&nbsp;931</ln><a id="931">&nbsp;</a>&nbsp;<c41>the&nbsp;dataflow&nbsp;sense.
</c41><br/><ln>&nbsp;&nbsp;932</ln><a id="932">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;933</ln><a id="933">&nbsp;</a>&nbsp;<c41>**WARNING:**&nbsp;We&nbsp;do&nbsp;not&nbsp;currently&nbsp;have&nbsp;`const`&nbsp;borrows&nbsp;in&nbsp;the
</c41><br/><ln>&nbsp;&nbsp;934</ln><a id="934">&nbsp;</a>&nbsp;<c41>language.&nbsp;If&nbsp;they&nbsp;are&nbsp;added&nbsp;back&nbsp;in,&nbsp;we&nbsp;must&nbsp;ensure&nbsp;that&nbsp;they&nbsp;are
</c41><br/><ln>&nbsp;&nbsp;935</ln><a id="935">&nbsp;</a>&nbsp;<c41>consistent&nbsp;with&nbsp;all&nbsp;of&nbsp;these&nbsp;examples.&nbsp;The&nbsp;crucial&nbsp;question&nbsp;will&nbsp;be
</c41><br/><ln>&nbsp;&nbsp;936</ln><a id="936">&nbsp;</a>&nbsp;<c41>what&nbsp;sorts&nbsp;of&nbsp;actions&nbsp;are&nbsp;permitted&nbsp;with&nbsp;a&nbsp;`&amp;const&nbsp;&amp;mut`&nbsp;pointer.&nbsp;I
</c41><br/><ln>&nbsp;&nbsp;937</ln><a id="937">&nbsp;</a>&nbsp;<c41>would&nbsp;suggest&nbsp;that&nbsp;an&nbsp;`&amp;mut`&nbsp;referent&nbsp;found&nbsp;in&nbsp;an&nbsp;`&amp;const`&nbsp;location&nbsp;be
</c41><br/><ln>&nbsp;&nbsp;938</ln><a id="938">&nbsp;</a>&nbsp;<c41>prohibited&nbsp;from&nbsp;both&nbsp;freezes&nbsp;and&nbsp;claims.&nbsp;This&nbsp;would&nbsp;avoid&nbsp;the&nbsp;need&nbsp;to
</c41><br/><ln>&nbsp;&nbsp;939</ln><a id="939">&nbsp;</a>&nbsp;<c41>prevent&nbsp;`const`&nbsp;borrows&nbsp;of&nbsp;the&nbsp;base&nbsp;pointer&nbsp;when&nbsp;the&nbsp;referent&nbsp;is
</c41><br/><ln>&nbsp;&nbsp;940</ln><a id="940">&nbsp;</a>&nbsp;<c41>borrowed.
</c41><br/><ln>&nbsp;&nbsp;941</ln><a id="941">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;942</ln><a id="942">&nbsp;</a>&nbsp;<c41>#&nbsp;Moves&nbsp;and&nbsp;initialization
</c41><br/><ln>&nbsp;&nbsp;943</ln><a id="943">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;944</ln><a id="944">&nbsp;</a>&nbsp;<c41>The&nbsp;borrow&nbsp;checker&nbsp;is&nbsp;also&nbsp;in&nbsp;charge&nbsp;of&nbsp;ensuring&nbsp;that:
</c41><br/><ln>&nbsp;&nbsp;945</ln><a id="945">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;946</ln><a id="946">&nbsp;</a>&nbsp;<c41>-&nbsp;all&nbsp;memory&nbsp;which&nbsp;is&nbsp;accessed&nbsp;is&nbsp;initialized
</c41><br/><ln>&nbsp;&nbsp;947</ln><a id="947">&nbsp;</a>&nbsp;<c41>-&nbsp;immutable&nbsp;local&nbsp;variables&nbsp;are&nbsp;assigned&nbsp;at&nbsp;most&nbsp;once.
</c41><br/><ln>&nbsp;&nbsp;948</ln><a id="948">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;949</ln><a id="949">&nbsp;</a>&nbsp;<c41>These&nbsp;are&nbsp;two&nbsp;separate&nbsp;dataflow&nbsp;analyses&nbsp;built&nbsp;on&nbsp;the&nbsp;same
</c41><br/><ln>&nbsp;&nbsp;950</ln><a id="950">&nbsp;</a>&nbsp;<c41>framework.&nbsp;Let's&nbsp;look&nbsp;at&nbsp;checking&nbsp;that&nbsp;memory&nbsp;is&nbsp;initialized&nbsp;first;
</c41><br/><ln>&nbsp;&nbsp;951</ln><a id="951">&nbsp;</a>&nbsp;<c41>the&nbsp;checking&nbsp;of&nbsp;immutable&nbsp;local&nbsp;variabe&nbsp;assignments&nbsp;works&nbsp;in&nbsp;a&nbsp;very
</c41><br/><ln>&nbsp;&nbsp;952</ln><a id="952">&nbsp;</a>&nbsp;<c41>similar&nbsp;way.
</c41><br/><ln>&nbsp;&nbsp;953</ln><a id="953">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;954</ln><a id="954">&nbsp;</a>&nbsp;<c41>To&nbsp;track&nbsp;the&nbsp;initialization&nbsp;of&nbsp;memory,&nbsp;we&nbsp;actually&nbsp;track&nbsp;all&nbsp;the
</c41><br/><ln>&nbsp;&nbsp;955</ln><a id="955">&nbsp;</a>&nbsp;<c41>points&nbsp;in&nbsp;the&nbsp;program&nbsp;that&nbsp;*create&nbsp;uninitialized&nbsp;memory*,&nbsp;meaning
</c41><br/><ln>&nbsp;&nbsp;956</ln><a id="956">&nbsp;</a>&nbsp;<c41>moves&nbsp;and&nbsp;the&nbsp;declaration&nbsp;of&nbsp;uninitialized&nbsp;variables.&nbsp;For&nbsp;each&nbsp;of
</c41><br/><ln>&nbsp;&nbsp;957</ln><a id="957">&nbsp;</a>&nbsp;<c41>these&nbsp;points,&nbsp;we&nbsp;create&nbsp;a&nbsp;bit&nbsp;in&nbsp;the&nbsp;dataflow&nbsp;set.&nbsp;Assignments&nbsp;to&nbsp;a
</c41><br/><ln>&nbsp;&nbsp;958</ln><a id="958">&nbsp;</a>&nbsp;<c41>variable&nbsp;`x`&nbsp;or&nbsp;path&nbsp;`a.b.c`&nbsp;kill&nbsp;the&nbsp;move/uninitialization&nbsp;bits&nbsp;for
</c41><br/><ln>&nbsp;&nbsp;959</ln><a id="959">&nbsp;</a>&nbsp;<c41>those&nbsp;paths&nbsp;and&nbsp;any&nbsp;subpaths&nbsp;(e.g.,&nbsp;`x`,&nbsp;`x.y`,&nbsp;`a.b.c`,&nbsp;`*a.b.c`).
</c41><br/><ln>&nbsp;&nbsp;960</ln><a id="960">&nbsp;</a>&nbsp;<c41>The&nbsp;bits&nbsp;are&nbsp;also&nbsp;killed&nbsp;when&nbsp;the&nbsp;root&nbsp;variables&nbsp;(`x`,&nbsp;`a`)&nbsp;go&nbsp;out&nbsp;of
</c41><br/><ln>&nbsp;&nbsp;961</ln><a id="961">&nbsp;</a>&nbsp;<c41>scope.&nbsp;Bits&nbsp;are&nbsp;unioned&nbsp;when&nbsp;two&nbsp;control-flow&nbsp;paths&nbsp;join.&nbsp;Thus,&nbsp;the
</c41><br/><ln>&nbsp;&nbsp;962</ln><a id="962">&nbsp;</a>&nbsp;<c41>presence&nbsp;of&nbsp;a&nbsp;bit&nbsp;indicates&nbsp;that&nbsp;the&nbsp;move&nbsp;may&nbsp;have&nbsp;occurred&nbsp;without&nbsp;an
</c41><br/><ln>&nbsp;&nbsp;963</ln><a id="963">&nbsp;</a>&nbsp;<c41>intervening&nbsp;assignment&nbsp;to&nbsp;the&nbsp;same&nbsp;memory.&nbsp;At&nbsp;each&nbsp;use&nbsp;of&nbsp;a&nbsp;variable,
</c41><br/><ln>&nbsp;&nbsp;964</ln><a id="964">&nbsp;</a>&nbsp;<c41>we&nbsp;examine&nbsp;the&nbsp;bits&nbsp;in&nbsp;scope,&nbsp;and&nbsp;check&nbsp;that&nbsp;none&nbsp;of&nbsp;them&nbsp;are
</c41><br/><ln>&nbsp;&nbsp;965</ln><a id="965">&nbsp;</a>&nbsp;<c41>moves/uninitializations&nbsp;of&nbsp;the&nbsp;variable&nbsp;that&nbsp;is&nbsp;being&nbsp;used.
</c41><br/><ln>&nbsp;&nbsp;966</ln><a id="966">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;967</ln><a id="967">&nbsp;</a>&nbsp;<c41>Let's&nbsp;look&nbsp;at&nbsp;a&nbsp;simple&nbsp;example:
</c41><br/><ln>&nbsp;&nbsp;968</ln><a id="968">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;969</ln><a id="969">&nbsp;</a>&nbsp;<c41>```
</c41><br/><ln>&nbsp;&nbsp;970</ln><a id="970">&nbsp;</a>&nbsp;<c41>fn&nbsp;foo(a:&nbsp;Box&lt;int&gt;)&nbsp;{
</c41><br/><ln>&nbsp;&nbsp;971</ln><a id="971">&nbsp;</a>&nbsp;<c41>&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;b:&nbsp;Box&lt;int&gt;;&nbsp;&nbsp;&nbsp;//&nbsp;Gen&nbsp;bit&nbsp;0.
</c41><br/><ln>&nbsp;&nbsp;972</ln><a id="972">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;973</ln><a id="973">&nbsp;</a>&nbsp;<c41>&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;cond&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Bits:&nbsp;0
</c41><br/><ln>&nbsp;&nbsp;974</ln><a id="974">&nbsp;</a>&nbsp;<c41>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;use(&amp;*a);
</c41><br/><ln>&nbsp;&nbsp;975</ln><a id="975">&nbsp;</a>&nbsp;<c41>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b&nbsp;=&nbsp;a;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Gen&nbsp;bit&nbsp;1,&nbsp;kill&nbsp;bit&nbsp;0.
</c41><br/><ln>&nbsp;&nbsp;976</ln><a id="976">&nbsp;</a>&nbsp;<c41>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;use(&amp;*b);
</c41><br/><ln>&nbsp;&nbsp;977</ln><a id="977">&nbsp;</a>&nbsp;<c41>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;else&nbsp;{
</c41><br/><ln>&nbsp;&nbsp;978</ln><a id="978">&nbsp;</a>&nbsp;<c41>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Bits:&nbsp;0
</c41><br/><ln>&nbsp;&nbsp;979</ln><a id="979">&nbsp;</a>&nbsp;<c41>&nbsp;&nbsp;&nbsp;&nbsp;}
</c41><br/><ln>&nbsp;&nbsp;980</ln><a id="980">&nbsp;</a>&nbsp;<c41>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Bits:&nbsp;0,1
</c41><br/><ln>&nbsp;&nbsp;981</ln><a id="981">&nbsp;</a>&nbsp;<c41>&nbsp;&nbsp;&nbsp;&nbsp;use(&amp;*a);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Error.
</c41><br/><ln>&nbsp;&nbsp;982</ln><a id="982">&nbsp;</a>&nbsp;<c41>&nbsp;&nbsp;&nbsp;&nbsp;use(&amp;*b);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Error.
</c41><br/><ln>&nbsp;&nbsp;983</ln><a id="983">&nbsp;</a>&nbsp;<c41>}
</c41><br/><ln>&nbsp;&nbsp;984</ln><a id="984">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;985</ln><a id="985">&nbsp;</a>&nbsp;<c41>fn&nbsp;use(a:&nbsp;&amp;int)&nbsp;{&nbsp;}
</c41><br/><ln>&nbsp;&nbsp;986</ln><a id="986">&nbsp;</a>&nbsp;<c41>```
</c41><br/><ln>&nbsp;&nbsp;987</ln><a id="987">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;&nbsp;988</ln><a id="988">&nbsp;</a>&nbsp;<c41>In&nbsp;this&nbsp;example,&nbsp;the&nbsp;variable&nbsp;`b`&nbsp;is&nbsp;created&nbsp;uninitialized.&nbsp;In&nbsp;one
</c41><br/><ln>&nbsp;&nbsp;989</ln><a id="989">&nbsp;</a>&nbsp;<c41>branch&nbsp;of&nbsp;an&nbsp;`if`,&nbsp;we&nbsp;then&nbsp;move&nbsp;the&nbsp;variable&nbsp;`a`&nbsp;into&nbsp;`b`.&nbsp;Once&nbsp;we
</c41><br/><ln>&nbsp;&nbsp;990</ln><a id="990">&nbsp;</a>&nbsp;<c41>exit&nbsp;the&nbsp;`if`,&nbsp;therefore,&nbsp;it&nbsp;is&nbsp;an&nbsp;error&nbsp;to&nbsp;use&nbsp;`a`&nbsp;or&nbsp;`b`&nbsp;since&nbsp;both
</c41><br/><ln>&nbsp;&nbsp;991</ln><a id="991">&nbsp;</a>&nbsp;<c41>are&nbsp;only&nbsp;conditionally&nbsp;initialized.&nbsp;I&nbsp;have&nbsp;annotated&nbsp;the&nbsp;dataflow
</c41><br/><ln>&nbsp;&nbsp;992</ln><a id="992">&nbsp;</a>&nbsp;<c41>state&nbsp;using&nbsp;comments.&nbsp;There&nbsp;are&nbsp;two&nbsp;dataflow&nbsp;bits,&nbsp;with&nbsp;bit&nbsp;0
</c41><br/><ln>&nbsp;&nbsp;993</ln><a id="993">&nbsp;</a>&nbsp;<c41>corresponding&nbsp;to&nbsp;the&nbsp;creation&nbsp;of&nbsp;`b`&nbsp;without&nbsp;an&nbsp;initializer,&nbsp;and&nbsp;bit&nbsp;1
</c41><br/><ln>&nbsp;&nbsp;994</ln><a id="994">&nbsp;</a>&nbsp;<c41>corresponding&nbsp;to&nbsp;the&nbsp;move&nbsp;of&nbsp;`a`.&nbsp;The&nbsp;assignment&nbsp;`b&nbsp;=&nbsp;a`&nbsp;both
</c41><br/><ln>&nbsp;&nbsp;995</ln><a id="995">&nbsp;</a>&nbsp;<c41>generates&nbsp;bit&nbsp;1,&nbsp;because&nbsp;it&nbsp;is&nbsp;a&nbsp;move&nbsp;of&nbsp;`a`,&nbsp;and&nbsp;kills&nbsp;bit&nbsp;0,&nbsp;because
</c41><br/><ln>&nbsp;&nbsp;996</ln><a id="996">&nbsp;</a>&nbsp;<c41>`b`&nbsp;is&nbsp;now&nbsp;initialized.&nbsp;On&nbsp;the&nbsp;else&nbsp;branch,&nbsp;though,&nbsp;`b`&nbsp;is&nbsp;never
</c41><br/><ln>&nbsp;&nbsp;997</ln><a id="997">&nbsp;</a>&nbsp;<c41>initialized,&nbsp;and&nbsp;so&nbsp;bit&nbsp;0&nbsp;remains&nbsp;untouched.&nbsp;When&nbsp;the&nbsp;two&nbsp;flows&nbsp;of
</c41><br/><ln>&nbsp;&nbsp;998</ln><a id="998">&nbsp;</a>&nbsp;<c41>control&nbsp;join,&nbsp;we&nbsp;union&nbsp;the&nbsp;bits&nbsp;from&nbsp;both&nbsp;sides,&nbsp;resulting&nbsp;in&nbsp;both
</c41><br/><ln>&nbsp;&nbsp;999</ln><a id="999">&nbsp;</a>&nbsp;<c41>bits&nbsp;0&nbsp;and&nbsp;1&nbsp;being&nbsp;set.&nbsp;Thus&nbsp;any&nbsp;attempt&nbsp;to&nbsp;use&nbsp;`a`&nbsp;uncovers&nbsp;the&nbsp;bit&nbsp;1
</c41><br/><ln>&nbsp;1000</ln><a id="1000">&nbsp;</a>&nbsp;<c41>from&nbsp;the&nbsp;"then"&nbsp;branch,&nbsp;showing&nbsp;that&nbsp;`a`&nbsp;may&nbsp;be&nbsp;moved,&nbsp;and&nbsp;any&nbsp;attempt
</c41><br/><ln>&nbsp;1001</ln><a id="1001">&nbsp;</a>&nbsp;<c41>to&nbsp;use&nbsp;`b`&nbsp;uncovers&nbsp;bit&nbsp;0,&nbsp;from&nbsp;the&nbsp;"else"&nbsp;branch,&nbsp;showing&nbsp;that&nbsp;`b`
</c41><br/><ln>&nbsp;1002</ln><a id="1002">&nbsp;</a>&nbsp;<c41>may&nbsp;not&nbsp;be&nbsp;initialized.
</c41><br/><ln>&nbsp;1003</ln><a id="1003">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;1004</ln><a id="1004">&nbsp;</a>&nbsp;<c41>##&nbsp;Initialization&nbsp;of&nbsp;immutable&nbsp;variables
</c41><br/><ln>&nbsp;1005</ln><a id="1005">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;1006</ln><a id="1006">&nbsp;</a>&nbsp;<c41>Initialization&nbsp;of&nbsp;immutable&nbsp;variables&nbsp;works&nbsp;in&nbsp;a&nbsp;very&nbsp;similar&nbsp;way,
</c41><br/><ln>&nbsp;1007</ln><a id="1007">&nbsp;</a>&nbsp;<c41>except&nbsp;that:
</c41><br/><ln>&nbsp;1008</ln><a id="1008">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;1009</ln><a id="1009">&nbsp;</a>&nbsp;<c41>1.&nbsp;we&nbsp;generate&nbsp;bits&nbsp;for&nbsp;each&nbsp;assignment&nbsp;to&nbsp;a&nbsp;variable;
</c41><br/><ln>&nbsp;1010</ln><a id="1010">&nbsp;</a>&nbsp;<c41>2.&nbsp;the&nbsp;bits&nbsp;are&nbsp;never&nbsp;killed&nbsp;except&nbsp;when&nbsp;the&nbsp;variable&nbsp;goes&nbsp;out&nbsp;of&nbsp;scope.
</c41><br/><ln>&nbsp;1011</ln><a id="1011">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;1012</ln><a id="1012">&nbsp;</a>&nbsp;<c41>Thus&nbsp;the&nbsp;presence&nbsp;of&nbsp;an&nbsp;assignment&nbsp;bit&nbsp;indicates&nbsp;that&nbsp;the&nbsp;assignment
</c41><br/><ln>&nbsp;1013</ln><a id="1013">&nbsp;</a>&nbsp;<c41>may&nbsp;have&nbsp;occurred.&nbsp;Note&nbsp;that&nbsp;assignments&nbsp;are&nbsp;only&nbsp;killed&nbsp;when&nbsp;the
</c41><br/><ln>&nbsp;1014</ln><a id="1014">&nbsp;</a>&nbsp;<c41>variable&nbsp;goes&nbsp;out&nbsp;of&nbsp;scope,&nbsp;as&nbsp;it&nbsp;is&nbsp;not&nbsp;relevant&nbsp;whether&nbsp;or&nbsp;not&nbsp;there
</c41><br/><ln>&nbsp;1015</ln><a id="1015">&nbsp;</a>&nbsp;<c41>has&nbsp;been&nbsp;a&nbsp;move&nbsp;in&nbsp;the&nbsp;meantime.&nbsp;Using&nbsp;these&nbsp;bits,&nbsp;we&nbsp;can&nbsp;declare&nbsp;that
</c41><br/><ln>&nbsp;1016</ln><a id="1016">&nbsp;</a>&nbsp;<c41>an&nbsp;assignment&nbsp;to&nbsp;an&nbsp;immutable&nbsp;variable&nbsp;is&nbsp;legal&nbsp;iff&nbsp;there&nbsp;is&nbsp;no&nbsp;other
</c41><br/><ln>&nbsp;1017</ln><a id="1017">&nbsp;</a>&nbsp;<c41>assignment&nbsp;bit&nbsp;to&nbsp;that&nbsp;same&nbsp;variable&nbsp;in&nbsp;scope.
</c41><br/><ln>&nbsp;1018</ln><a id="1018">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;1019</ln><a id="1019">&nbsp;</a>&nbsp;<c41>##&nbsp;Why&nbsp;is&nbsp;the&nbsp;design&nbsp;made&nbsp;this&nbsp;way?
</c41><br/><ln>&nbsp;1020</ln><a id="1020">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;1021</ln><a id="1021">&nbsp;</a>&nbsp;<c41>It&nbsp;may&nbsp;seem&nbsp;surprising&nbsp;that&nbsp;we&nbsp;assign&nbsp;dataflow&nbsp;bits&nbsp;to&nbsp;*each&nbsp;move*
</c41><br/><ln>&nbsp;1022</ln><a id="1022">&nbsp;</a>&nbsp;<c41>rather&nbsp;than&nbsp;*each&nbsp;path&nbsp;being&nbsp;moved*.&nbsp;This&nbsp;is&nbsp;somewhat&nbsp;less&nbsp;efficient,
</c41><br/><ln>&nbsp;1023</ln><a id="1023">&nbsp;</a>&nbsp;<c41>since&nbsp;on&nbsp;each&nbsp;use,&nbsp;we&nbsp;must&nbsp;iterate&nbsp;through&nbsp;all&nbsp;moves&nbsp;and&nbsp;check&nbsp;whether
</c41><br/><ln>&nbsp;1024</ln><a id="1024">&nbsp;</a>&nbsp;<c41>any&nbsp;of&nbsp;them&nbsp;correspond&nbsp;to&nbsp;the&nbsp;path&nbsp;in&nbsp;question.&nbsp;Similar&nbsp;concerns&nbsp;apply
</c41><br/><ln>&nbsp;1025</ln><a id="1025">&nbsp;</a>&nbsp;<c41>to&nbsp;the&nbsp;analysis&nbsp;for&nbsp;double&nbsp;assignments&nbsp;to&nbsp;immutable&nbsp;variables.&nbsp;The
</c41><br/><ln>&nbsp;1026</ln><a id="1026">&nbsp;</a>&nbsp;<c41>main&nbsp;reason&nbsp;to&nbsp;do&nbsp;it&nbsp;this&nbsp;way&nbsp;is&nbsp;that&nbsp;it&nbsp;allows&nbsp;us&nbsp;to&nbsp;print&nbsp;better
</c41><br/><ln>&nbsp;1027</ln><a id="1027">&nbsp;</a>&nbsp;<c41>error&nbsp;messages,&nbsp;because&nbsp;when&nbsp;a&nbsp;use&nbsp;occurs,&nbsp;we&nbsp;can&nbsp;print&nbsp;out&nbsp;the
</c41><br/><ln>&nbsp;1028</ln><a id="1028">&nbsp;</a>&nbsp;<c41>precise&nbsp;move&nbsp;that&nbsp;may&nbsp;be&nbsp;in&nbsp;scope,&nbsp;rather&nbsp;than&nbsp;simply&nbsp;having&nbsp;to&nbsp;say
</c41><br/><ln>&nbsp;1029</ln><a id="1029">&nbsp;</a>&nbsp;<c41>"the&nbsp;variable&nbsp;may&nbsp;not&nbsp;be&nbsp;initialized".
</c41><br/><ln>&nbsp;1030</ln><a id="1030">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;1031</ln><a id="1031">&nbsp;</a>&nbsp;<c41>##&nbsp;Data&nbsp;structures&nbsp;used&nbsp;in&nbsp;the&nbsp;move&nbsp;analysis
</c41><br/><ln>&nbsp;1032</ln><a id="1032">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;1033</ln><a id="1033">&nbsp;</a>&nbsp;<c41>The&nbsp;move&nbsp;analysis&nbsp;maintains&nbsp;several&nbsp;data&nbsp;structures&nbsp;that&nbsp;enable&nbsp;it&nbsp;to
</c41><br/><ln>&nbsp;1034</ln><a id="1034">&nbsp;</a>&nbsp;<c41>cross-reference&nbsp;moves&nbsp;and&nbsp;assignments&nbsp;to&nbsp;determine&nbsp;when&nbsp;they&nbsp;may&nbsp;be
</c41><br/><ln>&nbsp;1035</ln><a id="1035">&nbsp;</a>&nbsp;<c41>moving/assigning&nbsp;the&nbsp;same&nbsp;memory.&nbsp;These&nbsp;are&nbsp;all&nbsp;collected&nbsp;into&nbsp;the
</c41><br/><ln>&nbsp;1036</ln><a id="1036">&nbsp;</a>&nbsp;<c41>`MoveData`&nbsp;and&nbsp;`FlowedMoveData`&nbsp;structs.&nbsp;The&nbsp;former&nbsp;represents&nbsp;the&nbsp;set
</c41><br/><ln>&nbsp;1037</ln><a id="1037">&nbsp;</a>&nbsp;<c41>of&nbsp;move&nbsp;paths,&nbsp;moves,&nbsp;and&nbsp;assignments,&nbsp;and&nbsp;the&nbsp;latter&nbsp;adds&nbsp;in&nbsp;the
</c41><br/><ln>&nbsp;1038</ln><a id="1038">&nbsp;</a>&nbsp;<c41>results&nbsp;of&nbsp;a&nbsp;dataflow&nbsp;computation.
</c41><br/><ln>&nbsp;1039</ln><a id="1039">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;1040</ln><a id="1040">&nbsp;</a>&nbsp;<c41>###&nbsp;Move&nbsp;paths
</c41><br/><ln>&nbsp;1041</ln><a id="1041">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;1042</ln><a id="1042">&nbsp;</a>&nbsp;<c41>The&nbsp;`MovePath`&nbsp;tree&nbsp;tracks&nbsp;every&nbsp;path&nbsp;that&nbsp;is&nbsp;moved&nbsp;or&nbsp;assigned&nbsp;to.
</c41><br/><ln>&nbsp;1043</ln><a id="1043">&nbsp;</a>&nbsp;<c41>These&nbsp;paths&nbsp;have&nbsp;the&nbsp;same&nbsp;form&nbsp;as&nbsp;the&nbsp;`LoanPath`&nbsp;data&nbsp;structure,&nbsp;which
</c41><br/><ln>&nbsp;1044</ln><a id="1044">&nbsp;</a>&nbsp;<c41>in&nbsp;turn&nbsp;is&nbsp;the&nbsp;"real&nbsp;world&nbsp;version&nbsp;of&nbsp;the&nbsp;lvalues&nbsp;`LV`&nbsp;that&nbsp;we
</c41><br/><ln>&nbsp;1045</ln><a id="1045">&nbsp;</a>&nbsp;<c41>introduced&nbsp;earlier.&nbsp;The&nbsp;difference&nbsp;between&nbsp;a&nbsp;`MovePath`&nbsp;and&nbsp;a&nbsp;`LoanPath`
</c41><br/><ln>&nbsp;1046</ln><a id="1046">&nbsp;</a>&nbsp;<c41>is&nbsp;that&nbsp;move&nbsp;paths&nbsp;are:
</c41><br/><ln>&nbsp;1047</ln><a id="1047">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;1048</ln><a id="1048">&nbsp;</a>&nbsp;<c41>1.&nbsp;Canonicalized,&nbsp;so&nbsp;that&nbsp;we&nbsp;have&nbsp;exactly&nbsp;one&nbsp;copy&nbsp;of&nbsp;each,&nbsp;and
</c41><br/><ln>&nbsp;1049</ln><a id="1049">&nbsp;</a>&nbsp;<c41>&nbsp;&nbsp;&nbsp;we&nbsp;can&nbsp;refer&nbsp;to&nbsp;move&nbsp;paths&nbsp;by&nbsp;index;
</c41><br/><ln>&nbsp;1050</ln><a id="1050">&nbsp;</a>&nbsp;<c41>2.&nbsp;Cross-referenced&nbsp;with&nbsp;other&nbsp;paths&nbsp;into&nbsp;a&nbsp;tree,&nbsp;so&nbsp;that&nbsp;given&nbsp;a&nbsp;move
</c41><br/><ln>&nbsp;1051</ln><a id="1051">&nbsp;</a>&nbsp;<c41>&nbsp;&nbsp;&nbsp;path&nbsp;we&nbsp;can&nbsp;efficiently&nbsp;find&nbsp;all&nbsp;parent&nbsp;move&nbsp;paths&nbsp;and&nbsp;all
</c41><br/><ln>&nbsp;1052</ln><a id="1052">&nbsp;</a>&nbsp;<c41>&nbsp;&nbsp;&nbsp;extensions&nbsp;(e.g.,&nbsp;given&nbsp;the&nbsp;`a.b`&nbsp;move&nbsp;path,&nbsp;we&nbsp;can&nbsp;easily&nbsp;find&nbsp;the
</c41><br/><ln>&nbsp;1053</ln><a id="1053">&nbsp;</a>&nbsp;<c41>&nbsp;&nbsp;&nbsp;move&nbsp;path&nbsp;`a`&nbsp;and&nbsp;also&nbsp;the&nbsp;move&nbsp;paths&nbsp;`a.b.c`)
</c41><br/><ln>&nbsp;1054</ln><a id="1054">&nbsp;</a>&nbsp;<c41>3.&nbsp;Cross-referenced&nbsp;with&nbsp;moves&nbsp;and&nbsp;assignments,&nbsp;so&nbsp;that&nbsp;we&nbsp;can
</c41><br/><ln>&nbsp;1055</ln><a id="1055">&nbsp;</a>&nbsp;<c41>&nbsp;&nbsp;&nbsp;easily&nbsp;find&nbsp;all&nbsp;moves&nbsp;and&nbsp;assignments&nbsp;to&nbsp;a&nbsp;given&nbsp;path.
</c41><br/><ln>&nbsp;1056</ln><a id="1056">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;1057</ln><a id="1057">&nbsp;</a>&nbsp;<c41>The&nbsp;mechanism&nbsp;that&nbsp;we&nbsp;use&nbsp;is&nbsp;to&nbsp;create&nbsp;a&nbsp;`MovePath`&nbsp;record&nbsp;for&nbsp;each
</c41><br/><ln>&nbsp;1058</ln><a id="1058">&nbsp;</a>&nbsp;<c41>move&nbsp;path.&nbsp;These&nbsp;are&nbsp;arranged&nbsp;in&nbsp;an&nbsp;array&nbsp;and&nbsp;are&nbsp;referenced&nbsp;using
</c41><br/><ln>&nbsp;1059</ln><a id="1059">&nbsp;</a>&nbsp;<c41>`MovePathIndex`&nbsp;values,&nbsp;which&nbsp;are&nbsp;newtype'd&nbsp;indices.&nbsp;The&nbsp;`MovePath`
</c41><br/><ln>&nbsp;1060</ln><a id="1060">&nbsp;</a>&nbsp;<c41>structs&nbsp;are&nbsp;arranged&nbsp;into&nbsp;a&nbsp;tree,&nbsp;representing&nbsp;using&nbsp;the&nbsp;standard
</c41><br/><ln>&nbsp;1061</ln><a id="1061">&nbsp;</a>&nbsp;<c41>Knuth&nbsp;representation&nbsp;where&nbsp;each&nbsp;node&nbsp;has&nbsp;a&nbsp;child&nbsp;'pointer'&nbsp;and&nbsp;a&nbsp;"next
</c41><br/><ln>&nbsp;1062</ln><a id="1062">&nbsp;</a>&nbsp;<c41>sibling"&nbsp;'pointer'.&nbsp;In&nbsp;addition,&nbsp;each&nbsp;`MovePath`&nbsp;has&nbsp;a&nbsp;parent
</c41><br/><ln>&nbsp;1063</ln><a id="1063">&nbsp;</a>&nbsp;<c41>'pointer'.&nbsp;&nbsp;In&nbsp;this&nbsp;case,&nbsp;the&nbsp;'pointers'&nbsp;are&nbsp;just&nbsp;`MovePathIndex`
</c41><br/><ln>&nbsp;1064</ln><a id="1064">&nbsp;</a>&nbsp;<c41>values.
</c41><br/><ln>&nbsp;1065</ln><a id="1065">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;1066</ln><a id="1066">&nbsp;</a>&nbsp;<c41>In&nbsp;this&nbsp;way,&nbsp;if&nbsp;we&nbsp;want&nbsp;to&nbsp;find&nbsp;all&nbsp;base&nbsp;paths&nbsp;of&nbsp;a&nbsp;given&nbsp;move&nbsp;path,
</c41><br/><ln>&nbsp;1067</ln><a id="1067">&nbsp;</a>&nbsp;<c41>we&nbsp;can&nbsp;just&nbsp;iterate&nbsp;up&nbsp;the&nbsp;parent&nbsp;pointers&nbsp;(see&nbsp;`each_base_path()`&nbsp;in
</c41><br/><ln>&nbsp;1068</ln><a id="1068">&nbsp;</a>&nbsp;<c41>the&nbsp;`move_data`&nbsp;module).&nbsp;If&nbsp;we&nbsp;want&nbsp;to&nbsp;find&nbsp;all&nbsp;extensions,&nbsp;we&nbsp;can
</c41><br/><ln>&nbsp;1069</ln><a id="1069">&nbsp;</a>&nbsp;<c41>iterate&nbsp;through&nbsp;the&nbsp;subtree&nbsp;(see&nbsp;`each_extending_path()`).
</c41><br/><ln>&nbsp;1070</ln><a id="1070">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;1071</ln><a id="1071">&nbsp;</a>&nbsp;<c41>###&nbsp;Moves&nbsp;and&nbsp;assignments
</c41><br/><ln>&nbsp;1072</ln><a id="1072">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;1073</ln><a id="1073">&nbsp;</a>&nbsp;<c41>There&nbsp;are&nbsp;structs&nbsp;to&nbsp;represent&nbsp;moves&nbsp;(`Move`)&nbsp;and&nbsp;assignments
</c41><br/><ln>&nbsp;1074</ln><a id="1074">&nbsp;</a>&nbsp;<c41>(`Assignment`),&nbsp;and&nbsp;these&nbsp;are&nbsp;also&nbsp;placed&nbsp;into&nbsp;arrays&nbsp;and&nbsp;referenced
</c41><br/><ln>&nbsp;1075</ln><a id="1075">&nbsp;</a>&nbsp;<c41>by&nbsp;index.&nbsp;All&nbsp;moves&nbsp;of&nbsp;a&nbsp;particular&nbsp;path&nbsp;are&nbsp;arranged&nbsp;into&nbsp;a&nbsp;linked
</c41><br/><ln>&nbsp;1076</ln><a id="1076">&nbsp;</a>&nbsp;<c41>lists,&nbsp;beginning&nbsp;with&nbsp;`MovePath.first_move`&nbsp;and&nbsp;continuing&nbsp;through
</c41><br/><ln>&nbsp;1077</ln><a id="1077">&nbsp;</a>&nbsp;<c41>`Move.next_move`.
</c41><br/><ln>&nbsp;1078</ln><a id="1078">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;1079</ln><a id="1079">&nbsp;</a>&nbsp;<c41>We&nbsp;distinguish&nbsp;between&nbsp;"var"&nbsp;assignments,&nbsp;which&nbsp;are&nbsp;assignments&nbsp;to&nbsp;a
</c41><br/><ln>&nbsp;1080</ln><a id="1080">&nbsp;</a>&nbsp;<c41>variable&nbsp;like&nbsp;`x&nbsp;=&nbsp;foo`,&nbsp;and&nbsp;"path"&nbsp;assignments&nbsp;(`x.f&nbsp;=&nbsp;foo`).&nbsp;&nbsp;This
</c41><br/><ln>&nbsp;1081</ln><a id="1081">&nbsp;</a>&nbsp;<c41>is&nbsp;because&nbsp;we&nbsp;need&nbsp;to&nbsp;assign&nbsp;dataflows&nbsp;to&nbsp;the&nbsp;former,&nbsp;but&nbsp;not&nbsp;the
</c41><br/><ln>&nbsp;1082</ln><a id="1082">&nbsp;</a>&nbsp;<c41>latter,&nbsp;so&nbsp;as&nbsp;to&nbsp;check&nbsp;for&nbsp;double&nbsp;initialization&nbsp;of&nbsp;immutable
</c41><br/><ln>&nbsp;1083</ln><a id="1083">&nbsp;</a>&nbsp;<c41>variables.
</c41><br/><ln>&nbsp;1084</ln><a id="1084">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;1085</ln><a id="1085">&nbsp;</a>&nbsp;<c41>###&nbsp;Gathering&nbsp;and&nbsp;checking&nbsp;moves
</c41><br/><ln>&nbsp;1086</ln><a id="1086">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;1087</ln><a id="1087">&nbsp;</a>&nbsp;<c41>Like&nbsp;loans,&nbsp;we&nbsp;distinguish&nbsp;two&nbsp;phases.&nbsp;The&nbsp;first,&nbsp;gathering,&nbsp;is&nbsp;where
</c41><br/><ln>&nbsp;1088</ln><a id="1088">&nbsp;</a>&nbsp;<c41>we&nbsp;uncover&nbsp;all&nbsp;the&nbsp;moves&nbsp;and&nbsp;assignments.&nbsp;As&nbsp;with&nbsp;loans,&nbsp;we&nbsp;do&nbsp;some
</c41><br/><ln>&nbsp;1089</ln><a id="1089">&nbsp;</a>&nbsp;<c41>basic&nbsp;sanity&nbsp;checking&nbsp;in&nbsp;this&nbsp;phase,&nbsp;so&nbsp;we'll&nbsp;report&nbsp;errors&nbsp;if&nbsp;you
</c41><br/><ln>&nbsp;1090</ln><a id="1090">&nbsp;</a>&nbsp;<c41>attempt&nbsp;to&nbsp;move&nbsp;out&nbsp;of&nbsp;a&nbsp;borrowed&nbsp;pointer&nbsp;etc.&nbsp;Then&nbsp;we&nbsp;do&nbsp;the&nbsp;dataflow
</c41><br/><ln>&nbsp;1091</ln><a id="1091">&nbsp;</a>&nbsp;<c41>(see&nbsp;`FlowedMoveData::new`).&nbsp;Finally,&nbsp;in&nbsp;the&nbsp;`check_loans.rs`&nbsp;code,&nbsp;we
</c41><br/><ln>&nbsp;1092</ln><a id="1092">&nbsp;</a>&nbsp;<c41>walk&nbsp;back&nbsp;over,&nbsp;identify&nbsp;all&nbsp;uses,&nbsp;assignments,&nbsp;and&nbsp;captures,&nbsp;and
</c41><br/><ln>&nbsp;1093</ln><a id="1093">&nbsp;</a>&nbsp;<c41>check&nbsp;that&nbsp;they&nbsp;are&nbsp;legal&nbsp;given&nbsp;the&nbsp;set&nbsp;of&nbsp;dataflow&nbsp;bits&nbsp;we&nbsp;have
</c41><br/><ln>&nbsp;1094</ln><a id="1094">&nbsp;</a>&nbsp;<c41>computed&nbsp;for&nbsp;that&nbsp;program&nbsp;point.
</c41><br/><ln>&nbsp;1095</ln><a id="1095">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;1096</ln><a id="1096">&nbsp;</a>&nbsp;<c41>#&nbsp;Future&nbsp;work
</c41><br/><ln>&nbsp;1097</ln><a id="1097">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;1098</ln><a id="1098">&nbsp;</a>&nbsp;<c41>While&nbsp;writing&nbsp;up&nbsp;these&nbsp;docs,&nbsp;I&nbsp;encountered&nbsp;some&nbsp;rules&nbsp;I&nbsp;believe&nbsp;to&nbsp;be
</c41><br/><ln>&nbsp;1099</ln><a id="1099">&nbsp;</a>&nbsp;<c41>stricter&nbsp;than&nbsp;necessary:
</c41><br/><ln>&nbsp;1100</ln><a id="1100">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;1101</ln><a id="1101">&nbsp;</a>&nbsp;<c41>-&nbsp;I&nbsp;think&nbsp;restricting&nbsp;the&nbsp;`&amp;mut`&nbsp;LV&nbsp;against&nbsp;moves&nbsp;and&nbsp;`ALIAS`&nbsp;is&nbsp;sufficient,
</c41><br/><ln>&nbsp;1102</ln><a id="1102">&nbsp;</a>&nbsp;<c41>&nbsp;&nbsp;`MUTATE`&nbsp;and&nbsp;`CLAIM`&nbsp;are&nbsp;overkill.&nbsp;`MUTATE`&nbsp;was&nbsp;necessary&nbsp;when&nbsp;swap&nbsp;was
</c41><br/><ln>&nbsp;1103</ln><a id="1103">&nbsp;</a>&nbsp;<c41>&nbsp;&nbsp;a&nbsp;built-in&nbsp;operator,&nbsp;but&nbsp;as&nbsp;it&nbsp;is&nbsp;not,&nbsp;it&nbsp;is&nbsp;implied&nbsp;by&nbsp;`CLAIM`,
</c41><br/><ln>&nbsp;1104</ln><a id="1104">&nbsp;</a>&nbsp;<c41>&nbsp;&nbsp;and&nbsp;`CLAIM`&nbsp;is&nbsp;implied&nbsp;by&nbsp;`ALIAS`.&nbsp;The&nbsp;only&nbsp;net&nbsp;effect&nbsp;of&nbsp;this&nbsp;is&nbsp;an
</c41><br/><ln>&nbsp;1105</ln><a id="1105">&nbsp;</a>&nbsp;<c41>&nbsp;&nbsp;extra&nbsp;error&nbsp;message&nbsp;in&nbsp;some&nbsp;cases,&nbsp;though.
</c41><br/><ln>&nbsp;1106</ln><a id="1106">&nbsp;</a>&nbsp;<c41>-&nbsp;I&nbsp;have&nbsp;not&nbsp;described&nbsp;how&nbsp;closures&nbsp;interact.&nbsp;Current&nbsp;code&nbsp;is&nbsp;unsound.
</c41><br/><ln>&nbsp;1107</ln><a id="1107">&nbsp;</a>&nbsp;<c41>&nbsp;&nbsp;I&nbsp;am&nbsp;working&nbsp;on&nbsp;describing&nbsp;and&nbsp;implementing&nbsp;the&nbsp;fix.
</c41><br/><ln>&nbsp;1108</ln><a id="1108">&nbsp;</a>&nbsp;<c41>-&nbsp;If&nbsp;we&nbsp;wish,&nbsp;we&nbsp;can&nbsp;easily&nbsp;extend&nbsp;the&nbsp;move&nbsp;checking&nbsp;to&nbsp;allow&nbsp;finer-grained
</c41><br/><ln>&nbsp;1109</ln><a id="1109">&nbsp;</a>&nbsp;<c41>&nbsp;&nbsp;tracking&nbsp;of&nbsp;what&nbsp;is&nbsp;initialized&nbsp;and&nbsp;what&nbsp;is&nbsp;not,&nbsp;enabling&nbsp;code&nbsp;like
</c41><br/><ln>&nbsp;1110</ln><a id="1110">&nbsp;</a>&nbsp;<c41>&nbsp;&nbsp;this:
</c41><br/><ln>&nbsp;1111</ln><a id="1111">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;1112</ln><a id="1112">&nbsp;</a>&nbsp;<c41>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a&nbsp;=&nbsp;x.f.g;&nbsp;//&nbsp;x.f.g&nbsp;is&nbsp;now&nbsp;uninitialized
</c41><br/><ln>&nbsp;1113</ln><a id="1113">&nbsp;</a>&nbsp;<c41>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;here,&nbsp;x&nbsp;and&nbsp;x.f&nbsp;are&nbsp;not&nbsp;usable,&nbsp;but&nbsp;x.f.h&nbsp;*is*
</c41><br/><ln>&nbsp;1114</ln><a id="1114">&nbsp;</a>&nbsp;<c41>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x.f.g&nbsp;=&nbsp;b;&nbsp;//&nbsp;x.f.g&nbsp;is&nbsp;not&nbsp;initialized
</c41><br/><ln>&nbsp;1115</ln><a id="1115">&nbsp;</a>&nbsp;<c41>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;now&nbsp;x,&nbsp;x.f,&nbsp;x.f.g,&nbsp;x.f.h&nbsp;are&nbsp;all&nbsp;usable
</c41><br/><ln>&nbsp;1116</ln><a id="1116">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;1117</ln><a id="1117">&nbsp;</a>&nbsp;<c41>&nbsp;&nbsp;What&nbsp;needs&nbsp;to&nbsp;change&nbsp;here,&nbsp;most&nbsp;likely,&nbsp;is&nbsp;that&nbsp;the&nbsp;`moves`&nbsp;module
</c41><br/><ln>&nbsp;1118</ln><a id="1118">&nbsp;</a>&nbsp;<c41>&nbsp;&nbsp;should&nbsp;record&nbsp;not&nbsp;only&nbsp;what&nbsp;paths&nbsp;are&nbsp;moved,&nbsp;but&nbsp;what&nbsp;expressions
</c41><br/><ln>&nbsp;1119</ln><a id="1119">&nbsp;</a>&nbsp;<c41>&nbsp;&nbsp;are&nbsp;actual&nbsp;*uses*.&nbsp;For&nbsp;example,&nbsp;the&nbsp;reference&nbsp;to&nbsp;`x`&nbsp;in&nbsp;`x.f.g&nbsp;=&nbsp;b`
</c41><br/><ln>&nbsp;1120</ln><a id="1120">&nbsp;</a>&nbsp;<c41>&nbsp;&nbsp;is&nbsp;not&nbsp;a&nbsp;true&nbsp;*use*&nbsp;in&nbsp;the&nbsp;sense&nbsp;that&nbsp;it&nbsp;requires&nbsp;`x`&nbsp;to&nbsp;be&nbsp;fully
</c41><br/><ln>&nbsp;1121</ln><a id="1121">&nbsp;</a>&nbsp;<c41>&nbsp;&nbsp;initialized.&nbsp;This&nbsp;is&nbsp;in&nbsp;fact&nbsp;why&nbsp;the&nbsp;above&nbsp;code&nbsp;produces&nbsp;an&nbsp;error
</c41><br/><ln>&nbsp;1122</ln><a id="1122">&nbsp;</a>&nbsp;<c41>&nbsp;&nbsp;today:&nbsp;the&nbsp;reference&nbsp;to&nbsp;`x`&nbsp;in&nbsp;`x.f.g&nbsp;=&nbsp;b`&nbsp;is&nbsp;considered&nbsp;illegal
</c41><br/><ln>&nbsp;1123</ln><a id="1123">&nbsp;</a>&nbsp;<c41>&nbsp;&nbsp;because&nbsp;`x`&nbsp;is&nbsp;not&nbsp;fully&nbsp;initialized.
</c41><br/><ln>&nbsp;1124</ln><a id="1124">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;1125</ln><a id="1125">&nbsp;</a>&nbsp;<c41>There&nbsp;are&nbsp;also&nbsp;some&nbsp;possible&nbsp;refactorings:
</c41><br/><ln>&nbsp;1126</ln><a id="1126">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;1127</ln><a id="1127">&nbsp;</a>&nbsp;<c41>-&nbsp;It&nbsp;might&nbsp;be&nbsp;nice&nbsp;to&nbsp;replace&nbsp;all&nbsp;loan&nbsp;paths&nbsp;with&nbsp;the&nbsp;MovePath&nbsp;mechanism,
</c41><br/><ln>&nbsp;1128</ln><a id="1128">&nbsp;</a>&nbsp;<c41>&nbsp;&nbsp;since&nbsp;they&nbsp;allow&nbsp;lightweight&nbsp;comparison&nbsp;using&nbsp;an&nbsp;integer.
</c41><br/><ln>&nbsp;1129</ln><a id="1129">&nbsp;</a>&nbsp;<c0>
</c0><br/><ln>&nbsp;1130</ln><a id="1130">&nbsp;</a>&nbsp;<c41>*/
</c41><br/><div class="refblock"></div></maintext></div></body>