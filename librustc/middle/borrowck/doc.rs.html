<head><link href="css/shCore.css" rel="stylesheet" type="text/css"/><link href="css/shThemeDefault.css" rel="stylesheet" type="text/css"/></head><style type="text/css">maintext {color:#f0f0f0; font-size:12px; font-family:"Courier New"}
a:link{ color:#f0f0f0; font-style:normal;   text-decoration:none;}
a:visited{ color:#f0f0f0; font-style:normal;   text-decoration:none;}
a:link:hover{ color:#f0f0f0; font-style:normal; background-color:#606060; }
pr{font-weight:bold}
ln{color:#606060; -moz-user-select:-moz-none; -khtml-user-select:none; -webkit-user-select:none; -ms-user-select:none; user-select:none;}
c24{color:#ffffff; font-style:italic; opacity:0.5}
c25{color:#ffffff; opacity:0.92}
c26{color:#ffffff; font-weight:bold; }
c27{color:#b0ffff; font-weight:bold; }
c28{color:#b0ffb0; font-weight:bold; }
c29{color:#d0e0ff; font-weight:bold; }
c30{color:#fff0e0; font-weight:bold; }
c31{color:#d0b0ff; font-weight:bold; }
c32{color:#ffffff; font-style:italic; opacity:0.6}
c1{color:#ffffc0;   font-weight:bold; }
c33{color:#e0a0d0;  }
c2{color:#60f0c0}
c3{color:#50e0ff; }
c4{color:#f090f0}
c5{color:#50ff80; }
c6{color:#f0f0e0}
c7{color:#fff0d0}
c8{color:#e0d0f0}
c9{color:#70f0f0}
c10{color:#f0f070}
c11{color:#c0f070}
c12{color:#70c0f0}
c13{color:#c0f070}
c14{color:#f0ffc0}
c15{color:#f0f0e0}
c16{color:#c0ffe0}
c17{color:#90d0f0}
c18{color:#f0a0d0}
c19{color:#d0f0a0}
c20{color:#0f0ff}
c21{color:#d0d0d0; font-weight:bold}
c22{color:#c0ffd0; }
c23{color:#d0f0ff; }
</style><body style="background-color:#3c3834;"><maintext><br/><a href="./../../../../">&nbsp;&nbsp;&nbsp;&nbsp;./</a><c0><a href="./../../../../src/">src</a><c1>/</c1><c0><a href="./../../../../src/librustc/">librustc</a><c1>/</c1><c0><a href="./../../../../src/librustc/middle/">middle</a><c1>/</c1><c0><a href="./../../../../src/librustc/middle/borrowck/">borrowck</a><c1>/</c1><c0><a href="./../../../../src/librustc/middle/borrowck/doc.rs.html">doc.rs</a><br/><br/><ln>&nbsp;&nbsp;&nbsp;1</ln><a id="1">&nbsp;</a><c24>//&nbsp;Copyright&nbsp;2012&nbsp;The&nbsp;Rust&nbsp;Project&nbsp;Developers.&nbsp;See&nbsp;the&nbsp;COPYRIGHT
</c24><br/><ln>&nbsp;&nbsp;&nbsp;2</ln><a id="2">&nbsp;</a><c24>//&nbsp;file&nbsp;at&nbsp;the&nbsp;top-level&nbsp;directory&nbsp;of&nbsp;this&nbsp;distribution&nbsp;and&nbsp;at
</c24><br/><ln>&nbsp;&nbsp;&nbsp;3</ln><a id="3">&nbsp;</a><c24>//&nbsp;http://rust-lang.org/COPYRIGHT.
</c24><br/><ln>&nbsp;&nbsp;&nbsp;4</ln><a id="4">&nbsp;</a><c24>//
</c24><br/><ln>&nbsp;&nbsp;&nbsp;5</ln><a id="5">&nbsp;</a><c24>//&nbsp;Licensed&nbsp;under&nbsp;the&nbsp;Apache&nbsp;License,&nbsp;Version&nbsp;2.0&nbsp;&lt;LICENSE-APACHE&nbsp;or
</c24><br/><ln>&nbsp;&nbsp;&nbsp;6</ln><a id="6">&nbsp;</a><c24>//&nbsp;http://www.apache.org/licenses/LICENSE-2.0&gt;&nbsp;or&nbsp;the&nbsp;MIT&nbsp;license
</c24><br/><ln>&nbsp;&nbsp;&nbsp;7</ln><a id="7">&nbsp;</a><c24>//&nbsp;&lt;LICENSE-MIT&nbsp;or&nbsp;http://opensource.org/licenses/MIT&gt;,&nbsp;at&nbsp;your
</c24><br/><ln>&nbsp;&nbsp;&nbsp;8</ln><a id="8">&nbsp;</a><c24>//&nbsp;option.&nbsp;This&nbsp;file&nbsp;may&nbsp;not&nbsp;be&nbsp;copied,&nbsp;modified,&nbsp;or&nbsp;distributed
</c24><br/><ln>&nbsp;&nbsp;&nbsp;9</ln><a id="9">&nbsp;</a><c24>//&nbsp;except&nbsp;according&nbsp;to&nbsp;those&nbsp;terms.
</c24><br/><ln>&nbsp;&nbsp;10</ln><a id="10">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;&nbsp;11</ln><a id="11">&nbsp;</a><c24>/*!
</c24><br/><ln>&nbsp;&nbsp;12</ln><a id="12">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;&nbsp;13</ln><a id="13">&nbsp;</a><c24>#&nbsp;The&nbsp;Borrow&nbsp;Checker
</c24><br/><ln>&nbsp;&nbsp;14</ln><a id="14">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;&nbsp;15</ln><a id="15">&nbsp;</a><c24>This&nbsp;pass&nbsp;has&nbsp;the&nbsp;job&nbsp;of&nbsp;enforcing&nbsp;memory&nbsp;safety.&nbsp;This&nbsp;is&nbsp;a&nbsp;subtle
</c24><br/><ln>&nbsp;&nbsp;16</ln><a id="16">&nbsp;</a><c24>topic.&nbsp;This&nbsp;docs&nbsp;aim&nbsp;to&nbsp;explain&nbsp;both&nbsp;the&nbsp;practice&nbsp;and&nbsp;the&nbsp;theory
</c24><br/><ln>&nbsp;&nbsp;17</ln><a id="17">&nbsp;</a><c24>behind&nbsp;the&nbsp;borrow&nbsp;checker.&nbsp;They&nbsp;start&nbsp;with&nbsp;a&nbsp;high-level&nbsp;overview&nbsp;of
</c24><br/><ln>&nbsp;&nbsp;18</ln><a id="18">&nbsp;</a><c24>how&nbsp;it&nbsp;works,&nbsp;and&nbsp;then&nbsp;proceed&nbsp;to&nbsp;dive&nbsp;into&nbsp;the&nbsp;theoretical
</c24><br/><ln>&nbsp;&nbsp;19</ln><a id="19">&nbsp;</a><c24>background.&nbsp;Finally,&nbsp;they&nbsp;go&nbsp;into&nbsp;detail&nbsp;on&nbsp;some&nbsp;of&nbsp;the&nbsp;more&nbsp;subtle
</c24><br/><ln>&nbsp;&nbsp;20</ln><a id="20">&nbsp;</a><c24>aspects.
</c24><br/><ln>&nbsp;&nbsp;21</ln><a id="21">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;&nbsp;22</ln><a id="22">&nbsp;</a><c24>#&nbsp;Table&nbsp;of&nbsp;contents
</c24><br/><ln>&nbsp;&nbsp;23</ln><a id="23">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;&nbsp;24</ln><a id="24">&nbsp;</a><c24>These&nbsp;docs&nbsp;are&nbsp;long.&nbsp;Search&nbsp;for&nbsp;the&nbsp;section&nbsp;you&nbsp;are&nbsp;interested&nbsp;in.
</c24><br/><ln>&nbsp;&nbsp;25</ln><a id="25">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;&nbsp;26</ln><a id="26">&nbsp;</a><c24>-&nbsp;Overview
</c24><br/><ln>&nbsp;&nbsp;27</ln><a id="27">&nbsp;</a><c24>-&nbsp;Formal&nbsp;model
</c24><br/><ln>&nbsp;&nbsp;28</ln><a id="28">&nbsp;</a><c24>-&nbsp;Borrowing&nbsp;and&nbsp;loans
</c24><br/><ln>&nbsp;&nbsp;29</ln><a id="29">&nbsp;</a><c24>-&nbsp;Moves&nbsp;and&nbsp;initialization
</c24><br/><ln>&nbsp;&nbsp;30</ln><a id="30">&nbsp;</a><c24>-&nbsp;Future&nbsp;work
</c24><br/><ln>&nbsp;&nbsp;31</ln><a id="31">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;&nbsp;32</ln><a id="32">&nbsp;</a><c24>#&nbsp;Overview
</c24><br/><ln>&nbsp;&nbsp;33</ln><a id="33">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;&nbsp;34</ln><a id="34">&nbsp;</a><c24>The&nbsp;borrow&nbsp;checker&nbsp;checks&nbsp;one&nbsp;function&nbsp;at&nbsp;a&nbsp;time.&nbsp;It&nbsp;operates&nbsp;in&nbsp;two
</c24><br/><ln>&nbsp;&nbsp;35</ln><a id="35">&nbsp;</a><c24>passes.&nbsp;The&nbsp;first&nbsp;pass,&nbsp;called&nbsp;`gather_loans`,&nbsp;walks&nbsp;over&nbsp;the&nbsp;function
</c24><br/><ln>&nbsp;&nbsp;36</ln><a id="36">&nbsp;</a><c24>and&nbsp;identifies&nbsp;all&nbsp;of&nbsp;the&nbsp;places&nbsp;where&nbsp;borrows&nbsp;(e.g.,&nbsp;`&amp;`&nbsp;expressions
</c24><br/><ln>&nbsp;&nbsp;37</ln><a id="37">&nbsp;</a><c24>and&nbsp;`ref`&nbsp;bindings)&nbsp;and&nbsp;moves&nbsp;(copies&nbsp;or&nbsp;captures&nbsp;of&nbsp;a&nbsp;linear&nbsp;value)
</c24><br/><ln>&nbsp;&nbsp;38</ln><a id="38">&nbsp;</a><c24>occur.&nbsp;It&nbsp;also&nbsp;tracks&nbsp;initialization&nbsp;sites.&nbsp;For&nbsp;each&nbsp;borrow&nbsp;and&nbsp;move,
</c24><br/><ln>&nbsp;&nbsp;39</ln><a id="39">&nbsp;</a><c24>it&nbsp;checks&nbsp;various&nbsp;basic&nbsp;safety&nbsp;conditions&nbsp;at&nbsp;this&nbsp;time&nbsp;(for&nbsp;example,
</c24><br/><ln>&nbsp;&nbsp;40</ln><a id="40">&nbsp;</a><c24>that&nbsp;the&nbsp;lifetime&nbsp;of&nbsp;the&nbsp;borrow&nbsp;doesn't&nbsp;exceed&nbsp;the&nbsp;lifetime&nbsp;of&nbsp;the
</c24><br/><ln>&nbsp;&nbsp;41</ln><a id="41">&nbsp;</a><c24>value&nbsp;being&nbsp;borrowed,&nbsp;or&nbsp;that&nbsp;there&nbsp;is&nbsp;no&nbsp;move&nbsp;out&nbsp;of&nbsp;an&nbsp;`&amp;T`
</c24><br/><ln>&nbsp;&nbsp;42</ln><a id="42">&nbsp;</a><c24>pointee).
</c24><br/><ln>&nbsp;&nbsp;43</ln><a id="43">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;&nbsp;44</ln><a id="44">&nbsp;</a><c24>It&nbsp;then&nbsp;uses&nbsp;the&nbsp;dataflow&nbsp;module&nbsp;to&nbsp;propagate&nbsp;which&nbsp;of&nbsp;those&nbsp;borrows
</c24><br/><ln>&nbsp;&nbsp;45</ln><a id="45">&nbsp;</a><c24>may&nbsp;be&nbsp;in&nbsp;scope&nbsp;at&nbsp;each&nbsp;point&nbsp;in&nbsp;the&nbsp;procedure.&nbsp;A&nbsp;loan&nbsp;is&nbsp;considered
</c24><br/><ln>&nbsp;&nbsp;46</ln><a id="46">&nbsp;</a><c24>to&nbsp;come&nbsp;into&nbsp;scope&nbsp;at&nbsp;the&nbsp;expression&nbsp;that&nbsp;caused&nbsp;it&nbsp;and&nbsp;to&nbsp;go&nbsp;out&nbsp;of
</c24><br/><ln>&nbsp;&nbsp;47</ln><a id="47">&nbsp;</a><c24>scope&nbsp;when&nbsp;the&nbsp;lifetime&nbsp;of&nbsp;the&nbsp;resulting&nbsp;borrowed&nbsp;pointer&nbsp;expires.
</c24><br/><ln>&nbsp;&nbsp;48</ln><a id="48">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;&nbsp;49</ln><a id="49">&nbsp;</a><c24>Once&nbsp;the&nbsp;in-scope&nbsp;loans&nbsp;are&nbsp;known&nbsp;for&nbsp;each&nbsp;point&nbsp;in&nbsp;the&nbsp;program,&nbsp;the
</c24><br/><ln>&nbsp;&nbsp;50</ln><a id="50">&nbsp;</a><c24>borrow&nbsp;checker&nbsp;walks&nbsp;the&nbsp;IR&nbsp;again&nbsp;in&nbsp;a&nbsp;second&nbsp;pass&nbsp;called
</c24><br/><ln>&nbsp;&nbsp;51</ln><a id="51">&nbsp;</a><c24>`check_loans`.&nbsp;This&nbsp;pass&nbsp;examines&nbsp;each&nbsp;statement&nbsp;and&nbsp;makes&nbsp;sure&nbsp;that
</c24><br/><ln>&nbsp;&nbsp;52</ln><a id="52">&nbsp;</a><c24>it&nbsp;is&nbsp;safe&nbsp;with&nbsp;respect&nbsp;to&nbsp;the&nbsp;in-scope&nbsp;loans.
</c24><br/><ln>&nbsp;&nbsp;53</ln><a id="53">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;&nbsp;54</ln><a id="54">&nbsp;</a><c24>#&nbsp;Formal&nbsp;model
</c24><br/><ln>&nbsp;&nbsp;55</ln><a id="55">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;&nbsp;56</ln><a id="56">&nbsp;</a><c24>Throughout&nbsp;the&nbsp;docs&nbsp;we'll&nbsp;consider&nbsp;a&nbsp;simple&nbsp;subset&nbsp;of&nbsp;Rust&nbsp;in&nbsp;which
</c24><br/><ln>&nbsp;&nbsp;57</ln><a id="57">&nbsp;</a><c24>you&nbsp;can&nbsp;only&nbsp;borrow&nbsp;from&nbsp;lvalues,&nbsp;defined&nbsp;like&nbsp;so:
</c24><br/><ln>&nbsp;&nbsp;58</ln><a id="58">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;&nbsp;59</ln><a id="59">&nbsp;</a><c24>&nbsp;&nbsp;&nbsp;&nbsp;LV&nbsp;=&nbsp;x&nbsp;|&nbsp;LV.f&nbsp;|&nbsp;*LV
</c24><br/><ln>&nbsp;&nbsp;60</ln><a id="60">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;&nbsp;61</ln><a id="61">&nbsp;</a><c24>Here&nbsp;`x`&nbsp;represents&nbsp;some&nbsp;variable,&nbsp;`LV.f`&nbsp;is&nbsp;a&nbsp;field&nbsp;reference,
</c24><br/><ln>&nbsp;&nbsp;62</ln><a id="62">&nbsp;</a><c24>and&nbsp;`*LV`&nbsp;is&nbsp;a&nbsp;pointer&nbsp;dereference.&nbsp;There&nbsp;is&nbsp;no&nbsp;auto-deref&nbsp;or&nbsp;other
</c24><br/><ln>&nbsp;&nbsp;63</ln><a id="63">&nbsp;</a><c24>niceties.&nbsp;This&nbsp;means&nbsp;that&nbsp;if&nbsp;you&nbsp;have&nbsp;a&nbsp;type&nbsp;like:
</c24><br/><ln>&nbsp;&nbsp;64</ln><a id="64">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;&nbsp;65</ln><a id="65">&nbsp;</a><c24>&nbsp;&nbsp;&nbsp;&nbsp;struct&nbsp;S&nbsp;{&nbsp;f:&nbsp;uint&nbsp;}
</c24><br/><ln>&nbsp;&nbsp;66</ln><a id="66">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;&nbsp;67</ln><a id="67">&nbsp;</a><c24>and&nbsp;a&nbsp;variable&nbsp;`a:&nbsp;~S`,&nbsp;then&nbsp;the&nbsp;rust&nbsp;expression&nbsp;`a.f`&nbsp;would&nbsp;correspond
</c24><br/><ln>&nbsp;&nbsp;68</ln><a id="68">&nbsp;</a><c24>to&nbsp;an&nbsp;`LV`&nbsp;of&nbsp;`(*a).f`.
</c24><br/><ln>&nbsp;&nbsp;69</ln><a id="69">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;&nbsp;70</ln><a id="70">&nbsp;</a><c24>Here&nbsp;is&nbsp;the&nbsp;formal&nbsp;grammar&nbsp;for&nbsp;the&nbsp;types&nbsp;we'll&nbsp;consider:
</c24><br/><ln>&nbsp;&nbsp;71</ln><a id="71">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;&nbsp;72</ln><a id="72">&nbsp;</a><c24>&nbsp;&nbsp;&nbsp;&nbsp;TY&nbsp;=&nbsp;()&nbsp;|&nbsp;S&lt;'LT...&gt;&nbsp;|&nbsp;~TY&nbsp;|&nbsp;&amp;&nbsp;'LT&nbsp;MQ&nbsp;TY&nbsp;|&nbsp;@&nbsp;MQ&nbsp;TY
</c24><br/><ln>&nbsp;&nbsp;73</ln><a id="73">&nbsp;</a><c24>&nbsp;&nbsp;&nbsp;&nbsp;MQ&nbsp;=&nbsp;mut&nbsp;|&nbsp;imm&nbsp;|&nbsp;const
</c24><br/><ln>&nbsp;&nbsp;74</ln><a id="74">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;&nbsp;75</ln><a id="75">&nbsp;</a><c24>Most&nbsp;of&nbsp;these&nbsp;types&nbsp;should&nbsp;be&nbsp;pretty&nbsp;self&nbsp;explanatory.&nbsp;Here&nbsp;`S`&nbsp;is&nbsp;a
</c24><br/><ln>&nbsp;&nbsp;76</ln><a id="76">&nbsp;</a><c24>struct&nbsp;name&nbsp;and&nbsp;we&nbsp;assume&nbsp;structs&nbsp;are&nbsp;declared&nbsp;like&nbsp;so:
</c24><br/><ln>&nbsp;&nbsp;77</ln><a id="77">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;&nbsp;78</ln><a id="78">&nbsp;</a><c24>&nbsp;&nbsp;&nbsp;&nbsp;SD&nbsp;=&nbsp;struct&nbsp;S&lt;'LT...&gt;&nbsp;{&nbsp;(f:&nbsp;TY)...&nbsp;}
</c24><br/><ln>&nbsp;&nbsp;79</ln><a id="79">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;&nbsp;80</ln><a id="80">&nbsp;</a><c24>#&nbsp;Borrowing&nbsp;and&nbsp;loans
</c24><br/><ln>&nbsp;&nbsp;81</ln><a id="81">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;&nbsp;82</ln><a id="82">&nbsp;</a><c24>##&nbsp;An&nbsp;intuitive&nbsp;explanation
</c24><br/><ln>&nbsp;&nbsp;83</ln><a id="83">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;&nbsp;84</ln><a id="84">&nbsp;</a><c24>###&nbsp;Issuing&nbsp;loans
</c24><br/><ln>&nbsp;&nbsp;85</ln><a id="85">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;&nbsp;86</ln><a id="86">&nbsp;</a><c24>Now,&nbsp;imagine&nbsp;we&nbsp;had&nbsp;a&nbsp;program&nbsp;like&nbsp;this:
</c24><br/><ln>&nbsp;&nbsp;87</ln><a id="87">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;&nbsp;88</ln><a id="88">&nbsp;</a><c24>&nbsp;&nbsp;&nbsp;&nbsp;struct&nbsp;Foo&nbsp;{&nbsp;f:&nbsp;uint,&nbsp;g:&nbsp;uint&nbsp;}
</c24><br/><ln>&nbsp;&nbsp;89</ln><a id="89">&nbsp;</a><c24>&nbsp;&nbsp;&nbsp;&nbsp;...
</c24><br/><ln>&nbsp;&nbsp;90</ln><a id="90">&nbsp;</a><c24>&nbsp;&nbsp;&nbsp;&nbsp;'a:&nbsp;{
</c24><br/><ln>&nbsp;&nbsp;91</ln><a id="91">&nbsp;</a><c24>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;mut&nbsp;x:&nbsp;~Foo&nbsp;=&nbsp;...;
</c24><br/><ln>&nbsp;&nbsp;92</ln><a id="92">&nbsp;</a><c24>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;y&nbsp;=&nbsp;&amp;mut&nbsp;(*x).f;
</c24><br/><ln>&nbsp;&nbsp;93</ln><a id="93">&nbsp;</a><c24>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;=&nbsp;...;
</c24><br/><ln>&nbsp;&nbsp;94</ln><a id="94">&nbsp;</a><c24>&nbsp;&nbsp;&nbsp;&nbsp;}
</c24><br/><ln>&nbsp;&nbsp;95</ln><a id="95">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;&nbsp;96</ln><a id="96">&nbsp;</a><c24>This&nbsp;is&nbsp;of&nbsp;course&nbsp;dangerous&nbsp;because&nbsp;mutating&nbsp;`x`&nbsp;will&nbsp;free&nbsp;the&nbsp;old
</c24><br/><ln>&nbsp;&nbsp;97</ln><a id="97">&nbsp;</a><c24>value&nbsp;and&nbsp;hence&nbsp;invalidate&nbsp;`y`.&nbsp;The&nbsp;borrow&nbsp;checker&nbsp;aims&nbsp;to&nbsp;prevent
</c24><br/><ln>&nbsp;&nbsp;98</ln><a id="98">&nbsp;</a><c24>this&nbsp;sort&nbsp;of&nbsp;thing.
</c24><br/><ln>&nbsp;&nbsp;99</ln><a id="99">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;100</ln><a id="100">&nbsp;</a><c24>####&nbsp;Loans&nbsp;and&nbsp;restrictions
</c24><br/><ln>&nbsp;101</ln><a id="101">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;102</ln><a id="102">&nbsp;</a><c24>The&nbsp;way&nbsp;the&nbsp;borrow&nbsp;checker&nbsp;works&nbsp;is&nbsp;that&nbsp;it&nbsp;analyzes&nbsp;each&nbsp;borrow
</c24><br/><ln>&nbsp;103</ln><a id="103">&nbsp;</a><c24>expression&nbsp;(in&nbsp;our&nbsp;simple&nbsp;model,&nbsp;that's&nbsp;stuff&nbsp;like&nbsp;`&amp;LV`,&nbsp;though&nbsp;in
</c24><br/><ln>&nbsp;104</ln><a id="104">&nbsp;</a><c24>real&nbsp;life&nbsp;there&nbsp;are&nbsp;a&nbsp;few&nbsp;other&nbsp;cases&nbsp;to&nbsp;consider).&nbsp;For&nbsp;each&nbsp;borrow
</c24><br/><ln>&nbsp;105</ln><a id="105">&nbsp;</a><c24>expression,&nbsp;it&nbsp;computes&nbsp;a&nbsp;`Loan`,&nbsp;which&nbsp;is&nbsp;a&nbsp;data&nbsp;structure&nbsp;that
</c24><br/><ln>&nbsp;106</ln><a id="106">&nbsp;</a><c24>records&nbsp;(1)&nbsp;the&nbsp;value&nbsp;being&nbsp;borrowed,&nbsp;(2)&nbsp;the&nbsp;mutability&nbsp;and&nbsp;scope&nbsp;of
</c24><br/><ln>&nbsp;107</ln><a id="107">&nbsp;</a><c24>the&nbsp;borrow,&nbsp;and&nbsp;(3)&nbsp;a&nbsp;set&nbsp;of&nbsp;restrictions.&nbsp;In&nbsp;the&nbsp;code,&nbsp;`Loan`&nbsp;is&nbsp;a
</c24><br/><ln>&nbsp;108</ln><a id="108">&nbsp;</a><c24>struct&nbsp;defined&nbsp;in&nbsp;`middle::borrowck`.&nbsp;Formally,&nbsp;we&nbsp;define&nbsp;`LOAN`&nbsp;as
</c24><br/><ln>&nbsp;109</ln><a id="109">&nbsp;</a><c24>follows:
</c24><br/><ln>&nbsp;110</ln><a id="110">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;111</ln><a id="111">&nbsp;</a><c24>&nbsp;&nbsp;&nbsp;&nbsp;LOAN&nbsp;=&nbsp;(LV,&nbsp;LT,&nbsp;MQ,&nbsp;RESTRICTION*)
</c24><br/><ln>&nbsp;112</ln><a id="112">&nbsp;</a><c24>&nbsp;&nbsp;&nbsp;&nbsp;RESTRICTION&nbsp;=&nbsp;(LV,&nbsp;ACTION*)
</c24><br/><ln>&nbsp;113</ln><a id="113">&nbsp;</a><c24>&nbsp;&nbsp;&nbsp;&nbsp;ACTION&nbsp;=&nbsp;MUTATE&nbsp;|&nbsp;CLAIM&nbsp;|&nbsp;FREEZE&nbsp;|&nbsp;ALIAS
</c24><br/><ln>&nbsp;114</ln><a id="114">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;115</ln><a id="115">&nbsp;</a><c24>Here&nbsp;the&nbsp;`LOAN`&nbsp;tuple&nbsp;defines&nbsp;the&nbsp;lvalue&nbsp;`LV`&nbsp;being&nbsp;borrowed;&nbsp;the
</c24><br/><ln>&nbsp;116</ln><a id="116">&nbsp;</a><c24>lifetime&nbsp;`LT`&nbsp;of&nbsp;that&nbsp;borrow;&nbsp;the&nbsp;mutability&nbsp;`MQ`&nbsp;of&nbsp;the&nbsp;borrow;&nbsp;and&nbsp;a
</c24><br/><ln>&nbsp;117</ln><a id="117">&nbsp;</a><c24>list&nbsp;of&nbsp;restrictions.&nbsp;The&nbsp;restrictions&nbsp;indicate&nbsp;actions&nbsp;which,&nbsp;if
</c24><br/><ln>&nbsp;118</ln><a id="118">&nbsp;</a><c24>taken,&nbsp;could&nbsp;invalidate&nbsp;the&nbsp;loan&nbsp;and&nbsp;lead&nbsp;to&nbsp;type&nbsp;safety&nbsp;violations.
</c24><br/><ln>&nbsp;119</ln><a id="119">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;120</ln><a id="120">&nbsp;</a><c24>Each&nbsp;`RESTRICTION`&nbsp;is&nbsp;a&nbsp;pair&nbsp;of&nbsp;a&nbsp;restrictive&nbsp;lvalue&nbsp;`LV`&nbsp;(which&nbsp;will
</c24><br/><ln>&nbsp;121</ln><a id="121">&nbsp;</a><c24>either&nbsp;be&nbsp;the&nbsp;path&nbsp;that&nbsp;was&nbsp;borrowed&nbsp;or&nbsp;some&nbsp;prefix&nbsp;of&nbsp;the&nbsp;path&nbsp;that
</c24><br/><ln>&nbsp;122</ln><a id="122">&nbsp;</a><c24>was&nbsp;borrowed)&nbsp;and&nbsp;a&nbsp;set&nbsp;of&nbsp;restricted&nbsp;actions.&nbsp;&nbsp;There&nbsp;are&nbsp;three&nbsp;kinds
</c24><br/><ln>&nbsp;123</ln><a id="123">&nbsp;</a><c24>of&nbsp;actions&nbsp;that&nbsp;may&nbsp;be&nbsp;restricted&nbsp;for&nbsp;the&nbsp;path&nbsp;`LV`:
</c24><br/><ln>&nbsp;124</ln><a id="124">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;125</ln><a id="125">&nbsp;</a><c24>-&nbsp;`MUTATE`&nbsp;means&nbsp;that&nbsp;`LV`&nbsp;cannot&nbsp;be&nbsp;assigned&nbsp;to;
</c24><br/><ln>&nbsp;126</ln><a id="126">&nbsp;</a><c24>-&nbsp;`CLAIM`&nbsp;means&nbsp;that&nbsp;the&nbsp;`LV`&nbsp;cannot&nbsp;be&nbsp;borrowed&nbsp;mutably;
</c24><br/><ln>&nbsp;127</ln><a id="127">&nbsp;</a><c24>-&nbsp;`FREEZE`&nbsp;means&nbsp;that&nbsp;the&nbsp;`LV`&nbsp;cannot&nbsp;be&nbsp;borrowed&nbsp;immutably;
</c24><br/><ln>&nbsp;128</ln><a id="128">&nbsp;</a><c24>-&nbsp;`ALIAS`&nbsp;means&nbsp;that&nbsp;`LV`&nbsp;cannot&nbsp;be&nbsp;aliased&nbsp;in&nbsp;any&nbsp;way&nbsp;(not&nbsp;even&nbsp;`&amp;const`).
</c24><br/><ln>&nbsp;129</ln><a id="129">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;130</ln><a id="130">&nbsp;</a><c24>Finally,&nbsp;it&nbsp;is&nbsp;never&nbsp;possible&nbsp;to&nbsp;move&nbsp;from&nbsp;an&nbsp;lvalue&nbsp;that&nbsp;appears&nbsp;in&nbsp;a
</c24><br/><ln>&nbsp;131</ln><a id="131">&nbsp;</a><c24>restriction.&nbsp;This&nbsp;implies&nbsp;that&nbsp;the&nbsp;"empty&nbsp;restriction"&nbsp;`(LV,&nbsp;[])`,
</c24><br/><ln>&nbsp;132</ln><a id="132">&nbsp;</a><c24>which&nbsp;contains&nbsp;an&nbsp;empty&nbsp;set&nbsp;of&nbsp;actions,&nbsp;still&nbsp;has&nbsp;a&nbsp;purpose---it
</c24><br/><ln>&nbsp;133</ln><a id="133">&nbsp;</a><c24>prevents&nbsp;moves&nbsp;from&nbsp;`LV`.&nbsp;I&nbsp;chose&nbsp;not&nbsp;to&nbsp;make&nbsp;`MOVE`&nbsp;a&nbsp;fourth&nbsp;kind&nbsp;of
</c24><br/><ln>&nbsp;134</ln><a id="134">&nbsp;</a><c24>action&nbsp;because&nbsp;that&nbsp;would&nbsp;imply&nbsp;that&nbsp;sometimes&nbsp;moves&nbsp;are&nbsp;permitted
</c24><br/><ln>&nbsp;135</ln><a id="135">&nbsp;</a><c24>from&nbsp;restrictived&nbsp;values,&nbsp;which&nbsp;is&nbsp;not&nbsp;the&nbsp;case.
</c24><br/><ln>&nbsp;136</ln><a id="136">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;137</ln><a id="137">&nbsp;</a><c24>####&nbsp;Example
</c24><br/><ln>&nbsp;138</ln><a id="138">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;139</ln><a id="139">&nbsp;</a><c24>To&nbsp;give&nbsp;you&nbsp;a&nbsp;better&nbsp;feeling&nbsp;for&nbsp;what&nbsp;kind&nbsp;of&nbsp;restrictions&nbsp;derived
</c24><br/><ln>&nbsp;140</ln><a id="140">&nbsp;</a><c24>from&nbsp;a&nbsp;loan,&nbsp;let's&nbsp;look&nbsp;at&nbsp;the&nbsp;loan&nbsp;`L`&nbsp;that&nbsp;would&nbsp;be&nbsp;issued&nbsp;as&nbsp;a
</c24><br/><ln>&nbsp;141</ln><a id="141">&nbsp;</a><c24>result&nbsp;of&nbsp;the&nbsp;borrow&nbsp;`&amp;mut&nbsp;(*x).f`&nbsp;in&nbsp;the&nbsp;example&nbsp;above:
</c24><br/><ln>&nbsp;142</ln><a id="142">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;143</ln><a id="143">&nbsp;</a><c24>&nbsp;&nbsp;&nbsp;&nbsp;L&nbsp;=&nbsp;((*x).f,&nbsp;'a,&nbsp;mut,&nbsp;RS)&nbsp;where
</c24><br/><ln>&nbsp;144</ln><a id="144">&nbsp;</a><c24>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RS&nbsp;=&nbsp;[((*x).f,&nbsp;[MUTATE,&nbsp;CLAIM,&nbsp;FREEZE]),
</c24><br/><ln>&nbsp;145</ln><a id="145">&nbsp;</a><c24>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*x,&nbsp;[MUTATE,&nbsp;CLAIM,&nbsp;FREEZE]),
</c24><br/><ln>&nbsp;146</ln><a id="146">&nbsp;</a><c24>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(x,&nbsp;[MUTATE,&nbsp;CLAIM,&nbsp;FREEZE])]
</c24><br/><ln>&nbsp;147</ln><a id="147">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;148</ln><a id="148">&nbsp;</a><c24>The&nbsp;loan&nbsp;states&nbsp;that&nbsp;the&nbsp;expression&nbsp;`(*x).f`&nbsp;has&nbsp;been&nbsp;loaned&nbsp;as
</c24><br/><ln>&nbsp;149</ln><a id="149">&nbsp;</a><c24>mutable&nbsp;for&nbsp;the&nbsp;lifetime&nbsp;`'a`.&nbsp;Because&nbsp;the&nbsp;loan&nbsp;is&nbsp;mutable,&nbsp;that&nbsp;means
</c24><br/><ln>&nbsp;150</ln><a id="150">&nbsp;</a><c24>that&nbsp;the&nbsp;value&nbsp;`(*x).f`&nbsp;may&nbsp;be&nbsp;mutated&nbsp;via&nbsp;the&nbsp;newly&nbsp;created&nbsp;borrowed
</c24><br/><ln>&nbsp;151</ln><a id="151">&nbsp;</a><c24>pointer&nbsp;(and&nbsp;*only*&nbsp;via&nbsp;that&nbsp;pointer).&nbsp;This&nbsp;is&nbsp;reflected&nbsp;in&nbsp;the
</c24><br/><ln>&nbsp;152</ln><a id="152">&nbsp;</a><c24>restrictions&nbsp;`RS`&nbsp;that&nbsp;accompany&nbsp;the&nbsp;loan.
</c24><br/><ln>&nbsp;153</ln><a id="153">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;154</ln><a id="154">&nbsp;</a><c24>The&nbsp;first&nbsp;restriction&nbsp;`((*x).f,&nbsp;[MUTATE,&nbsp;CLAIM,&nbsp;FREEZE])`&nbsp;states&nbsp;that
</c24><br/><ln>&nbsp;155</ln><a id="155">&nbsp;</a><c24>the&nbsp;lender&nbsp;may&nbsp;not&nbsp;mutate&nbsp;nor&nbsp;freeze&nbsp;`(*x).f`.&nbsp;Mutation&nbsp;is&nbsp;illegal
</c24><br/><ln>&nbsp;156</ln><a id="156">&nbsp;</a><c24>because&nbsp;`(*x).f`&nbsp;is&nbsp;only&nbsp;supposed&nbsp;to&nbsp;be&nbsp;mutated&nbsp;via&nbsp;the&nbsp;new&nbsp;borrowed
</c24><br/><ln>&nbsp;157</ln><a id="157">&nbsp;</a><c24>pointer,&nbsp;not&nbsp;by&nbsp;mutating&nbsp;the&nbsp;original&nbsp;path&nbsp;`(*x).f`.&nbsp;Freezing&nbsp;is
</c24><br/><ln>&nbsp;158</ln><a id="158">&nbsp;</a><c24>illegal&nbsp;because&nbsp;the&nbsp;path&nbsp;now&nbsp;has&nbsp;an&nbsp;`&amp;mut`&nbsp;alias;&nbsp;so&nbsp;even&nbsp;if&nbsp;we&nbsp;the
</c24><br/><ln>&nbsp;159</ln><a id="159">&nbsp;</a><c24>lender&nbsp;were&nbsp;to&nbsp;consider&nbsp;`(*x).f`&nbsp;to&nbsp;be&nbsp;immutable,&nbsp;it&nbsp;might&nbsp;be&nbsp;mutated
</c24><br/><ln>&nbsp;160</ln><a id="160">&nbsp;</a><c24>via&nbsp;this&nbsp;alias.&nbsp;Both&nbsp;of&nbsp;these&nbsp;restrictions&nbsp;are&nbsp;temporary.&nbsp;They&nbsp;will&nbsp;be
</c24><br/><ln>&nbsp;161</ln><a id="161">&nbsp;</a><c24>enforced&nbsp;for&nbsp;the&nbsp;lifetime&nbsp;`'a`&nbsp;of&nbsp;the&nbsp;loan.&nbsp;After&nbsp;the&nbsp;loan&nbsp;expires,
</c24><br/><ln>&nbsp;162</ln><a id="162">&nbsp;</a><c24>the&nbsp;restrictions&nbsp;no&nbsp;longer&nbsp;apply.
</c24><br/><ln>&nbsp;163</ln><a id="163">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;164</ln><a id="164">&nbsp;</a><c24>The&nbsp;second&nbsp;restriction&nbsp;on&nbsp;`*x`&nbsp;is&nbsp;interesting&nbsp;because&nbsp;it&nbsp;does&nbsp;not
</c24><br/><ln>&nbsp;165</ln><a id="165">&nbsp;</a><c24>apply&nbsp;to&nbsp;the&nbsp;path&nbsp;that&nbsp;was&nbsp;lent&nbsp;(`(*x).f`)&nbsp;but&nbsp;rather&nbsp;to&nbsp;a&nbsp;prefix&nbsp;of
</c24><br/><ln>&nbsp;166</ln><a id="166">&nbsp;</a><c24>the&nbsp;borrowed&nbsp;path.&nbsp;This&nbsp;is&nbsp;due&nbsp;to&nbsp;the&nbsp;rules&nbsp;of&nbsp;inherited&nbsp;mutability:
</c24><br/><ln>&nbsp;167</ln><a id="167">&nbsp;</a><c24>if&nbsp;the&nbsp;user&nbsp;were&nbsp;to&nbsp;assign&nbsp;to&nbsp;(or&nbsp;freeze)&nbsp;`*x`,&nbsp;they&nbsp;would&nbsp;indirectly
</c24><br/><ln>&nbsp;168</ln><a id="168">&nbsp;</a><c24>overwrite&nbsp;(or&nbsp;freeze)&nbsp;`(*x).f`,&nbsp;and&nbsp;thus&nbsp;invalidate&nbsp;the&nbsp;borrowed
</c24><br/><ln>&nbsp;169</ln><a id="169">&nbsp;</a><c24>pointer&nbsp;that&nbsp;was&nbsp;created.&nbsp;In&nbsp;general&nbsp;it&nbsp;holds&nbsp;that&nbsp;when&nbsp;a&nbsp;path&nbsp;is
</c24><br/><ln>&nbsp;170</ln><a id="170">&nbsp;</a><c24>lent,&nbsp;restrictions&nbsp;are&nbsp;issued&nbsp;for&nbsp;all&nbsp;the&nbsp;owning&nbsp;prefixes&nbsp;of&nbsp;that
</c24><br/><ln>&nbsp;171</ln><a id="171">&nbsp;</a><c24>path.&nbsp;In&nbsp;this&nbsp;case,&nbsp;the&nbsp;path&nbsp;`*x`&nbsp;owns&nbsp;the&nbsp;path&nbsp;`(*x).f`&nbsp;and,
</c24><br/><ln>&nbsp;172</ln><a id="172">&nbsp;</a><c24>because&nbsp;`x`&nbsp;is&nbsp;an&nbsp;owned&nbsp;pointer,&nbsp;the&nbsp;path&nbsp;`x`&nbsp;owns&nbsp;the&nbsp;path&nbsp;`*x`.
</c24><br/><ln>&nbsp;173</ln><a id="173">&nbsp;</a><c24>Therefore,&nbsp;borrowing&nbsp;`(*x).f`&nbsp;yields&nbsp;restrictions&nbsp;on&nbsp;both
</c24><br/><ln>&nbsp;174</ln><a id="174">&nbsp;</a><c24>`*x`&nbsp;and&nbsp;`x`.
</c24><br/><ln>&nbsp;175</ln><a id="175">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;176</ln><a id="176">&nbsp;</a><c24>###&nbsp;Checking&nbsp;for&nbsp;illegal&nbsp;assignments,&nbsp;moves,&nbsp;and&nbsp;reborrows
</c24><br/><ln>&nbsp;177</ln><a id="177">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;178</ln><a id="178">&nbsp;</a><c24>Once&nbsp;we&nbsp;have&nbsp;computed&nbsp;the&nbsp;loans&nbsp;introduced&nbsp;by&nbsp;each&nbsp;borrow,&nbsp;the&nbsp;borrow
</c24><br/><ln>&nbsp;179</ln><a id="179">&nbsp;</a><c24>checker&nbsp;uses&nbsp;a&nbsp;data&nbsp;flow&nbsp;propagation&nbsp;to&nbsp;compute&nbsp;the&nbsp;full&nbsp;set&nbsp;of&nbsp;loans
</c24><br/><ln>&nbsp;180</ln><a id="180">&nbsp;</a><c24>in&nbsp;scope&nbsp;at&nbsp;each&nbsp;expression&nbsp;and&nbsp;then&nbsp;uses&nbsp;that&nbsp;set&nbsp;to&nbsp;decide&nbsp;whether
</c24><br/><ln>&nbsp;181</ln><a id="181">&nbsp;</a><c24>that&nbsp;expression&nbsp;is&nbsp;legal.&nbsp;&nbsp;Remember&nbsp;that&nbsp;the&nbsp;scope&nbsp;of&nbsp;loan&nbsp;is&nbsp;defined
</c24><br/><ln>&nbsp;182</ln><a id="182">&nbsp;</a><c24>by&nbsp;its&nbsp;lifetime&nbsp;LT.&nbsp;&nbsp;We&nbsp;sometimes&nbsp;say&nbsp;that&nbsp;a&nbsp;loan&nbsp;which&nbsp;is&nbsp;in-scope&nbsp;at
</c24><br/><ln>&nbsp;183</ln><a id="183">&nbsp;</a><c24>a&nbsp;particular&nbsp;point&nbsp;is&nbsp;an&nbsp;"outstanding&nbsp;loan",&nbsp;aand&nbsp;the&nbsp;set&nbsp;of
</c24><br/><ln>&nbsp;184</ln><a id="184">&nbsp;</a><c24>restrictions&nbsp;included&nbsp;in&nbsp;those&nbsp;loans&nbsp;as&nbsp;the&nbsp;"outstanding
</c24><br/><ln>&nbsp;185</ln><a id="185">&nbsp;</a><c24>restrictions".
</c24><br/><ln>&nbsp;186</ln><a id="186">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;187</ln><a id="187">&nbsp;</a><c24>The&nbsp;kinds&nbsp;of&nbsp;expressions&nbsp;which&nbsp;in-scope&nbsp;loans&nbsp;can&nbsp;render&nbsp;illegal&nbsp;are:
</c24><br/><ln>&nbsp;188</ln><a id="188">&nbsp;</a><c24>-&nbsp;*assignments*&nbsp;(`lv&nbsp;=&nbsp;v`):&nbsp;illegal&nbsp;if&nbsp;there&nbsp;is&nbsp;an&nbsp;in-scope&nbsp;restriction
</c24><br/><ln>&nbsp;189</ln><a id="189">&nbsp;</a><c24>&nbsp;&nbsp;against&nbsp;mutating&nbsp;`lv`;
</c24><br/><ln>&nbsp;190</ln><a id="190">&nbsp;</a><c24>-&nbsp;*moves*:&nbsp;illegal&nbsp;if&nbsp;there&nbsp;is&nbsp;any&nbsp;in-scope&nbsp;restriction&nbsp;on&nbsp;`lv`&nbsp;at&nbsp;all;
</c24><br/><ln>&nbsp;191</ln><a id="191">&nbsp;</a><c24>-&nbsp;*mutable&nbsp;borrows*&nbsp;(`&amp;mut&nbsp;lv`):&nbsp;illegal&nbsp;there&nbsp;is&nbsp;an&nbsp;in-scope&nbsp;restriction
</c24><br/><ln>&nbsp;192</ln><a id="192">&nbsp;</a><c24>&nbsp;&nbsp;against&nbsp;mutating&nbsp;`lv`&nbsp;or&nbsp;aliasing&nbsp;`lv`;
</c24><br/><ln>&nbsp;193</ln><a id="193">&nbsp;</a><c24>-&nbsp;*immutable&nbsp;borrows*&nbsp;(`&amp;lv`):&nbsp;illegal&nbsp;there&nbsp;is&nbsp;an&nbsp;in-scope&nbsp;restriction
</c24><br/><ln>&nbsp;194</ln><a id="194">&nbsp;</a><c24>&nbsp;&nbsp;against&nbsp;freezing&nbsp;`lv`&nbsp;or&nbsp;aliasing&nbsp;`lv`;
</c24><br/><ln>&nbsp;195</ln><a id="195">&nbsp;</a><c24>-&nbsp;*read-only&nbsp;borrows*&nbsp;(`&amp;const&nbsp;lv`):&nbsp;illegal&nbsp;there&nbsp;is&nbsp;an&nbsp;in-scope&nbsp;restriction
</c24><br/><ln>&nbsp;196</ln><a id="196">&nbsp;</a><c24>&nbsp;&nbsp;against&nbsp;aliasing&nbsp;`lv`.
</c24><br/><ln>&nbsp;197</ln><a id="197">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;198</ln><a id="198">&nbsp;</a><c24>##&nbsp;Formal&nbsp;rules
</c24><br/><ln>&nbsp;199</ln><a id="199">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;200</ln><a id="200">&nbsp;</a><c24>Now&nbsp;that&nbsp;we&nbsp;hopefully&nbsp;have&nbsp;some&nbsp;kind&nbsp;of&nbsp;intuitive&nbsp;feeling&nbsp;for&nbsp;how&nbsp;the
</c24><br/><ln>&nbsp;201</ln><a id="201">&nbsp;</a><c24>borrow&nbsp;checker&nbsp;works,&nbsp;let's&nbsp;look&nbsp;a&nbsp;bit&nbsp;more&nbsp;closely&nbsp;now&nbsp;at&nbsp;the&nbsp;precise
</c24><br/><ln>&nbsp;202</ln><a id="202">&nbsp;</a><c24>conditions&nbsp;that&nbsp;it&nbsp;uses.&nbsp;For&nbsp;simplicity&nbsp;I&nbsp;will&nbsp;ignore&nbsp;const&nbsp;loans.
</c24><br/><ln>&nbsp;203</ln><a id="203">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;204</ln><a id="204">&nbsp;</a><c24>I&nbsp;will&nbsp;present&nbsp;the&nbsp;rules&nbsp;in&nbsp;a&nbsp;modified&nbsp;form&nbsp;of&nbsp;standard&nbsp;inference
</c24><br/><ln>&nbsp;205</ln><a id="205">&nbsp;</a><c24>rules,&nbsp;which&nbsp;looks&nbsp;as&nbsp;as&nbsp;follows:
</c24><br/><ln>&nbsp;206</ln><a id="206">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;207</ln><a id="207">&nbsp;</a><c24>&nbsp;&nbsp;&nbsp;&nbsp;PREDICATE(X,&nbsp;Y,&nbsp;Z)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Rule-Name
</c24><br/><ln>&nbsp;208</ln><a id="208">&nbsp;</a><c24>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Condition&nbsp;1
</c24><br/><ln>&nbsp;209</ln><a id="209">&nbsp;</a><c24>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Condition&nbsp;2
</c24><br/><ln>&nbsp;210</ln><a id="210">&nbsp;</a><c24>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Condition&nbsp;3
</c24><br/><ln>&nbsp;211</ln><a id="211">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;212</ln><a id="212">&nbsp;</a><c24>The&nbsp;initial&nbsp;line&nbsp;states&nbsp;the&nbsp;predicate&nbsp;that&nbsp;is&nbsp;to&nbsp;be&nbsp;satisfied.&nbsp;&nbsp;The
</c24><br/><ln>&nbsp;213</ln><a id="213">&nbsp;</a><c24>indented&nbsp;lines&nbsp;indicate&nbsp;the&nbsp;conditions&nbsp;that&nbsp;must&nbsp;be&nbsp;met&nbsp;for&nbsp;the
</c24><br/><ln>&nbsp;214</ln><a id="214">&nbsp;</a><c24>predicate&nbsp;to&nbsp;be&nbsp;satisfied.&nbsp;The&nbsp;right-justified&nbsp;comment&nbsp;states&nbsp;the&nbsp;name
</c24><br/><ln>&nbsp;215</ln><a id="215">&nbsp;</a><c24>of&nbsp;this&nbsp;rule:&nbsp;there&nbsp;are&nbsp;comments&nbsp;in&nbsp;the&nbsp;borrowck&nbsp;source&nbsp;referencing
</c24><br/><ln>&nbsp;216</ln><a id="216">&nbsp;</a><c24>these&nbsp;names,&nbsp;so&nbsp;that&nbsp;you&nbsp;can&nbsp;cross&nbsp;reference&nbsp;to&nbsp;find&nbsp;the&nbsp;actual&nbsp;code
</c24><br/><ln>&nbsp;217</ln><a id="217">&nbsp;</a><c24>that&nbsp;corresponds&nbsp;to&nbsp;the&nbsp;formal&nbsp;rule.
</c24><br/><ln>&nbsp;218</ln><a id="218">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;219</ln><a id="219">&nbsp;</a><c24>###&nbsp;The&nbsp;`gather_loans`&nbsp;pass
</c24><br/><ln>&nbsp;220</ln><a id="220">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;221</ln><a id="221">&nbsp;</a><c24>We&nbsp;start&nbsp;with&nbsp;the&nbsp;`gather_loans`&nbsp;pass,&nbsp;which&nbsp;walks&nbsp;the&nbsp;AST&nbsp;looking&nbsp;for
</c24><br/><ln>&nbsp;222</ln><a id="222">&nbsp;</a><c24>borrows.&nbsp;&nbsp;For&nbsp;each&nbsp;borrow,&nbsp;there&nbsp;are&nbsp;three&nbsp;bits&nbsp;of&nbsp;information:&nbsp;the
</c24><br/><ln>&nbsp;223</ln><a id="223">&nbsp;</a><c24>lvalue&nbsp;`LV`&nbsp;being&nbsp;borrowed&nbsp;and&nbsp;the&nbsp;mutability&nbsp;`MQ`&nbsp;and&nbsp;lifetime&nbsp;`LT`
</c24><br/><ln>&nbsp;224</ln><a id="224">&nbsp;</a><c24>of&nbsp;the&nbsp;resulting&nbsp;pointer.&nbsp;Given&nbsp;those,&nbsp;`gather_loans`&nbsp;applies&nbsp;three
</c24><br/><ln>&nbsp;225</ln><a id="225">&nbsp;</a><c24>validity&nbsp;tests:
</c24><br/><ln>&nbsp;226</ln><a id="226">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;227</ln><a id="227">&nbsp;</a><c24>1.&nbsp;`MUTABILITY(LV,&nbsp;MQ)`:&nbsp;The&nbsp;mutability&nbsp;of&nbsp;the&nbsp;borrowed&nbsp;pointer&nbsp;is
</c24><br/><ln>&nbsp;228</ln><a id="228">&nbsp;</a><c24>compatible&nbsp;with&nbsp;the&nbsp;mutability&nbsp;of&nbsp;`LV`&nbsp;(i.e.,&nbsp;not&nbsp;borrowing&nbsp;immutable
</c24><br/><ln>&nbsp;229</ln><a id="229">&nbsp;</a><c24>data&nbsp;as&nbsp;mutable).
</c24><br/><ln>&nbsp;230</ln><a id="230">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;231</ln><a id="231">&nbsp;</a><c24>2.&nbsp;`LIFETIME(LV,&nbsp;LT,&nbsp;MQ)`:&nbsp;The&nbsp;lifetime&nbsp;of&nbsp;the&nbsp;borrow&nbsp;does&nbsp;not&nbsp;exceed
</c24><br/><ln>&nbsp;232</ln><a id="232">&nbsp;</a><c24>the&nbsp;lifetime&nbsp;of&nbsp;the&nbsp;value&nbsp;being&nbsp;borrowed.&nbsp;This&nbsp;pass&nbsp;is&nbsp;also
</c24><br/><ln>&nbsp;233</ln><a id="233">&nbsp;</a><c24>responsible&nbsp;for&nbsp;inserting&nbsp;root&nbsp;annotations&nbsp;to&nbsp;keep&nbsp;managed&nbsp;values
</c24><br/><ln>&nbsp;234</ln><a id="234">&nbsp;</a><c24>alive&nbsp;and&nbsp;for&nbsp;dynamically&nbsp;freezing&nbsp;`@mut`&nbsp;boxes.
</c24><br/><ln>&nbsp;235</ln><a id="235">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;236</ln><a id="236">&nbsp;</a><c24>3.&nbsp;`RESTRICTIONS(LV,&nbsp;ACTIONS)&nbsp;=&nbsp;RS`:&nbsp;This&nbsp;pass&nbsp;checks&nbsp;and&nbsp;computes&nbsp;the
</c24><br/><ln>&nbsp;237</ln><a id="237">&nbsp;</a><c24>restrictions&nbsp;to&nbsp;maintain&nbsp;memory&nbsp;safety.&nbsp;These&nbsp;are&nbsp;the&nbsp;restrictions
</c24><br/><ln>&nbsp;238</ln><a id="238">&nbsp;</a><c24>that&nbsp;will&nbsp;go&nbsp;into&nbsp;the&nbsp;final&nbsp;loan.&nbsp;We'll&nbsp;discuss&nbsp;in&nbsp;more&nbsp;detail&nbsp;below.
</c24><br/><ln>&nbsp;239</ln><a id="239">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;240</ln><a id="240">&nbsp;</a><c24>##&nbsp;Checking&nbsp;mutability
</c24><br/><ln>&nbsp;241</ln><a id="241">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;242</ln><a id="242">&nbsp;</a><c24>Checking&nbsp;mutability&nbsp;is&nbsp;fairly&nbsp;straightforward.&nbsp;We&nbsp;just&nbsp;want&nbsp;to&nbsp;prevent
</c24><br/><ln>&nbsp;243</ln><a id="243">&nbsp;</a><c24>immutable&nbsp;data&nbsp;from&nbsp;being&nbsp;borrowed&nbsp;as&nbsp;mutable.&nbsp;Note&nbsp;that&nbsp;it&nbsp;is&nbsp;ok&nbsp;to
</c24><br/><ln>&nbsp;244</ln><a id="244">&nbsp;</a><c24>borrow&nbsp;mutable&nbsp;data&nbsp;as&nbsp;immutable,&nbsp;since&nbsp;that&nbsp;is&nbsp;simply&nbsp;a
</c24><br/><ln>&nbsp;245</ln><a id="245">&nbsp;</a><c24>freeze.&nbsp;Formally&nbsp;we&nbsp;define&nbsp;a&nbsp;predicate&nbsp;`MUTABLE(LV,&nbsp;MQ)`&nbsp;which,&nbsp;if
</c24><br/><ln>&nbsp;246</ln><a id="246">&nbsp;</a><c24>defined,&nbsp;means&nbsp;that&nbsp;"borrowing&nbsp;`LV`&nbsp;with&nbsp;mutability&nbsp;`MQ`&nbsp;is&nbsp;ok.&nbsp;The
</c24><br/><ln>&nbsp;247</ln><a id="247">&nbsp;</a><c24>Rust&nbsp;code&nbsp;corresponding&nbsp;to&nbsp;this&nbsp;predicate&nbsp;is&nbsp;the&nbsp;function
</c24><br/><ln>&nbsp;248</ln><a id="248">&nbsp;</a><c24>`check_mutability`&nbsp;in&nbsp;`middle::borrowck::gather_loans`.
</c24><br/><ln>&nbsp;249</ln><a id="249">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;250</ln><a id="250">&nbsp;</a><c24>###&nbsp;Checking&nbsp;mutability&nbsp;of&nbsp;variables
</c24><br/><ln>&nbsp;251</ln><a id="251">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;252</ln><a id="252">&nbsp;</a><c24>*Code&nbsp;pointer:*&nbsp;Function&nbsp;`check_mutability()`&nbsp;in&nbsp;`gather_loans/mod.rs`,
</c24><br/><ln>&nbsp;253</ln><a id="253">&nbsp;</a><c24>but&nbsp;also&nbsp;the&nbsp;code&nbsp;in&nbsp;`mem_categorization`.
</c24><br/><ln>&nbsp;254</ln><a id="254">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;255</ln><a id="255">&nbsp;</a><c24>Let's&nbsp;begin&nbsp;with&nbsp;the&nbsp;rules&nbsp;for&nbsp;variables,&nbsp;which&nbsp;state&nbsp;that&nbsp;if&nbsp;a
</c24><br/><ln>&nbsp;256</ln><a id="256">&nbsp;</a><c24>variable&nbsp;is&nbsp;declared&nbsp;as&nbsp;mutable,&nbsp;it&nbsp;may&nbsp;be&nbsp;borrowed&nbsp;any&nbsp;which&nbsp;way,&nbsp;but
</c24><br/><ln>&nbsp;257</ln><a id="257">&nbsp;</a><c24>otherwise&nbsp;the&nbsp;variable&nbsp;must&nbsp;be&nbsp;borrowed&nbsp;as&nbsp;immutable&nbsp;or&nbsp;const:
</c24><br/><ln>&nbsp;258</ln><a id="258">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;259</ln><a id="259">&nbsp;</a><c24>&nbsp;&nbsp;&nbsp;&nbsp;MUTABILITY(X,&nbsp;MQ)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;M-Var-Mut
</c24><br/><ln>&nbsp;260</ln><a id="260">&nbsp;</a><c24>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DECL(X)&nbsp;=&nbsp;mut
</c24><br/><ln>&nbsp;261</ln><a id="261">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;262</ln><a id="262">&nbsp;</a><c24>&nbsp;&nbsp;&nbsp;&nbsp;MUTABILITY(X,&nbsp;MQ)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;M-Var-Imm
</c24><br/><ln>&nbsp;263</ln><a id="263">&nbsp;</a><c24>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DECL(X)&nbsp;=&nbsp;imm
</c24><br/><ln>&nbsp;264</ln><a id="264">&nbsp;</a><c24>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MQ&nbsp;=&nbsp;imm&nbsp;|&nbsp;const
</c24><br/><ln>&nbsp;265</ln><a id="265">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;266</ln><a id="266">&nbsp;</a><c24>###&nbsp;Checking&nbsp;mutability&nbsp;of&nbsp;owned&nbsp;content
</c24><br/><ln>&nbsp;267</ln><a id="267">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;268</ln><a id="268">&nbsp;</a><c24>Fields&nbsp;and&nbsp;owned&nbsp;pointers&nbsp;inherit&nbsp;their&nbsp;mutability&nbsp;from
</c24><br/><ln>&nbsp;269</ln><a id="269">&nbsp;</a><c24>their&nbsp;base&nbsp;expressions,&nbsp;so&nbsp;both&nbsp;of&nbsp;their&nbsp;rules&nbsp;basically
</c24><br/><ln>&nbsp;270</ln><a id="270">&nbsp;</a><c24>delegate&nbsp;the&nbsp;check&nbsp;to&nbsp;the&nbsp;base&nbsp;expression&nbsp;`LV`:
</c24><br/><ln>&nbsp;271</ln><a id="271">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;272</ln><a id="272">&nbsp;</a><c24>&nbsp;&nbsp;&nbsp;&nbsp;MUTABILITY(LV.f,&nbsp;MQ)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;M-Field
</c24><br/><ln>&nbsp;273</ln><a id="273">&nbsp;</a><c24>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MUTABILITY(LV,&nbsp;MQ)
</c24><br/><ln>&nbsp;274</ln><a id="274">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;275</ln><a id="275">&nbsp;</a><c24>&nbsp;&nbsp;&nbsp;&nbsp;MUTABILITY(*LV,&nbsp;MQ)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;M-Deref-Unique
</c24><br/><ln>&nbsp;276</ln><a id="276">&nbsp;</a><c24>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TYPE(LV)&nbsp;=&nbsp;~Ty
</c24><br/><ln>&nbsp;277</ln><a id="277">&nbsp;</a><c24>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MUTABILITY(LV,&nbsp;MQ)
</c24><br/><ln>&nbsp;278</ln><a id="278">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;279</ln><a id="279">&nbsp;</a><c24>###&nbsp;Checking&nbsp;mutability&nbsp;of&nbsp;immutable&nbsp;pointer&nbsp;types
</c24><br/><ln>&nbsp;280</ln><a id="280">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;281</ln><a id="281">&nbsp;</a><c24>Immutable&nbsp;pointer&nbsp;types&nbsp;like&nbsp;`&amp;T`&nbsp;and&nbsp;`@T`&nbsp;can&nbsp;only
</c24><br/><ln>&nbsp;282</ln><a id="282">&nbsp;</a><c24>be&nbsp;borrowed&nbsp;if&nbsp;MQ&nbsp;is&nbsp;immutable&nbsp;or&nbsp;const:
</c24><br/><ln>&nbsp;283</ln><a id="283">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;284</ln><a id="284">&nbsp;</a><c24>&nbsp;&nbsp;&nbsp;&nbsp;MUTABILITY(*LV,&nbsp;MQ)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;M-Deref-Borrowed-Imm
</c24><br/><ln>&nbsp;285</ln><a id="285">&nbsp;</a><c24>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TYPE(LV)&nbsp;=&nbsp;&amp;Ty
</c24><br/><ln>&nbsp;286</ln><a id="286">&nbsp;</a><c24>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MQ&nbsp;==&nbsp;imm&nbsp;|&nbsp;const
</c24><br/><ln>&nbsp;287</ln><a id="287">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;288</ln><a id="288">&nbsp;</a><c24>&nbsp;&nbsp;&nbsp;&nbsp;MUTABILITY(*LV,&nbsp;MQ)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;M-Deref-Managed-Imm
</c24><br/><ln>&nbsp;289</ln><a id="289">&nbsp;</a><c24>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TYPE(LV)&nbsp;=&nbsp;@Ty
</c24><br/><ln>&nbsp;290</ln><a id="290">&nbsp;</a><c24>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MQ&nbsp;==&nbsp;imm&nbsp;|&nbsp;const
</c24><br/><ln>&nbsp;291</ln><a id="291">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;292</ln><a id="292">&nbsp;</a><c24>###&nbsp;Checking&nbsp;mutability&nbsp;of&nbsp;mutable&nbsp;pointer&nbsp;types
</c24><br/><ln>&nbsp;293</ln><a id="293">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;294</ln><a id="294">&nbsp;</a><c24>`&amp;mut&nbsp;T`&nbsp;and&nbsp;`@mut&nbsp;T`&nbsp;can&nbsp;be&nbsp;frozen,&nbsp;so&nbsp;it&nbsp;is&nbsp;acceptable&nbsp;to&nbsp;borrow
</c24><br/><ln>&nbsp;295</ln><a id="295">&nbsp;</a><c24>them&nbsp;as&nbsp;either&nbsp;imm&nbsp;or&nbsp;mut:
</c24><br/><ln>&nbsp;296</ln><a id="296">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;297</ln><a id="297">&nbsp;</a><c24>&nbsp;&nbsp;&nbsp;&nbsp;MUTABILITY(*LV,&nbsp;MQ)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;M-Deref-Borrowed-Mut
</c24><br/><ln>&nbsp;298</ln><a id="298">&nbsp;</a><c24>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TYPE(LV)&nbsp;=&nbsp;&amp;mut&nbsp;Ty
</c24><br/><ln>&nbsp;299</ln><a id="299">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;300</ln><a id="300">&nbsp;</a><c24>&nbsp;&nbsp;&nbsp;&nbsp;MUTABILITY(*LV,&nbsp;MQ)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;M-Deref-Managed-Mut
</c24><br/><ln>&nbsp;301</ln><a id="301">&nbsp;</a><c24>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TYPE(LV)&nbsp;=&nbsp;@mut&nbsp;Ty
</c24><br/><ln>&nbsp;302</ln><a id="302">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;303</ln><a id="303">&nbsp;</a><c24>##&nbsp;Checking&nbsp;lifetime
</c24><br/><ln>&nbsp;304</ln><a id="304">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;305</ln><a id="305">&nbsp;</a><c24>These&nbsp;rules&nbsp;aim&nbsp;to&nbsp;ensure&nbsp;that&nbsp;no&nbsp;data&nbsp;is&nbsp;borrowed&nbsp;for&nbsp;a&nbsp;scope&nbsp;that
</c24><br/><ln>&nbsp;306</ln><a id="306">&nbsp;</a><c24>exceeds&nbsp;its&nbsp;lifetime.&nbsp;In&nbsp;addition,&nbsp;these&nbsp;rules&nbsp;manage&nbsp;the&nbsp;rooting&nbsp;and
</c24><br/><ln>&nbsp;307</ln><a id="307">&nbsp;</a><c24>dynamic&nbsp;freezing&nbsp;of&nbsp;`@`&nbsp;and&nbsp;`@mut`&nbsp;values.&nbsp;These&nbsp;two&nbsp;computations&nbsp;wind
</c24><br/><ln>&nbsp;308</ln><a id="308">&nbsp;</a><c24>up&nbsp;being&nbsp;intimately&nbsp;related.&nbsp;Formally,&nbsp;we&nbsp;define&nbsp;a&nbsp;predicate
</c24><br/><ln>&nbsp;309</ln><a id="309">&nbsp;</a><c24>`LIFETIME(LV,&nbsp;LT,&nbsp;MQ)`,&nbsp;which&nbsp;states&nbsp;that&nbsp;"the&nbsp;lvalue&nbsp;`LV`&nbsp;can&nbsp;be
</c24><br/><ln>&nbsp;310</ln><a id="310">&nbsp;</a><c24>safely&nbsp;borrowed&nbsp;for&nbsp;the&nbsp;lifetime&nbsp;`LT`&nbsp;with&nbsp;mutability&nbsp;`MQ`".&nbsp;The&nbsp;Rust
</c24><br/><ln>&nbsp;311</ln><a id="311">&nbsp;</a><c24>code&nbsp;corresponding&nbsp;to&nbsp;this&nbsp;predicate&nbsp;is&nbsp;the&nbsp;module
</c24><br/><ln>&nbsp;312</ln><a id="312">&nbsp;</a><c24>`middle::borrowck::gather_loans::lifetime`.
</c24><br/><ln>&nbsp;313</ln><a id="313">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;314</ln><a id="314">&nbsp;</a><c24>###&nbsp;The&nbsp;Scope&nbsp;function
</c24><br/><ln>&nbsp;315</ln><a id="315">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;316</ln><a id="316">&nbsp;</a><c24>Several&nbsp;of&nbsp;the&nbsp;rules&nbsp;refer&nbsp;to&nbsp;a&nbsp;helper&nbsp;function&nbsp;`SCOPE(LV)=LT`.&nbsp;&nbsp;The
</c24><br/><ln>&nbsp;317</ln><a id="317">&nbsp;</a><c24>`SCOPE(LV)`&nbsp;yields&nbsp;the&nbsp;lifetime&nbsp;`LT`&nbsp;for&nbsp;which&nbsp;the&nbsp;lvalue&nbsp;`LV`&nbsp;is
</c24><br/><ln>&nbsp;318</ln><a id="318">&nbsp;</a><c24>guaranteed&nbsp;to&nbsp;exist,&nbsp;presuming&nbsp;that&nbsp;no&nbsp;mutations&nbsp;occur.
</c24><br/><ln>&nbsp;319</ln><a id="319">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;320</ln><a id="320">&nbsp;</a><c24>The&nbsp;scope&nbsp;of&nbsp;a&nbsp;local&nbsp;variable&nbsp;is&nbsp;the&nbsp;block&nbsp;where&nbsp;it&nbsp;is&nbsp;declared:
</c24><br/><ln>&nbsp;321</ln><a id="321">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;322</ln><a id="322">&nbsp;</a><c24>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SCOPE(X)&nbsp;=&nbsp;block&nbsp;where&nbsp;X&nbsp;is&nbsp;declared
</c24><br/><ln>&nbsp;323</ln><a id="323">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;324</ln><a id="324">&nbsp;</a><c24>The&nbsp;scope&nbsp;of&nbsp;a&nbsp;field&nbsp;is&nbsp;the&nbsp;scope&nbsp;of&nbsp;the&nbsp;struct:
</c24><br/><ln>&nbsp;325</ln><a id="325">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;326</ln><a id="326">&nbsp;</a><c24>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SCOPE(LV.f)&nbsp;=&nbsp;SCOPE(LV)
</c24><br/><ln>&nbsp;327</ln><a id="327">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;328</ln><a id="328">&nbsp;</a><c24>The&nbsp;scope&nbsp;of&nbsp;a&nbsp;unique&nbsp;pointee&nbsp;is&nbsp;the&nbsp;scope&nbsp;of&nbsp;the&nbsp;pointer,&nbsp;since
</c24><br/><ln>&nbsp;329</ln><a id="329">&nbsp;</a><c24>(barring&nbsp;mutation&nbsp;or&nbsp;moves)&nbsp;the&nbsp;pointer&nbsp;will&nbsp;not&nbsp;be&nbsp;freed&nbsp;until
</c24><br/><ln>&nbsp;330</ln><a id="330">&nbsp;</a><c24>the&nbsp;pointer&nbsp;itself&nbsp;`LV`&nbsp;goes&nbsp;out&nbsp;of&nbsp;scope:
</c24><br/><ln>&nbsp;331</ln><a id="331">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;332</ln><a id="332">&nbsp;</a><c24>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SCOPE(*LV)&nbsp;=&nbsp;SCOPE(LV)&nbsp;if&nbsp;LV&nbsp;has&nbsp;type&nbsp;~T
</c24><br/><ln>&nbsp;333</ln><a id="333">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;334</ln><a id="334">&nbsp;</a><c24>The&nbsp;scope&nbsp;of&nbsp;a&nbsp;managed&nbsp;pointee&nbsp;is&nbsp;also&nbsp;the&nbsp;scope&nbsp;of&nbsp;the&nbsp;pointer.&nbsp;&nbsp;This
</c24><br/><ln>&nbsp;335</ln><a id="335">&nbsp;</a><c24>is&nbsp;a&nbsp;conservative&nbsp;approximation,&nbsp;since&nbsp;there&nbsp;may&nbsp;be&nbsp;other&nbsp;aliases&nbsp;fo
</c24><br/><ln>&nbsp;336</ln><a id="336">&nbsp;</a><c24>that&nbsp;same&nbsp;managed&nbsp;box&nbsp;that&nbsp;would&nbsp;cause&nbsp;it&nbsp;to&nbsp;live&nbsp;longer:
</c24><br/><ln>&nbsp;337</ln><a id="337">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;338</ln><a id="338">&nbsp;</a><c24>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SCOPE(*LV)&nbsp;=&nbsp;SCOPE(LV)&nbsp;if&nbsp;LV&nbsp;has&nbsp;type&nbsp;@T&nbsp;or&nbsp;@mut&nbsp;T
</c24><br/><ln>&nbsp;339</ln><a id="339">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;340</ln><a id="340">&nbsp;</a><c24>The&nbsp;scope&nbsp;of&nbsp;a&nbsp;borrowed&nbsp;pointee&nbsp;is&nbsp;the&nbsp;scope&nbsp;associated&nbsp;with&nbsp;the
</c24><br/><ln>&nbsp;341</ln><a id="341">&nbsp;</a><c24>pointer.&nbsp;&nbsp;This&nbsp;is&nbsp;a&nbsp;conservative&nbsp;approximation,&nbsp;since&nbsp;the&nbsp;data&nbsp;that
</c24><br/><ln>&nbsp;342</ln><a id="342">&nbsp;</a><c24>the&nbsp;pointer&nbsp;points&nbsp;at&nbsp;may&nbsp;actually&nbsp;live&nbsp;longer:
</c24><br/><ln>&nbsp;343</ln><a id="343">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;344</ln><a id="344">&nbsp;</a><c24>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SCOPE(*LV)&nbsp;=&nbsp;LT&nbsp;if&nbsp;LV&nbsp;has&nbsp;type&nbsp;&amp;'LT&nbsp;T&nbsp;or&nbsp;&amp;'LT&nbsp;mut&nbsp;T
</c24><br/><ln>&nbsp;345</ln><a id="345">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;346</ln><a id="346">&nbsp;</a><c24>###&nbsp;Checking&nbsp;lifetime&nbsp;of&nbsp;variables
</c24><br/><ln>&nbsp;347</ln><a id="347">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;348</ln><a id="348">&nbsp;</a><c24>The&nbsp;rule&nbsp;for&nbsp;variables&nbsp;states&nbsp;that&nbsp;a&nbsp;variable&nbsp;can&nbsp;only&nbsp;be&nbsp;borrowed&nbsp;a
</c24><br/><ln>&nbsp;349</ln><a id="349">&nbsp;</a><c24>lifetime&nbsp;`LT`&nbsp;that&nbsp;is&nbsp;a&nbsp;subregion&nbsp;of&nbsp;the&nbsp;variable's&nbsp;scope:
</c24><br/><ln>&nbsp;350</ln><a id="350">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;351</ln><a id="351">&nbsp;</a><c24>&nbsp;&nbsp;&nbsp;&nbsp;LIFETIME(X,&nbsp;LT,&nbsp;MQ)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;L-Local
</c24><br/><ln>&nbsp;352</ln><a id="352">&nbsp;</a><c24>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LT&nbsp;&lt;=&nbsp;SCOPE(X)
</c24><br/><ln>&nbsp;353</ln><a id="353">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;354</ln><a id="354">&nbsp;</a><c24>###&nbsp;Checking&nbsp;lifetime&nbsp;for&nbsp;owned&nbsp;content
</c24><br/><ln>&nbsp;355</ln><a id="355">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;356</ln><a id="356">&nbsp;</a><c24>The&nbsp;lifetime&nbsp;of&nbsp;a&nbsp;field&nbsp;or&nbsp;owned&nbsp;pointer&nbsp;is&nbsp;the&nbsp;same&nbsp;as&nbsp;the&nbsp;lifetime
</c24><br/><ln>&nbsp;357</ln><a id="357">&nbsp;</a><c24>of&nbsp;its&nbsp;owner:
</c24><br/><ln>&nbsp;358</ln><a id="358">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;359</ln><a id="359">&nbsp;</a><c24>&nbsp;&nbsp;&nbsp;&nbsp;LIFETIME(LV.f,&nbsp;LT,&nbsp;MQ)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;L-Field
</c24><br/><ln>&nbsp;360</ln><a id="360">&nbsp;</a><c24>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LIFETIME(LV,&nbsp;LT,&nbsp;MQ)
</c24><br/><ln>&nbsp;361</ln><a id="361">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;362</ln><a id="362">&nbsp;</a><c24>&nbsp;&nbsp;&nbsp;&nbsp;LIFETIME(*LV,&nbsp;LT,&nbsp;MQ)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;L-Deref-Send
</c24><br/><ln>&nbsp;363</ln><a id="363">&nbsp;</a><c24>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TYPE(LV)&nbsp;=&nbsp;~Ty
</c24><br/><ln>&nbsp;364</ln><a id="364">&nbsp;</a><c24>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LIFETIME(LV,&nbsp;LT,&nbsp;MQ)
</c24><br/><ln>&nbsp;365</ln><a id="365">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;366</ln><a id="366">&nbsp;</a><c24>###&nbsp;Checking&nbsp;lifetime&nbsp;for&nbsp;derefs&nbsp;of&nbsp;borrowed&nbsp;pointers
</c24><br/><ln>&nbsp;367</ln><a id="367">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;368</ln><a id="368">&nbsp;</a><c24>Borrowed&nbsp;pointers&nbsp;have&nbsp;a&nbsp;lifetime&nbsp;`LT'`&nbsp;associated&nbsp;with&nbsp;them.&nbsp;&nbsp;The
</c24><br/><ln>&nbsp;369</ln><a id="369">&nbsp;</a><c24>data&nbsp;they&nbsp;point&nbsp;at&nbsp;has&nbsp;been&nbsp;guaranteed&nbsp;to&nbsp;be&nbsp;valid&nbsp;for&nbsp;at&nbsp;least&nbsp;this
</c24><br/><ln>&nbsp;370</ln><a id="370">&nbsp;</a><c24>lifetime.&nbsp;Therefore,&nbsp;the&nbsp;borrow&nbsp;is&nbsp;valid&nbsp;so&nbsp;long&nbsp;as&nbsp;the&nbsp;lifetime&nbsp;`LT`
</c24><br/><ln>&nbsp;371</ln><a id="371">&nbsp;</a><c24>of&nbsp;the&nbsp;borrow&nbsp;is&nbsp;shorter&nbsp;than&nbsp;the&nbsp;lifetime&nbsp;`LT'`&nbsp;of&nbsp;the&nbsp;pointer
</c24><br/><ln>&nbsp;372</ln><a id="372">&nbsp;</a><c24>itself:
</c24><br/><ln>&nbsp;373</ln><a id="373">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;374</ln><a id="374">&nbsp;</a><c24>&nbsp;&nbsp;&nbsp;&nbsp;LIFETIME(*LV,&nbsp;LT,&nbsp;MQ)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;L-Deref-Borrowed
</c24><br/><ln>&nbsp;375</ln><a id="375">&nbsp;</a><c24>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TYPE(LV)&nbsp;=&nbsp;&amp;LT'&nbsp;Ty&nbsp;OR&nbsp;&amp;LT'&nbsp;mut&nbsp;Ty
</c24><br/><ln>&nbsp;376</ln><a id="376">&nbsp;</a><c24>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LT&nbsp;&lt;=&nbsp;LT'
</c24><br/><ln>&nbsp;377</ln><a id="377">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;378</ln><a id="378">&nbsp;</a><c24>###&nbsp;Checking&nbsp;lifetime&nbsp;for&nbsp;derefs&nbsp;of&nbsp;managed,&nbsp;immutable&nbsp;pointers
</c24><br/><ln>&nbsp;379</ln><a id="379">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;380</ln><a id="380">&nbsp;</a><c24>Managed&nbsp;pointers&nbsp;are&nbsp;valid&nbsp;so&nbsp;long&nbsp;as&nbsp;the&nbsp;data&nbsp;within&nbsp;them&nbsp;is
</c24><br/><ln>&nbsp;381</ln><a id="381">&nbsp;</a><c24>*rooted*.&nbsp;There&nbsp;are&nbsp;two&nbsp;ways&nbsp;that&nbsp;this&nbsp;can&nbsp;be&nbsp;achieved.&nbsp;The&nbsp;first&nbsp;is
</c24><br/><ln>&nbsp;382</ln><a id="382">&nbsp;</a><c24>when&nbsp;the&nbsp;user&nbsp;guarantees&nbsp;such&nbsp;a&nbsp;root&nbsp;will&nbsp;exist.&nbsp;For&nbsp;this&nbsp;to&nbsp;be&nbsp;true,
</c24><br/><ln>&nbsp;383</ln><a id="383">&nbsp;</a><c24>three&nbsp;conditions&nbsp;must&nbsp;be&nbsp;met:
</c24><br/><ln>&nbsp;384</ln><a id="384">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;385</ln><a id="385">&nbsp;</a><c24>&nbsp;&nbsp;&nbsp;&nbsp;LIFETIME(*LV,&nbsp;LT,&nbsp;MQ)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;L-Deref-Managed-Imm-User-Root
</c24><br/><ln>&nbsp;386</ln><a id="386">&nbsp;</a><c24>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TYPE(LV)&nbsp;=&nbsp;@Ty
</c24><br/><ln>&nbsp;387</ln><a id="387">&nbsp;</a><c24>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LT&nbsp;&lt;=&nbsp;SCOPE(LV)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;(1)
</c24><br/><ln>&nbsp;388</ln><a id="388">&nbsp;</a><c24>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LV&nbsp;is&nbsp;immutable&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;(2)
</c24><br/><ln>&nbsp;389</ln><a id="389">&nbsp;</a><c24>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LV&nbsp;is&nbsp;not&nbsp;moved&nbsp;or&nbsp;not&nbsp;movable&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;(3)
</c24><br/><ln>&nbsp;390</ln><a id="390">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;391</ln><a id="391">&nbsp;</a><c24>Condition&nbsp;(1)&nbsp;guarantees&nbsp;that&nbsp;the&nbsp;managed&nbsp;box&nbsp;will&nbsp;be&nbsp;rooted&nbsp;for&nbsp;at
</c24><br/><ln>&nbsp;392</ln><a id="392">&nbsp;</a><c24>least&nbsp;the&nbsp;lifetime&nbsp;`LT`&nbsp;of&nbsp;the&nbsp;borrow,&nbsp;presuming&nbsp;that&nbsp;no&nbsp;mutation&nbsp;or
</c24><br/><ln>&nbsp;393</ln><a id="393">&nbsp;</a><c24>moves&nbsp;occur.&nbsp;Conditions&nbsp;(2)&nbsp;and&nbsp;(3)&nbsp;then&nbsp;serve&nbsp;to&nbsp;guarantee&nbsp;that&nbsp;the
</c24><br/><ln>&nbsp;394</ln><a id="394">&nbsp;</a><c24>value&nbsp;is&nbsp;not&nbsp;mutated&nbsp;or&nbsp;moved.&nbsp;Note&nbsp;that&nbsp;lvalues&nbsp;are&nbsp;either
</c24><br/><ln>&nbsp;395</ln><a id="395">&nbsp;</a><c24>(ultimately)&nbsp;owned&nbsp;by&nbsp;a&nbsp;local&nbsp;variable,&nbsp;in&nbsp;which&nbsp;case&nbsp;we&nbsp;can&nbsp;check
</c24><br/><ln>&nbsp;396</ln><a id="396">&nbsp;</a><c24>whether&nbsp;that&nbsp;local&nbsp;variable&nbsp;is&nbsp;ever&nbsp;moved&nbsp;in&nbsp;its&nbsp;scope,&nbsp;or&nbsp;they&nbsp;are
</c24><br/><ln>&nbsp;397</ln><a id="397">&nbsp;</a><c24>owned&nbsp;by&nbsp;the&nbsp;pointee&nbsp;of&nbsp;an&nbsp;(immutable,&nbsp;due&nbsp;to&nbsp;condition&nbsp;2)&nbsp;managed&nbsp;or
</c24><br/><ln>&nbsp;398</ln><a id="398">&nbsp;</a><c24>borrowed&nbsp;pointer,&nbsp;in&nbsp;which&nbsp;case&nbsp;moves&nbsp;are&nbsp;not&nbsp;permitted&nbsp;because&nbsp;the
</c24><br/><ln>&nbsp;399</ln><a id="399">&nbsp;</a><c24>location&nbsp;is&nbsp;aliasable.
</c24><br/><ln>&nbsp;400</ln><a id="400">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;401</ln><a id="401">&nbsp;</a><c24>If&nbsp;the&nbsp;conditions&nbsp;of&nbsp;`L-Deref-Managed-Imm-User-Root`&nbsp;are&nbsp;not&nbsp;met,&nbsp;then
</c24><br/><ln>&nbsp;402</ln><a id="402">&nbsp;</a><c24>there&nbsp;is&nbsp;a&nbsp;second&nbsp;alternative.&nbsp;The&nbsp;compiler&nbsp;can&nbsp;attempt&nbsp;to&nbsp;root&nbsp;the
</c24><br/><ln>&nbsp;403</ln><a id="403">&nbsp;</a><c24>managed&nbsp;pointer&nbsp;itself.&nbsp;This&nbsp;permits&nbsp;great&nbsp;flexibility,&nbsp;because&nbsp;the
</c24><br/><ln>&nbsp;404</ln><a id="404">&nbsp;</a><c24>location&nbsp;`LV`&nbsp;where&nbsp;the&nbsp;managed&nbsp;pointer&nbsp;is&nbsp;found&nbsp;does&nbsp;not&nbsp;matter,&nbsp;but
</c24><br/><ln>&nbsp;405</ln><a id="405">&nbsp;</a><c24>there&nbsp;are&nbsp;some&nbsp;limitations.&nbsp;The&nbsp;lifetime&nbsp;of&nbsp;the&nbsp;borrow&nbsp;can&nbsp;only&nbsp;extend
</c24><br/><ln>&nbsp;406</ln><a id="406">&nbsp;</a><c24>to&nbsp;the&nbsp;innermost&nbsp;enclosing&nbsp;loop&nbsp;or&nbsp;function&nbsp;body.&nbsp;This&nbsp;guarantees&nbsp;that
</c24><br/><ln>&nbsp;407</ln><a id="407">&nbsp;</a><c24>the&nbsp;compiler&nbsp;never&nbsp;requires&nbsp;an&nbsp;unbounded&nbsp;amount&nbsp;of&nbsp;stack&nbsp;space&nbsp;to
</c24><br/><ln>&nbsp;408</ln><a id="408">&nbsp;</a><c24>perform&nbsp;the&nbsp;rooting;&nbsp;if&nbsp;this&nbsp;condition&nbsp;were&nbsp;violated,&nbsp;the&nbsp;compiler
</c24><br/><ln>&nbsp;409</ln><a id="409">&nbsp;</a><c24>might&nbsp;have&nbsp;to&nbsp;accumulate&nbsp;a&nbsp;list&nbsp;of&nbsp;rooted&nbsp;objects,&nbsp;for&nbsp;example&nbsp;if&nbsp;the
</c24><br/><ln>&nbsp;410</ln><a id="410">&nbsp;</a><c24>borrow&nbsp;occurred&nbsp;inside&nbsp;the&nbsp;body&nbsp;of&nbsp;a&nbsp;loop&nbsp;but&nbsp;the&nbsp;scope&nbsp;of&nbsp;the&nbsp;borrow
</c24><br/><ln>&nbsp;411</ln><a id="411">&nbsp;</a><c24>extended&nbsp;outside&nbsp;the&nbsp;loop.&nbsp;More&nbsp;formally,&nbsp;the&nbsp;requirement&nbsp;is&nbsp;that
</c24><br/><ln>&nbsp;412</ln><a id="412">&nbsp;</a><c24>there&nbsp;is&nbsp;no&nbsp;path&nbsp;starting&nbsp;from&nbsp;the&nbsp;borrow&nbsp;that&nbsp;leads&nbsp;back&nbsp;to&nbsp;the
</c24><br/><ln>&nbsp;413</ln><a id="413">&nbsp;</a><c24>borrow&nbsp;without&nbsp;crossing&nbsp;the&nbsp;exit&nbsp;from&nbsp;the&nbsp;scope&nbsp;`LT`.
</c24><br/><ln>&nbsp;414</ln><a id="414">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;415</ln><a id="415">&nbsp;</a><c24>The&nbsp;rule&nbsp;for&nbsp;compiler&nbsp;rooting&nbsp;is&nbsp;as&nbsp;follows:
</c24><br/><ln>&nbsp;416</ln><a id="416">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;417</ln><a id="417">&nbsp;</a><c24>&nbsp;&nbsp;&nbsp;&nbsp;LIFETIME(*LV,&nbsp;LT,&nbsp;MQ)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;L-Deref-Managed-Imm-Compiler-Root
</c24><br/><ln>&nbsp;418</ln><a id="418">&nbsp;</a><c24>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TYPE(LV)&nbsp;=&nbsp;@Ty
</c24><br/><ln>&nbsp;419</ln><a id="419">&nbsp;</a><c24>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LT&nbsp;&lt;=&nbsp;innermost&nbsp;enclosing&nbsp;loop/func
</c24><br/><ln>&nbsp;420</ln><a id="420">&nbsp;</a><c24>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ROOT&nbsp;LV&nbsp;at&nbsp;*LV&nbsp;for&nbsp;LT
</c24><br/><ln>&nbsp;421</ln><a id="421">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;422</ln><a id="422">&nbsp;</a><c24>Here&nbsp;I&nbsp;have&nbsp;written&nbsp;`ROOT&nbsp;LV&nbsp;at&nbsp;*LV&nbsp;FOR&nbsp;LT`&nbsp;to&nbsp;indicate&nbsp;that&nbsp;the&nbsp;code
</c24><br/><ln>&nbsp;423</ln><a id="423">&nbsp;</a><c24>makes&nbsp;a&nbsp;note&nbsp;in&nbsp;a&nbsp;side-table&nbsp;that&nbsp;the&nbsp;box&nbsp;`LV`&nbsp;must&nbsp;be&nbsp;rooted&nbsp;into&nbsp;the
</c24><br/><ln>&nbsp;424</ln><a id="424">&nbsp;</a><c24>stack&nbsp;when&nbsp;`*LV`&nbsp;is&nbsp;evaluated,&nbsp;and&nbsp;that&nbsp;this&nbsp;root&nbsp;can&nbsp;be&nbsp;released&nbsp;when
</c24><br/><ln>&nbsp;425</ln><a id="425">&nbsp;</a><c24>the&nbsp;scope&nbsp;`LT`&nbsp;exits.
</c24><br/><ln>&nbsp;426</ln><a id="426">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;427</ln><a id="427">&nbsp;</a><c24>###&nbsp;Checking&nbsp;lifetime&nbsp;for&nbsp;derefs&nbsp;of&nbsp;managed,&nbsp;mutable&nbsp;pointers
</c24><br/><ln>&nbsp;428</ln><a id="428">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;429</ln><a id="429">&nbsp;</a><c24>Loans&nbsp;of&nbsp;the&nbsp;contents&nbsp;of&nbsp;mutable&nbsp;managed&nbsp;pointers&nbsp;are&nbsp;simpler&nbsp;in&nbsp;some
</c24><br/><ln>&nbsp;430</ln><a id="430">&nbsp;</a><c24>ways&nbsp;that&nbsp;loans&nbsp;of&nbsp;immutable&nbsp;managed&nbsp;pointers,&nbsp;because&nbsp;we&nbsp;can&nbsp;never
</c24><br/><ln>&nbsp;431</ln><a id="431">&nbsp;</a><c24>rely&nbsp;on&nbsp;the&nbsp;user&nbsp;to&nbsp;root&nbsp;them&nbsp;(since&nbsp;the&nbsp;contents&nbsp;are,&nbsp;after&nbsp;all,
</c24><br/><ln>&nbsp;432</ln><a id="432">&nbsp;</a><c24>mutable).&nbsp;This&nbsp;means&nbsp;that&nbsp;the&nbsp;burden&nbsp;always&nbsp;falls&nbsp;to&nbsp;the&nbsp;compiler,&nbsp;so
</c24><br/><ln>&nbsp;433</ln><a id="433">&nbsp;</a><c24>there&nbsp;is&nbsp;only&nbsp;one&nbsp;rule:
</c24><br/><ln>&nbsp;434</ln><a id="434">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;435</ln><a id="435">&nbsp;</a><c24>&nbsp;&nbsp;&nbsp;&nbsp;LIFETIME(*LV,&nbsp;LT,&nbsp;MQ)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;L-Deref-Managed-Mut-Compiler-Root
</c24><br/><ln>&nbsp;436</ln><a id="436">&nbsp;</a><c24>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TYPE(LV)&nbsp;=&nbsp;@mut&nbsp;Ty
</c24><br/><ln>&nbsp;437</ln><a id="437">&nbsp;</a><c24>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LT&nbsp;&lt;=&nbsp;innermost&nbsp;enclosing&nbsp;loop/func
</c24><br/><ln>&nbsp;438</ln><a id="438">&nbsp;</a><c24>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ROOT&nbsp;LV&nbsp;at&nbsp;*LV&nbsp;for&nbsp;LT
</c24><br/><ln>&nbsp;439</ln><a id="439">&nbsp;</a><c24>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LOCK&nbsp;LV&nbsp;at&nbsp;*LV&nbsp;as&nbsp;MQ&nbsp;for&nbsp;LT
</c24><br/><ln>&nbsp;440</ln><a id="440">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;441</ln><a id="441">&nbsp;</a><c24>Note&nbsp;that&nbsp;there&nbsp;is&nbsp;an&nbsp;additional&nbsp;clause&nbsp;this&nbsp;time&nbsp;`LOCK&nbsp;LV&nbsp;at&nbsp;*LV&nbsp;as
</c24><br/><ln>&nbsp;442</ln><a id="442">&nbsp;</a><c24>MQ&nbsp;for&nbsp;LT`.&nbsp;&nbsp;This&nbsp;clause&nbsp;states&nbsp;that&nbsp;in&nbsp;addition&nbsp;to&nbsp;rooting&nbsp;`LV`,&nbsp;the
</c24><br/><ln>&nbsp;443</ln><a id="443">&nbsp;</a><c24>compiler&nbsp;should&nbsp;also&nbsp;"lock"&nbsp;the&nbsp;box&nbsp;dynamically,&nbsp;meaning&nbsp;that&nbsp;we
</c24><br/><ln>&nbsp;444</ln><a id="444">&nbsp;</a><c24>register&nbsp;that&nbsp;the&nbsp;box&nbsp;has&nbsp;been&nbsp;borrowed&nbsp;as&nbsp;mutable&nbsp;or&nbsp;immutable,
</c24><br/><ln>&nbsp;445</ln><a id="445">&nbsp;</a><c24>depending&nbsp;on&nbsp;`MQ`.&nbsp;This&nbsp;lock&nbsp;will&nbsp;fail&nbsp;if&nbsp;the&nbsp;box&nbsp;has&nbsp;already&nbsp;been
</c24><br/><ln>&nbsp;446</ln><a id="446">&nbsp;</a><c24>borrowed&nbsp;and&nbsp;either&nbsp;the&nbsp;old&nbsp;loan&nbsp;or&nbsp;the&nbsp;new&nbsp;loan&nbsp;is&nbsp;a&nbsp;mutable&nbsp;loan
</c24><br/><ln>&nbsp;447</ln><a id="447">&nbsp;</a><c24>(multiple&nbsp;immutable&nbsp;loans&nbsp;are&nbsp;okay).&nbsp;The&nbsp;lock&nbsp;is&nbsp;released&nbsp;as&nbsp;we&nbsp;exit
</c24><br/><ln>&nbsp;448</ln><a id="448">&nbsp;</a><c24>the&nbsp;scope&nbsp;`LT`.
</c24><br/><ln>&nbsp;449</ln><a id="449">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;450</ln><a id="450">&nbsp;</a><c24>##&nbsp;Computing&nbsp;the&nbsp;restrictions
</c24><br/><ln>&nbsp;451</ln><a id="451">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;452</ln><a id="452">&nbsp;</a><c24>The&nbsp;final&nbsp;rules&nbsp;govern&nbsp;the&nbsp;computation&nbsp;of&nbsp;*restrictions*,&nbsp;meaning&nbsp;that
</c24><br/><ln>&nbsp;453</ln><a id="453">&nbsp;</a><c24>we&nbsp;compute&nbsp;the&nbsp;set&nbsp;of&nbsp;actions&nbsp;that&nbsp;will&nbsp;be&nbsp;illegal&nbsp;for&nbsp;the&nbsp;life&nbsp;of&nbsp;the
</c24><br/><ln>&nbsp;454</ln><a id="454">&nbsp;</a><c24>loan.&nbsp;The&nbsp;predicate&nbsp;is&nbsp;written&nbsp;`RESTRICTIONS(LV,&nbsp;ACTIONS)&nbsp;=
</c24><br/><ln>&nbsp;455</ln><a id="455">&nbsp;</a><c24>RESTRICTION*`,&nbsp;which&nbsp;can&nbsp;be&nbsp;read&nbsp;"in&nbsp;order&nbsp;to&nbsp;prevent&nbsp;`ACTIONS`&nbsp;from
</c24><br/><ln>&nbsp;456</ln><a id="456">&nbsp;</a><c24>occuring&nbsp;on&nbsp;`LV`,&nbsp;the&nbsp;restrictions&nbsp;`RESTRICTION*`&nbsp;must&nbsp;be&nbsp;respected
</c24><br/><ln>&nbsp;457</ln><a id="457">&nbsp;</a><c24>for&nbsp;the&nbsp;lifetime&nbsp;of&nbsp;the&nbsp;loan".
</c24><br/><ln>&nbsp;458</ln><a id="458">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;459</ln><a id="459">&nbsp;</a><c24>Note&nbsp;that&nbsp;there&nbsp;is&nbsp;an&nbsp;initial&nbsp;set&nbsp;of&nbsp;restrictions:&nbsp;these&nbsp;restrictions
</c24><br/><ln>&nbsp;460</ln><a id="460">&nbsp;</a><c24>are&nbsp;computed&nbsp;based&nbsp;on&nbsp;the&nbsp;kind&nbsp;of&nbsp;borrow:
</c24><br/><ln>&nbsp;461</ln><a id="461">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;462</ln><a id="462">&nbsp;</a><c24>&nbsp;&nbsp;&nbsp;&nbsp;&amp;mut&nbsp;LV&nbsp;=&gt;&nbsp;&nbsp;&nbsp;RESTRICTIONS(LV,&nbsp;MUTATE|CLAIM|FREEZE)
</c24><br/><ln>&nbsp;463</ln><a id="463">&nbsp;</a><c24>&nbsp;&nbsp;&nbsp;&nbsp;&amp;LV&nbsp;=&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RESTRICTIONS(LV,&nbsp;MUTATE|CLAIM)
</c24><br/><ln>&nbsp;464</ln><a id="464">&nbsp;</a><c24>&nbsp;&nbsp;&nbsp;&nbsp;&amp;const&nbsp;LV&nbsp;=&gt;&nbsp;RESTRICTIONS(LV,&nbsp;[])
</c24><br/><ln>&nbsp;465</ln><a id="465">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;466</ln><a id="466">&nbsp;</a><c24>The&nbsp;reasoning&nbsp;here&nbsp;is&nbsp;that&nbsp;a&nbsp;mutable&nbsp;borrow&nbsp;must&nbsp;be&nbsp;the&nbsp;only&nbsp;writer,
</c24><br/><ln>&nbsp;467</ln><a id="467">&nbsp;</a><c24>therefore&nbsp;it&nbsp;prevents&nbsp;other&nbsp;writes&nbsp;(`MUTATE`),&nbsp;mutable&nbsp;borrows
</c24><br/><ln>&nbsp;468</ln><a id="468">&nbsp;</a><c24>(`CLAIM`),&nbsp;and&nbsp;immutable&nbsp;borrows&nbsp;(`FREEZE`).&nbsp;An&nbsp;immutable&nbsp;borrow
</c24><br/><ln>&nbsp;469</ln><a id="469">&nbsp;</a><c24>permits&nbsp;other&nbsp;immutable&nbsp;borows&nbsp;but&nbsp;forbids&nbsp;writes&nbsp;and&nbsp;mutable&nbsp;borows.
</c24><br/><ln>&nbsp;470</ln><a id="470">&nbsp;</a><c24>Finally,&nbsp;a&nbsp;const&nbsp;borrow&nbsp;just&nbsp;wants&nbsp;to&nbsp;be&nbsp;sure&nbsp;that&nbsp;the&nbsp;value&nbsp;is&nbsp;not
</c24><br/><ln>&nbsp;471</ln><a id="471">&nbsp;</a><c24>moved&nbsp;out&nbsp;from&nbsp;under&nbsp;it,&nbsp;so&nbsp;no&nbsp;actions&nbsp;are&nbsp;forbidden.
</c24><br/><ln>&nbsp;472</ln><a id="472">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;473</ln><a id="473">&nbsp;</a><c24>###&nbsp;Restrictions&nbsp;for&nbsp;loans&nbsp;of&nbsp;a&nbsp;local&nbsp;variable
</c24><br/><ln>&nbsp;474</ln><a id="474">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;475</ln><a id="475">&nbsp;</a><c24>The&nbsp;simplest&nbsp;case&nbsp;is&nbsp;a&nbsp;borrow&nbsp;of&nbsp;a&nbsp;local&nbsp;variable&nbsp;`X`:
</c24><br/><ln>&nbsp;476</ln><a id="476">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;477</ln><a id="477">&nbsp;</a><c24>&nbsp;&nbsp;&nbsp;&nbsp;RESTRICTIONS(X,&nbsp;ACTIONS)&nbsp;=&nbsp;(X,&nbsp;ACTIONS)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;R-Variable
</c24><br/><ln>&nbsp;478</ln><a id="478">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;479</ln><a id="479">&nbsp;</a><c24>In&nbsp;such&nbsp;cases&nbsp;we&nbsp;just&nbsp;record&nbsp;the&nbsp;actions&nbsp;that&nbsp;are&nbsp;not&nbsp;permitted.
</c24><br/><ln>&nbsp;480</ln><a id="480">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;481</ln><a id="481">&nbsp;</a><c24>###&nbsp;Restrictions&nbsp;for&nbsp;loans&nbsp;of&nbsp;fields
</c24><br/><ln>&nbsp;482</ln><a id="482">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;483</ln><a id="483">&nbsp;</a><c24>Restricting&nbsp;a&nbsp;field&nbsp;is&nbsp;the&nbsp;same&nbsp;as&nbsp;restricting&nbsp;the&nbsp;owner&nbsp;of&nbsp;that
</c24><br/><ln>&nbsp;484</ln><a id="484">&nbsp;</a><c24>field:
</c24><br/><ln>&nbsp;485</ln><a id="485">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;486</ln><a id="486">&nbsp;</a><c24>&nbsp;&nbsp;&nbsp;&nbsp;RESTRICTIONS(LV.f,&nbsp;ACTIONS)&nbsp;=&nbsp;RS,&nbsp;(LV.f,&nbsp;ACTIONS)&nbsp;&nbsp;//&nbsp;R-Field
</c24><br/><ln>&nbsp;487</ln><a id="487">&nbsp;</a><c24>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RESTRICTIONS(LV,&nbsp;ACTIONS)&nbsp;=&nbsp;RS
</c24><br/><ln>&nbsp;488</ln><a id="488">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;489</ln><a id="489">&nbsp;</a><c24>The&nbsp;reasoning&nbsp;here&nbsp;is&nbsp;as&nbsp;follows.&nbsp;If&nbsp;the&nbsp;field&nbsp;must&nbsp;not&nbsp;be&nbsp;mutated,
</c24><br/><ln>&nbsp;490</ln><a id="490">&nbsp;</a><c24>then&nbsp;you&nbsp;must&nbsp;not&nbsp;mutate&nbsp;the&nbsp;owner&nbsp;of&nbsp;the&nbsp;field&nbsp;either,&nbsp;since&nbsp;that
</c24><br/><ln>&nbsp;491</ln><a id="491">&nbsp;</a><c24>would&nbsp;indirectly&nbsp;modify&nbsp;the&nbsp;field.&nbsp;Similarly,&nbsp;if&nbsp;the&nbsp;field&nbsp;cannot&nbsp;be
</c24><br/><ln>&nbsp;492</ln><a id="492">&nbsp;</a><c24>frozen&nbsp;or&nbsp;aliased,&nbsp;we&nbsp;cannot&nbsp;allow&nbsp;the&nbsp;owner&nbsp;to&nbsp;be&nbsp;frozen&nbsp;or&nbsp;aliased,
</c24><br/><ln>&nbsp;493</ln><a id="493">&nbsp;</a><c24>since&nbsp;doing&nbsp;so&nbsp;indirectly&nbsp;freezes/aliases&nbsp;the&nbsp;field.&nbsp;This&nbsp;is&nbsp;the
</c24><br/><ln>&nbsp;494</ln><a id="494">&nbsp;</a><c24>origin&nbsp;of&nbsp;inherited&nbsp;mutability.
</c24><br/><ln>&nbsp;495</ln><a id="495">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;496</ln><a id="496">&nbsp;</a><c24>###&nbsp;Restrictions&nbsp;for&nbsp;loans&nbsp;of&nbsp;owned&nbsp;pointees
</c24><br/><ln>&nbsp;497</ln><a id="497">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;498</ln><a id="498">&nbsp;</a><c24>Because&nbsp;the&nbsp;mutability&nbsp;of&nbsp;owned&nbsp;pointees&nbsp;is&nbsp;inherited,&nbsp;restricting&nbsp;an
</c24><br/><ln>&nbsp;499</ln><a id="499">&nbsp;</a><c24>owned&nbsp;pointee&nbsp;is&nbsp;similar&nbsp;to&nbsp;restricting&nbsp;a&nbsp;field,&nbsp;in&nbsp;that&nbsp;it&nbsp;implies
</c24><br/><ln>&nbsp;500</ln><a id="500">&nbsp;</a><c24>restrictions&nbsp;on&nbsp;the&nbsp;pointer.&nbsp;However,&nbsp;owned&nbsp;pointers&nbsp;have&nbsp;an&nbsp;important
</c24><br/><ln>&nbsp;501</ln><a id="501">&nbsp;</a><c24>twist:&nbsp;if&nbsp;the&nbsp;owner&nbsp;`LV`&nbsp;is&nbsp;mutated,&nbsp;that&nbsp;causes&nbsp;the&nbsp;owned&nbsp;pointee
</c24><br/><ln>&nbsp;502</ln><a id="502">&nbsp;</a><c24>`*LV`&nbsp;to&nbsp;be&nbsp;freed!&nbsp;So&nbsp;whenever&nbsp;an&nbsp;owned&nbsp;pointee&nbsp;`*LV`&nbsp;is&nbsp;borrowed,&nbsp;we
</c24><br/><ln>&nbsp;503</ln><a id="503">&nbsp;</a><c24>must&nbsp;prevent&nbsp;the&nbsp;owned&nbsp;pointer&nbsp;`LV`&nbsp;from&nbsp;being&nbsp;mutated,&nbsp;which&nbsp;means
</c24><br/><ln>&nbsp;504</ln><a id="504">&nbsp;</a><c24>that&nbsp;we&nbsp;always&nbsp;add&nbsp;`MUTATE`&nbsp;and&nbsp;`CLAIM`&nbsp;to&nbsp;the&nbsp;restriction&nbsp;set&nbsp;imposed
</c24><br/><ln>&nbsp;505</ln><a id="505">&nbsp;</a><c24>on&nbsp;`LV`:
</c24><br/><ln>&nbsp;506</ln><a id="506">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;507</ln><a id="507">&nbsp;</a><c24>&nbsp;&nbsp;&nbsp;&nbsp;RESTRICTIONS(*LV,&nbsp;ACTIONS)&nbsp;=&nbsp;RS,&nbsp;(*LV,&nbsp;ACTIONS)&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;R-Deref-Send-Pointer
</c24><br/><ln>&nbsp;508</ln><a id="508">&nbsp;</a><c24>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TYPE(LV)&nbsp;=&nbsp;~Ty
</c24><br/><ln>&nbsp;509</ln><a id="509">&nbsp;</a><c24>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RESTRICTIONS(LV,&nbsp;ACTIONS|MUTATE|CLAIM)&nbsp;=&nbsp;RS
</c24><br/><ln>&nbsp;510</ln><a id="510">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;511</ln><a id="511">&nbsp;</a><c24>###&nbsp;Restrictions&nbsp;for&nbsp;loans&nbsp;of&nbsp;immutable&nbsp;managed/borrowed&nbsp;pointees
</c24><br/><ln>&nbsp;512</ln><a id="512">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;513</ln><a id="513">&nbsp;</a><c24>Immutable&nbsp;managed/borrowed&nbsp;pointees&nbsp;are&nbsp;freely&nbsp;aliasable,&nbsp;meaning&nbsp;that
</c24><br/><ln>&nbsp;514</ln><a id="514">&nbsp;</a><c24>the&nbsp;compiler&nbsp;does&nbsp;not&nbsp;prevent&nbsp;you&nbsp;from&nbsp;copying&nbsp;the&nbsp;pointer.&nbsp;&nbsp;This
</c24><br/><ln>&nbsp;515</ln><a id="515">&nbsp;</a><c24>implies&nbsp;that&nbsp;issuing&nbsp;restrictions&nbsp;is&nbsp;useless.&nbsp;We&nbsp;might&nbsp;prevent&nbsp;the
</c24><br/><ln>&nbsp;516</ln><a id="516">&nbsp;</a><c24>user&nbsp;from&nbsp;acting&nbsp;on&nbsp;`*LV`&nbsp;itself,&nbsp;but&nbsp;there&nbsp;could&nbsp;be&nbsp;another&nbsp;path
</c24><br/><ln>&nbsp;517</ln><a id="517">&nbsp;</a><c24>`*LV1`&nbsp;that&nbsp;refers&nbsp;to&nbsp;the&nbsp;exact&nbsp;same&nbsp;memory,&nbsp;and&nbsp;we&nbsp;would&nbsp;not&nbsp;be
</c24><br/><ln>&nbsp;518</ln><a id="518">&nbsp;</a><c24>restricting&nbsp;that&nbsp;path.&nbsp;Therefore,&nbsp;the&nbsp;rule&nbsp;for&nbsp;`&amp;Ty`&nbsp;and&nbsp;`@Ty`
</c24><br/><ln>&nbsp;519</ln><a id="519">&nbsp;</a><c24>pointers&nbsp;always&nbsp;returns&nbsp;an&nbsp;empty&nbsp;set&nbsp;of&nbsp;restrictions,&nbsp;and&nbsp;it&nbsp;only
</c24><br/><ln>&nbsp;520</ln><a id="520">&nbsp;</a><c24>permits&nbsp;restricting&nbsp;`MUTATE`&nbsp;and&nbsp;`CLAIM`&nbsp;actions:
</c24><br/><ln>&nbsp;521</ln><a id="521">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;522</ln><a id="522">&nbsp;</a><c24>&nbsp;&nbsp;&nbsp;&nbsp;RESTRICTIONS(*LV,&nbsp;ACTIONS)&nbsp;=&nbsp;[]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;R-Deref-Imm-Borrowed
</c24><br/><ln>&nbsp;523</ln><a id="523">&nbsp;</a><c24>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TYPE(LV)&nbsp;=&nbsp;&amp;Ty&nbsp;or&nbsp;@Ty
</c24><br/><ln>&nbsp;524</ln><a id="524">&nbsp;</a><c24>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ACTIONS&nbsp;subset&nbsp;of&nbsp;[MUTATE,&nbsp;CLAIM]
</c24><br/><ln>&nbsp;525</ln><a id="525">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;526</ln><a id="526">&nbsp;</a><c24>The&nbsp;reason&nbsp;that&nbsp;we&nbsp;can&nbsp;restrict&nbsp;`MUTATE`&nbsp;and&nbsp;`CLAIM`&nbsp;actions&nbsp;even
</c24><br/><ln>&nbsp;527</ln><a id="527">&nbsp;</a><c24>without&nbsp;a&nbsp;restrictions&nbsp;list&nbsp;is&nbsp;that&nbsp;it&nbsp;is&nbsp;never&nbsp;legal&nbsp;to&nbsp;mutate&nbsp;nor&nbsp;to
</c24><br/><ln>&nbsp;528</ln><a id="528">&nbsp;</a><c24>borrow&nbsp;mutably&nbsp;the&nbsp;contents&nbsp;of&nbsp;a&nbsp;`&amp;Ty`&nbsp;or&nbsp;`@Ty`&nbsp;pointer.&nbsp;In&nbsp;other
</c24><br/><ln>&nbsp;529</ln><a id="529">&nbsp;</a><c24>words,&nbsp;those&nbsp;restrictions&nbsp;are&nbsp;already&nbsp;inherent&nbsp;in&nbsp;the&nbsp;type.
</c24><br/><ln>&nbsp;530</ln><a id="530">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;531</ln><a id="531">&nbsp;</a><c24>Typically,&nbsp;this&nbsp;limitation&nbsp;is&nbsp;not&nbsp;an&nbsp;issue,&nbsp;because&nbsp;restrictions&nbsp;other
</c24><br/><ln>&nbsp;532</ln><a id="532">&nbsp;</a><c24>than&nbsp;`MUTATE`&nbsp;or&nbsp;`CLAIM`&nbsp;typically&nbsp;arise&nbsp;due&nbsp;to&nbsp;`&amp;mut`&nbsp;borrow,&nbsp;and&nbsp;as
</c24><br/><ln>&nbsp;533</ln><a id="533">&nbsp;</a><c24>we&nbsp;said,&nbsp;that&nbsp;is&nbsp;already&nbsp;illegal&nbsp;for&nbsp;`*LV`.&nbsp;However,&nbsp;there&nbsp;is&nbsp;one&nbsp;case
</c24><br/><ln>&nbsp;534</ln><a id="534">&nbsp;</a><c24>where&nbsp;we&nbsp;can&nbsp;be&nbsp;asked&nbsp;to&nbsp;enforce&nbsp;an&nbsp;`ALIAS`&nbsp;restriction&nbsp;on&nbsp;`*LV`,
</c24><br/><ln>&nbsp;535</ln><a id="535">&nbsp;</a><c24>which&nbsp;is&nbsp;when&nbsp;you&nbsp;have&nbsp;a&nbsp;type&nbsp;like&nbsp;`&amp;&amp;mut&nbsp;T`.&nbsp;In&nbsp;such&nbsp;cases&nbsp;we&nbsp;will
</c24><br/><ln>&nbsp;536</ln><a id="536">&nbsp;</a><c24>report&nbsp;an&nbsp;error&nbsp;because&nbsp;we&nbsp;cannot&nbsp;enforce&nbsp;a&nbsp;lack&nbsp;of&nbsp;aliases&nbsp;on&nbsp;a&nbsp;`&amp;Ty`
</c24><br/><ln>&nbsp;537</ln><a id="537">&nbsp;</a><c24>or&nbsp;`@Ty`&nbsp;type.&nbsp;That&nbsp;case&nbsp;is&nbsp;described&nbsp;in&nbsp;more&nbsp;detail&nbsp;in&nbsp;the&nbsp;section&nbsp;on
</c24><br/><ln>&nbsp;538</ln><a id="538">&nbsp;</a><c24>mutable&nbsp;borrowed&nbsp;pointers.
</c24><br/><ln>&nbsp;539</ln><a id="539">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;540</ln><a id="540">&nbsp;</a><c24>###&nbsp;Restrictions&nbsp;for&nbsp;loans&nbsp;of&nbsp;const&nbsp;aliasable&nbsp;pointees
</c24><br/><ln>&nbsp;541</ln><a id="541">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;542</ln><a id="542">&nbsp;</a><c24>Freeze&nbsp;pointers&nbsp;are&nbsp;read-only.&nbsp;There&nbsp;may&nbsp;be&nbsp;`&amp;mut`&nbsp;or&nbsp;`&amp;`&nbsp;aliases,&nbsp;and
</c24><br/><ln>&nbsp;543</ln><a id="543">&nbsp;</a><c24>we&nbsp;can&nbsp;not&nbsp;prevent&nbsp;*anything*&nbsp;but&nbsp;moves&nbsp;in&nbsp;that&nbsp;case.&nbsp;So&nbsp;the
</c24><br/><ln>&nbsp;544</ln><a id="544">&nbsp;</a><c24>`RESTRICTIONS`&nbsp;function&nbsp;is&nbsp;only&nbsp;defined&nbsp;if&nbsp;`ACTIONS`&nbsp;is&nbsp;the&nbsp;empty&nbsp;set.
</c24><br/><ln>&nbsp;545</ln><a id="545">&nbsp;</a><c24>Because&nbsp;moves&nbsp;from&nbsp;a&nbsp;`&amp;const`&nbsp;or&nbsp;`@const`&nbsp;lvalue&nbsp;are&nbsp;never&nbsp;legal,&nbsp;it
</c24><br/><ln>&nbsp;546</ln><a id="546">&nbsp;</a><c24>is&nbsp;not&nbsp;necessary&nbsp;to&nbsp;add&nbsp;any&nbsp;restrictions&nbsp;at&nbsp;all&nbsp;to&nbsp;the&nbsp;final
</c24><br/><ln>&nbsp;547</ln><a id="547">&nbsp;</a><c24>result.
</c24><br/><ln>&nbsp;548</ln><a id="548">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;549</ln><a id="549">&nbsp;</a><c24>&nbsp;&nbsp;&nbsp;&nbsp;RESTRICTIONS(*LV,&nbsp;[])&nbsp;=&nbsp;[]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;R-Deref-Freeze-Borrowed
</c24><br/><ln>&nbsp;550</ln><a id="550">&nbsp;</a><c24>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TYPE(LV)&nbsp;=&nbsp;&amp;const&nbsp;Ty&nbsp;or&nbsp;@const&nbsp;Ty
</c24><br/><ln>&nbsp;551</ln><a id="551">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;552</ln><a id="552">&nbsp;</a><c24>###&nbsp;Restrictions&nbsp;for&nbsp;loans&nbsp;of&nbsp;mutable&nbsp;borrowed&nbsp;pointees
</c24><br/><ln>&nbsp;553</ln><a id="553">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;554</ln><a id="554">&nbsp;</a><c24>Borrowing&nbsp;mutable&nbsp;borrowed&nbsp;pointees&nbsp;is&nbsp;a&nbsp;bit&nbsp;subtle&nbsp;because&nbsp;we&nbsp;permit
</c24><br/><ln>&nbsp;555</ln><a id="555">&nbsp;</a><c24>users&nbsp;to&nbsp;freeze&nbsp;or&nbsp;claim&nbsp;`&amp;mut`&nbsp;pointees.&nbsp;To&nbsp;see&nbsp;what&nbsp;I&nbsp;mean,&nbsp;consider&nbsp;this
</c24><br/><ln>&nbsp;556</ln><a id="556">&nbsp;</a><c24>(perfectly&nbsp;safe)&nbsp;code&nbsp;example:
</c24><br/><ln>&nbsp;557</ln><a id="557">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;558</ln><a id="558">&nbsp;</a><c24>&nbsp;&nbsp;&nbsp;&nbsp;fn&nbsp;foo(t0:&nbsp;&amp;mut&nbsp;T,&nbsp;op:&nbsp;fn(&amp;T))&nbsp;{
</c24><br/><ln>&nbsp;559</ln><a id="559">&nbsp;</a><c24>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;t1:&nbsp;&amp;T&nbsp;=&nbsp;&amp;*t0;&nbsp;//&nbsp;(1)
</c24><br/><ln>&nbsp;560</ln><a id="560">&nbsp;</a><c24>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;op(t1);
</c24><br/><ln>&nbsp;561</ln><a id="561">&nbsp;</a><c24>&nbsp;&nbsp;&nbsp;&nbsp;}
</c24><br/><ln>&nbsp;562</ln><a id="562">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;563</ln><a id="563">&nbsp;</a><c24>In&nbsp;the&nbsp;borrow&nbsp;marked&nbsp;`(1)`,&nbsp;the&nbsp;data&nbsp;at&nbsp;`*t0`&nbsp;is&nbsp;*frozen*&nbsp;as&nbsp;part&nbsp;of&nbsp;a
</c24><br/><ln>&nbsp;564</ln><a id="564">&nbsp;</a><c24>re-borrow.&nbsp;Therefore,&nbsp;for&nbsp;the&nbsp;lifetime&nbsp;of&nbsp;`t1`,&nbsp;`*t0`&nbsp;must&nbsp;not&nbsp;be
</c24><br/><ln>&nbsp;565</ln><a id="565">&nbsp;</a><c24>mutated.&nbsp;This&nbsp;is&nbsp;the&nbsp;same&nbsp;basic&nbsp;idea&nbsp;as&nbsp;when&nbsp;we&nbsp;freeze&nbsp;a&nbsp;mutable&nbsp;local
</c24><br/><ln>&nbsp;566</ln><a id="566">&nbsp;</a><c24>variable,&nbsp;but&nbsp;unlike&nbsp;in&nbsp;that&nbsp;case&nbsp;`t0`&nbsp;is&nbsp;a&nbsp;*pointer*&nbsp;to&nbsp;the&nbsp;data,&nbsp;and
</c24><br/><ln>&nbsp;567</ln><a id="567">&nbsp;</a><c24>thus&nbsp;we&nbsp;must&nbsp;enforce&nbsp;some&nbsp;subtle&nbsp;restrictions&nbsp;in&nbsp;order&nbsp;to&nbsp;guarantee
</c24><br/><ln>&nbsp;568</ln><a id="568">&nbsp;</a><c24>soundness.
</c24><br/><ln>&nbsp;569</ln><a id="569">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;570</ln><a id="570">&nbsp;</a><c24>Intuitively,&nbsp;we&nbsp;must&nbsp;ensure&nbsp;that&nbsp;`*t0`&nbsp;is&nbsp;the&nbsp;only&nbsp;*mutable*&nbsp;path&nbsp;to
</c24><br/><ln>&nbsp;571</ln><a id="571">&nbsp;</a><c24>reach&nbsp;the&nbsp;memory&nbsp;that&nbsp;was&nbsp;frozen.&nbsp;The&nbsp;reason&nbsp;that&nbsp;we&nbsp;are&nbsp;so&nbsp;concerned
</c24><br/><ln>&nbsp;572</ln><a id="572">&nbsp;</a><c24>with&nbsp;*mutable*&nbsp;paths&nbsp;is&nbsp;that&nbsp;those&nbsp;are&nbsp;the&nbsp;paths&nbsp;through&nbsp;which&nbsp;the
</c24><br/><ln>&nbsp;573</ln><a id="573">&nbsp;</a><c24>user&nbsp;could&nbsp;mutate&nbsp;the&nbsp;data&nbsp;that&nbsp;was&nbsp;frozen&nbsp;and&nbsp;hence&nbsp;invalidate&nbsp;the
</c24><br/><ln>&nbsp;574</ln><a id="574">&nbsp;</a><c24>`t1`&nbsp;pointer.&nbsp;Note&nbsp;that&nbsp;const&nbsp;aliases&nbsp;to&nbsp;`*t0`&nbsp;are&nbsp;acceptable&nbsp;(and&nbsp;in
</c24><br/><ln>&nbsp;575</ln><a id="575">&nbsp;</a><c24>fact&nbsp;we&nbsp;can't&nbsp;prevent&nbsp;them&nbsp;without&nbsp;unacceptable&nbsp;performance&nbsp;cost,&nbsp;more
</c24><br/><ln>&nbsp;576</ln><a id="576">&nbsp;</a><c24>on&nbsp;that&nbsp;later)&nbsp;because
</c24><br/><ln>&nbsp;577</ln><a id="577">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;578</ln><a id="578">&nbsp;</a><c24>There&nbsp;are&nbsp;two&nbsp;rules&nbsp;governing&nbsp;`&amp;mut`&nbsp;pointers,&nbsp;but&nbsp;we'll&nbsp;begin&nbsp;with
</c24><br/><ln>&nbsp;579</ln><a id="579">&nbsp;</a><c24>the&nbsp;first.&nbsp;This&nbsp;rule&nbsp;governs&nbsp;cases&nbsp;where&nbsp;we&nbsp;are&nbsp;attempting&nbsp;to&nbsp;prevent
</c24><br/><ln>&nbsp;580</ln><a id="580">&nbsp;</a><c24>an&nbsp;`&amp;mut`&nbsp;pointee&nbsp;from&nbsp;being&nbsp;mutated,&nbsp;claimed,&nbsp;or&nbsp;frozen,&nbsp;as&nbsp;occurs
</c24><br/><ln>&nbsp;581</ln><a id="581">&nbsp;</a><c24>whenever&nbsp;the&nbsp;`&amp;mut`&nbsp;pointee&nbsp;`*LV`&nbsp;is&nbsp;reborrowed&nbsp;as&nbsp;mutable&nbsp;or
</c24><br/><ln>&nbsp;582</ln><a id="582">&nbsp;</a><c24>immutable:
</c24><br/><ln>&nbsp;583</ln><a id="583">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;584</ln><a id="584">&nbsp;</a><c24>&nbsp;&nbsp;&nbsp;&nbsp;RESTRICTIONS(*LV,&nbsp;ACTIONS)&nbsp;=&nbsp;RS,&nbsp;(*LV,&nbsp;ACTIONS)&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;R-Deref-Mut-Borrowed-1
</c24><br/><ln>&nbsp;585</ln><a id="585">&nbsp;</a><c24>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TYPE(LV)&nbsp;=&nbsp;&amp;mut&nbsp;Ty
</c24><br/><ln>&nbsp;586</ln><a id="586">&nbsp;</a><c24>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RESTRICTIONS(LV,&nbsp;MUTATE|CLAIM|ALIAS)&nbsp;=&nbsp;RS
</c24><br/><ln>&nbsp;587</ln><a id="587">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;588</ln><a id="588">&nbsp;</a><c24>The&nbsp;main&nbsp;interesting&nbsp;part&nbsp;of&nbsp;the&nbsp;rule&nbsp;is&nbsp;the&nbsp;final&nbsp;line,&nbsp;which
</c24><br/><ln>&nbsp;589</ln><a id="589">&nbsp;</a><c24>requires&nbsp;that&nbsp;the&nbsp;`&amp;mut`&nbsp;*pointer*&nbsp;`LV`&nbsp;be&nbsp;restricted&nbsp;from&nbsp;being
</c24><br/><ln>&nbsp;590</ln><a id="590">&nbsp;</a><c24>mutated,&nbsp;claimed,&nbsp;or&nbsp;aliased.&nbsp;The&nbsp;goal&nbsp;of&nbsp;these&nbsp;restrictions&nbsp;is&nbsp;to
</c24><br/><ln>&nbsp;591</ln><a id="591">&nbsp;</a><c24>ensure&nbsp;that,&nbsp;not&nbsp;considering&nbsp;the&nbsp;pointer&nbsp;that&nbsp;will&nbsp;result&nbsp;from&nbsp;this
</c24><br/><ln>&nbsp;592</ln><a id="592">&nbsp;</a><c24>borrow,&nbsp;`LV`&nbsp;remains&nbsp;the&nbsp;*sole&nbsp;pointer&nbsp;with&nbsp;mutable&nbsp;access*&nbsp;to&nbsp;`*LV`.
</c24><br/><ln>&nbsp;593</ln><a id="593">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;594</ln><a id="594">&nbsp;</a><c24>Restrictions&nbsp;against&nbsp;mutations&nbsp;and&nbsp;claims&nbsp;are&nbsp;necessary&nbsp;because&nbsp;if&nbsp;the
</c24><br/><ln>&nbsp;595</ln><a id="595">&nbsp;</a><c24>pointer&nbsp;in&nbsp;`LV`&nbsp;were&nbsp;to&nbsp;be&nbsp;somehow&nbsp;copied&nbsp;or&nbsp;moved&nbsp;to&nbsp;a&nbsp;different
</c24><br/><ln>&nbsp;596</ln><a id="596">&nbsp;</a><c24>location,&nbsp;then&nbsp;the&nbsp;restriction&nbsp;issued&nbsp;for&nbsp;`*LV`&nbsp;would&nbsp;not&nbsp;apply&nbsp;to&nbsp;the
</c24><br/><ln>&nbsp;597</ln><a id="597">&nbsp;</a><c24>new&nbsp;location.&nbsp;Note&nbsp;that&nbsp;because&nbsp;`&amp;mut`&nbsp;values&nbsp;are&nbsp;non-copyable,&nbsp;a
</c24><br/><ln>&nbsp;598</ln><a id="598">&nbsp;</a><c24>simple&nbsp;attempt&nbsp;to&nbsp;move&nbsp;the&nbsp;base&nbsp;pointer&nbsp;will&nbsp;fail&nbsp;due&nbsp;to&nbsp;the
</c24><br/><ln>&nbsp;599</ln><a id="599">&nbsp;</a><c24>(implicit)&nbsp;restriction&nbsp;against&nbsp;moves:
</c24><br/><ln>&nbsp;600</ln><a id="600">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;601</ln><a id="601">&nbsp;</a><c24>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;src/test/compile-fail/borrowck-move-mut-base-ptr.rs
</c24><br/><ln>&nbsp;602</ln><a id="602">&nbsp;</a><c24>&nbsp;&nbsp;&nbsp;&nbsp;fn&nbsp;foo(t0:&nbsp;&amp;mut&nbsp;int)&nbsp;{
</c24><br/><ln>&nbsp;603</ln><a id="603">&nbsp;</a><c24>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;p:&nbsp;&amp;int&nbsp;=&nbsp;&amp;*t0;&nbsp;//&nbsp;Freezes&nbsp;`*t0`
</c24><br/><ln>&nbsp;604</ln><a id="604">&nbsp;</a><c24>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;t1&nbsp;=&nbsp;t0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//~&nbsp;ERROR&nbsp;cannot&nbsp;move&nbsp;out&nbsp;of&nbsp;`t0`
</c24><br/><ln>&nbsp;605</ln><a id="605">&nbsp;</a><c24>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*t1&nbsp;=&nbsp;22;
</c24><br/><ln>&nbsp;606</ln><a id="606">&nbsp;</a><c24>&nbsp;&nbsp;&nbsp;&nbsp;}
</c24><br/><ln>&nbsp;607</ln><a id="607">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;608</ln><a id="608">&nbsp;</a><c24>However,&nbsp;the&nbsp;additional&nbsp;restrictions&nbsp;against&nbsp;mutation&nbsp;mean&nbsp;that&nbsp;even&nbsp;a
</c24><br/><ln>&nbsp;609</ln><a id="609">&nbsp;</a><c24>clever&nbsp;attempt&nbsp;to&nbsp;use&nbsp;a&nbsp;swap&nbsp;to&nbsp;circumvent&nbsp;the&nbsp;type&nbsp;system&nbsp;will
</c24><br/><ln>&nbsp;610</ln><a id="610">&nbsp;</a><c24>encounter&nbsp;an&nbsp;error:
</c24><br/><ln>&nbsp;611</ln><a id="611">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;612</ln><a id="612">&nbsp;</a><c24>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;src/test/compile-fail/borrowck-swap-mut-base-ptr.rs
</c24><br/><ln>&nbsp;613</ln><a id="613">&nbsp;</a><c24>&nbsp;&nbsp;&nbsp;&nbsp;fn&nbsp;foo&lt;'a&gt;(mut&nbsp;t0:&nbsp;&amp;'a&nbsp;mut&nbsp;int,
</c24><br/><ln>&nbsp;614</ln><a id="614">&nbsp;</a><c24>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mut&nbsp;t1:&nbsp;&amp;'a&nbsp;mut&nbsp;int)&nbsp;{
</c24><br/><ln>&nbsp;615</ln><a id="615">&nbsp;</a><c24>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;p:&nbsp;&amp;int&nbsp;=&nbsp;&amp;*t0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Freezes&nbsp;`*t0`
</c24><br/><ln>&nbsp;616</ln><a id="616">&nbsp;</a><c24>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;swap(&amp;mut&nbsp;t0,&nbsp;&amp;mut&nbsp;t1);&nbsp;//~&nbsp;ERROR&nbsp;cannot&nbsp;borrow&nbsp;`t0`
</c24><br/><ln>&nbsp;617</ln><a id="617">&nbsp;</a><c24>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*t1&nbsp;=&nbsp;22;
</c24><br/><ln>&nbsp;618</ln><a id="618">&nbsp;</a><c24>&nbsp;&nbsp;&nbsp;&nbsp;}
</c24><br/><ln>&nbsp;619</ln><a id="619">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;620</ln><a id="620">&nbsp;</a><c24>The&nbsp;restriction&nbsp;against&nbsp;*aliasing*&nbsp;(and,&nbsp;in&nbsp;turn,&nbsp;freezing)&nbsp;is
</c24><br/><ln>&nbsp;621</ln><a id="621">&nbsp;</a><c24>necessary&nbsp;because,&nbsp;if&nbsp;an&nbsp;alias&nbsp;were&nbsp;of&nbsp;`LV`&nbsp;were&nbsp;to&nbsp;be&nbsp;produced,&nbsp;then
</c24><br/><ln>&nbsp;622</ln><a id="622">&nbsp;</a><c24>`LV`&nbsp;would&nbsp;no&nbsp;longer&nbsp;be&nbsp;the&nbsp;sole&nbsp;path&nbsp;to&nbsp;access&nbsp;the&nbsp;`&amp;mut`
</c24><br/><ln>&nbsp;623</ln><a id="623">&nbsp;</a><c24>pointee.&nbsp;Since&nbsp;we&nbsp;are&nbsp;only&nbsp;issuing&nbsp;restrictions&nbsp;against&nbsp;`*LV`,&nbsp;these
</c24><br/><ln>&nbsp;624</ln><a id="624">&nbsp;</a><c24>other&nbsp;aliases&nbsp;would&nbsp;be&nbsp;unrestricted,&nbsp;and&nbsp;the&nbsp;result&nbsp;would&nbsp;be
</c24><br/><ln>&nbsp;625</ln><a id="625">&nbsp;</a><c24>unsound.&nbsp;For&nbsp;example:
</c24><br/><ln>&nbsp;626</ln><a id="626">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;627</ln><a id="627">&nbsp;</a><c24>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;src/test/compile-fail/borrowck-alias-mut-base-ptr.rs
</c24><br/><ln>&nbsp;628</ln><a id="628">&nbsp;</a><c24>&nbsp;&nbsp;&nbsp;&nbsp;fn&nbsp;foo(t0:&nbsp;&amp;mut&nbsp;int)&nbsp;{
</c24><br/><ln>&nbsp;629</ln><a id="629">&nbsp;</a><c24>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;p:&nbsp;&amp;int&nbsp;=&nbsp;&amp;*t0;&nbsp;//&nbsp;Freezes&nbsp;`*t0`
</c24><br/><ln>&nbsp;630</ln><a id="630">&nbsp;</a><c24>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;q:&nbsp;&amp;const&nbsp;&amp;mut&nbsp;int&nbsp;=&nbsp;&amp;const&nbsp;t0;&nbsp;//~&nbsp;ERROR&nbsp;cannot&nbsp;borrow&nbsp;`t0`
</c24><br/><ln>&nbsp;631</ln><a id="631">&nbsp;</a><c24>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**q&nbsp;=&nbsp;22;&nbsp;//&nbsp;(*)
</c24><br/><ln>&nbsp;632</ln><a id="632">&nbsp;</a><c24>&nbsp;&nbsp;&nbsp;&nbsp;}
</c24><br/><ln>&nbsp;633</ln><a id="633">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;634</ln><a id="634">&nbsp;</a><c24>Note&nbsp;that&nbsp;the&nbsp;current&nbsp;rules&nbsp;also&nbsp;report&nbsp;an&nbsp;error&nbsp;at&nbsp;the&nbsp;assignment&nbsp;in
</c24><br/><ln>&nbsp;635</ln><a id="635">&nbsp;</a><c24>`(*)`,&nbsp;because&nbsp;we&nbsp;only&nbsp;permit&nbsp;`&amp;mut`&nbsp;poiners&nbsp;to&nbsp;be&nbsp;assigned&nbsp;if&nbsp;they
</c24><br/><ln>&nbsp;636</ln><a id="636">&nbsp;</a><c24>are&nbsp;located&nbsp;in&nbsp;a&nbsp;non-aliasable&nbsp;location.&nbsp;However,&nbsp;I&nbsp;do&nbsp;not&nbsp;believe
</c24><br/><ln>&nbsp;637</ln><a id="637">&nbsp;</a><c24>this&nbsp;restriction&nbsp;is&nbsp;strictly&nbsp;necessary.&nbsp;It&nbsp;was&nbsp;added,&nbsp;I&nbsp;believe,&nbsp;to
</c24><br/><ln>&nbsp;638</ln><a id="638">&nbsp;</a><c24>discourage&nbsp;`&amp;mut`&nbsp;from&nbsp;being&nbsp;placed&nbsp;in&nbsp;aliasable&nbsp;locations&nbsp;in&nbsp;the
</c24><br/><ln>&nbsp;639</ln><a id="639">&nbsp;</a><c24>first&nbsp;place.&nbsp;One&nbsp;(desirable)&nbsp;side-effect&nbsp;of&nbsp;restricting&nbsp;aliasing&nbsp;on
</c24><br/><ln>&nbsp;640</ln><a id="640">&nbsp;</a><c24>`LV`&nbsp;is&nbsp;that&nbsp;borrowing&nbsp;an&nbsp;`&amp;mut`&nbsp;pointee&nbsp;found&nbsp;inside&nbsp;an&nbsp;aliasable
</c24><br/><ln>&nbsp;641</ln><a id="641">&nbsp;</a><c24>pointee&nbsp;yields&nbsp;an&nbsp;error:
</c24><br/><ln>&nbsp;642</ln><a id="642">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;643</ln><a id="643">&nbsp;</a><c24>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;src/test/compile-fail/borrowck-borrow-mut-base-ptr-in-aliasable-loc:
</c24><br/><ln>&nbsp;644</ln><a id="644">&nbsp;</a><c24>&nbsp;&nbsp;&nbsp;&nbsp;fn&nbsp;foo(t0:&nbsp;&amp;&nbsp;&amp;mut&nbsp;int)&nbsp;{
</c24><br/><ln>&nbsp;645</ln><a id="645">&nbsp;</a><c24>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;t1&nbsp;=&nbsp;t0;
</c24><br/><ln>&nbsp;646</ln><a id="646">&nbsp;</a><c24>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;p:&nbsp;&amp;int&nbsp;=&nbsp;&amp;**t0;&nbsp;//~&nbsp;ERROR&nbsp;cannot&nbsp;borrow&nbsp;an&nbsp;`&amp;mut`&nbsp;in&nbsp;a&nbsp;`&amp;`&nbsp;pointer
</c24><br/><ln>&nbsp;647</ln><a id="647">&nbsp;</a><c24>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**t1&nbsp;=&nbsp;22;&nbsp;//&nbsp;(*)
</c24><br/><ln>&nbsp;648</ln><a id="648">&nbsp;</a><c24>&nbsp;&nbsp;&nbsp;&nbsp;}
</c24><br/><ln>&nbsp;649</ln><a id="649">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;650</ln><a id="650">&nbsp;</a><c24>Here&nbsp;at&nbsp;the&nbsp;line&nbsp;`(*)`&nbsp;you&nbsp;will&nbsp;also&nbsp;see&nbsp;the&nbsp;error&nbsp;I&nbsp;referred&nbsp;to
</c24><br/><ln>&nbsp;651</ln><a id="651">&nbsp;</a><c24>above,&nbsp;which&nbsp;I&nbsp;do&nbsp;not&nbsp;believe&nbsp;is&nbsp;strictly&nbsp;necessary.
</c24><br/><ln>&nbsp;652</ln><a id="652">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;653</ln><a id="653">&nbsp;</a><c24>The&nbsp;second&nbsp;rule&nbsp;for&nbsp;`&amp;mut`&nbsp;handles&nbsp;the&nbsp;case&nbsp;where&nbsp;we&nbsp;are&nbsp;not&nbsp;adding
</c24><br/><ln>&nbsp;654</ln><a id="654">&nbsp;</a><c24>any&nbsp;restrictions&nbsp;(beyond&nbsp;the&nbsp;default&nbsp;of&nbsp;"no&nbsp;move"):
</c24><br/><ln>&nbsp;655</ln><a id="655">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;656</ln><a id="656">&nbsp;</a><c24>&nbsp;&nbsp;&nbsp;&nbsp;RESTRICTIONS(*LV,&nbsp;[])&nbsp;=&nbsp;[]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;R-Deref-Mut-Borrowed-2
</c24><br/><ln>&nbsp;657</ln><a id="657">&nbsp;</a><c24>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TYPE(LV)&nbsp;=&nbsp;&amp;mut&nbsp;Ty
</c24><br/><ln>&nbsp;658</ln><a id="658">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;659</ln><a id="659">&nbsp;</a><c24>Moving&nbsp;from&nbsp;an&nbsp;`&amp;mut`&nbsp;pointee&nbsp;is&nbsp;never&nbsp;legal,&nbsp;so&nbsp;no&nbsp;special
</c24><br/><ln>&nbsp;660</ln><a id="660">&nbsp;</a><c24>restrictions&nbsp;are&nbsp;needed.
</c24><br/><ln>&nbsp;661</ln><a id="661">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;662</ln><a id="662">&nbsp;</a><c24>###&nbsp;Restrictions&nbsp;for&nbsp;loans&nbsp;of&nbsp;mutable&nbsp;managed&nbsp;pointees
</c24><br/><ln>&nbsp;663</ln><a id="663">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;664</ln><a id="664">&nbsp;</a><c24>With&nbsp;`@mut`&nbsp;pointees,&nbsp;we&nbsp;don't&nbsp;make&nbsp;any&nbsp;static&nbsp;guarantees.&nbsp;&nbsp;But&nbsp;as&nbsp;a
</c24><br/><ln>&nbsp;665</ln><a id="665">&nbsp;</a><c24>convenience,&nbsp;we&nbsp;still&nbsp;register&nbsp;a&nbsp;restriction&nbsp;against&nbsp;`*LV`,&nbsp;because
</c24><br/><ln>&nbsp;666</ln><a id="666">&nbsp;</a><c24>that&nbsp;way&nbsp;if&nbsp;we&nbsp;*can*&nbsp;find&nbsp;a&nbsp;simple&nbsp;static&nbsp;error,&nbsp;we&nbsp;will:
</c24><br/><ln>&nbsp;667</ln><a id="667">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;668</ln><a id="668">&nbsp;</a><c24>&nbsp;&nbsp;&nbsp;&nbsp;RESTRICTIONS(*LV,&nbsp;ACTIONS)&nbsp;=&nbsp;[*LV,&nbsp;ACTIONS]&nbsp;&nbsp;&nbsp;//&nbsp;R-Deref-Managed-Borrowed
</c24><br/><ln>&nbsp;669</ln><a id="669">&nbsp;</a><c24>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TYPE(LV)&nbsp;=&nbsp;@mut&nbsp;Ty
</c24><br/><ln>&nbsp;670</ln><a id="670">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;671</ln><a id="671">&nbsp;</a><c24>#&nbsp;Moves&nbsp;and&nbsp;initialization
</c24><br/><ln>&nbsp;672</ln><a id="672">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;673</ln><a id="673">&nbsp;</a><c24>The&nbsp;borrow&nbsp;checker&nbsp;is&nbsp;also&nbsp;in&nbsp;charge&nbsp;of&nbsp;ensuring&nbsp;that:
</c24><br/><ln>&nbsp;674</ln><a id="674">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;675</ln><a id="675">&nbsp;</a><c24>-&nbsp;all&nbsp;memory&nbsp;which&nbsp;is&nbsp;accessed&nbsp;is&nbsp;initialized
</c24><br/><ln>&nbsp;676</ln><a id="676">&nbsp;</a><c24>-&nbsp;immutable&nbsp;local&nbsp;variables&nbsp;are&nbsp;assigned&nbsp;at&nbsp;most&nbsp;once.
</c24><br/><ln>&nbsp;677</ln><a id="677">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;678</ln><a id="678">&nbsp;</a><c24>These&nbsp;are&nbsp;two&nbsp;separate&nbsp;dataflow&nbsp;analyses&nbsp;built&nbsp;on&nbsp;the&nbsp;same
</c24><br/><ln>&nbsp;679</ln><a id="679">&nbsp;</a><c24>framework.&nbsp;Let's&nbsp;look&nbsp;at&nbsp;checking&nbsp;that&nbsp;memory&nbsp;is&nbsp;initialized&nbsp;first;
</c24><br/><ln>&nbsp;680</ln><a id="680">&nbsp;</a><c24>the&nbsp;checking&nbsp;of&nbsp;immutable&nbsp;local&nbsp;variabe&nbsp;assignments&nbsp;works&nbsp;in&nbsp;a&nbsp;very
</c24><br/><ln>&nbsp;681</ln><a id="681">&nbsp;</a><c24>similar&nbsp;way.
</c24><br/><ln>&nbsp;682</ln><a id="682">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;683</ln><a id="683">&nbsp;</a><c24>To&nbsp;track&nbsp;the&nbsp;initialization&nbsp;of&nbsp;memory,&nbsp;we&nbsp;actually&nbsp;track&nbsp;all&nbsp;the
</c24><br/><ln>&nbsp;684</ln><a id="684">&nbsp;</a><c24>points&nbsp;in&nbsp;the&nbsp;program&nbsp;that&nbsp;*create&nbsp;uninitialized&nbsp;memory*,&nbsp;meaning
</c24><br/><ln>&nbsp;685</ln><a id="685">&nbsp;</a><c24>moves&nbsp;and&nbsp;the&nbsp;declaration&nbsp;of&nbsp;uninitialized&nbsp;variables.&nbsp;For&nbsp;each&nbsp;of
</c24><br/><ln>&nbsp;686</ln><a id="686">&nbsp;</a><c24>these&nbsp;points,&nbsp;we&nbsp;create&nbsp;a&nbsp;bit&nbsp;in&nbsp;the&nbsp;dataflow&nbsp;set.&nbsp;Assignments&nbsp;to&nbsp;a
</c24><br/><ln>&nbsp;687</ln><a id="687">&nbsp;</a><c24>variable&nbsp;`x`&nbsp;or&nbsp;path&nbsp;`a.b.c`&nbsp;kill&nbsp;the&nbsp;move/uninitialization&nbsp;bits&nbsp;for
</c24><br/><ln>&nbsp;688</ln><a id="688">&nbsp;</a><c24>those&nbsp;paths&nbsp;and&nbsp;any&nbsp;subpaths&nbsp;(e.g.,&nbsp;`x`,&nbsp;`x.y`,&nbsp;`a.b.c`,&nbsp;`*a.b.c`).
</c24><br/><ln>&nbsp;689</ln><a id="689">&nbsp;</a><c24>The&nbsp;bits&nbsp;are&nbsp;also&nbsp;killed&nbsp;when&nbsp;the&nbsp;root&nbsp;variables&nbsp;(`x`,&nbsp;`a`)&nbsp;go&nbsp;out&nbsp;of
</c24><br/><ln>&nbsp;690</ln><a id="690">&nbsp;</a><c24>scope.&nbsp;Bits&nbsp;are&nbsp;unioned&nbsp;when&nbsp;two&nbsp;control-flow&nbsp;paths&nbsp;join.&nbsp;Thus,&nbsp;the
</c24><br/><ln>&nbsp;691</ln><a id="691">&nbsp;</a><c24>presence&nbsp;of&nbsp;a&nbsp;bit&nbsp;indicates&nbsp;that&nbsp;the&nbsp;move&nbsp;may&nbsp;have&nbsp;occurred&nbsp;without&nbsp;an
</c24><br/><ln>&nbsp;692</ln><a id="692">&nbsp;</a><c24>intervening&nbsp;assignment&nbsp;to&nbsp;the&nbsp;same&nbsp;memory.&nbsp;At&nbsp;each&nbsp;use&nbsp;of&nbsp;a&nbsp;variable,
</c24><br/><ln>&nbsp;693</ln><a id="693">&nbsp;</a><c24>we&nbsp;examine&nbsp;the&nbsp;bits&nbsp;in&nbsp;scope,&nbsp;and&nbsp;check&nbsp;that&nbsp;none&nbsp;of&nbsp;them&nbsp;are
</c24><br/><ln>&nbsp;694</ln><a id="694">&nbsp;</a><c24>moves/uninitializations&nbsp;of&nbsp;the&nbsp;variable&nbsp;that&nbsp;is&nbsp;being&nbsp;used.
</c24><br/><ln>&nbsp;695</ln><a id="695">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;696</ln><a id="696">&nbsp;</a><c24>Let's&nbsp;look&nbsp;at&nbsp;a&nbsp;simple&nbsp;example:
</c24><br/><ln>&nbsp;697</ln><a id="697">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;698</ln><a id="698">&nbsp;</a><c24>&nbsp;&nbsp;&nbsp;&nbsp;fn&nbsp;foo(a:&nbsp;~int)&nbsp;{
</c24><br/><ln>&nbsp;699</ln><a id="699">&nbsp;</a><c24>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;b:&nbsp;~int;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Gen&nbsp;bit&nbsp;0.
</c24><br/><ln>&nbsp;700</ln><a id="700">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;701</ln><a id="701">&nbsp;</a><c24>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;cond&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Bits:&nbsp;0
</c24><br/><ln>&nbsp;702</ln><a id="702">&nbsp;</a><c24>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;use(&amp;*a);
</c24><br/><ln>&nbsp;703</ln><a id="703">&nbsp;</a><c24>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b&nbsp;=&nbsp;a;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Gen&nbsp;bit&nbsp;1,&nbsp;kill&nbsp;bit&nbsp;0.
</c24><br/><ln>&nbsp;704</ln><a id="704">&nbsp;</a><c24>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;use(&amp;*b);
</c24><br/><ln>&nbsp;705</ln><a id="705">&nbsp;</a><c24>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;else&nbsp;{
</c24><br/><ln>&nbsp;706</ln><a id="706">&nbsp;</a><c24>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Bits:&nbsp;0
</c24><br/><ln>&nbsp;707</ln><a id="707">&nbsp;</a><c24>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
</c24><br/><ln>&nbsp;708</ln><a id="708">&nbsp;</a><c24>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Bits:&nbsp;0,1
</c24><br/><ln>&nbsp;709</ln><a id="709">&nbsp;</a><c24>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;use(&amp;*a);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Error.
</c24><br/><ln>&nbsp;710</ln><a id="710">&nbsp;</a><c24>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;use(&amp;*b);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Error.
</c24><br/><ln>&nbsp;711</ln><a id="711">&nbsp;</a><c24>&nbsp;&nbsp;&nbsp;&nbsp;}
</c24><br/><ln>&nbsp;712</ln><a id="712">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;713</ln><a id="713">&nbsp;</a><c24>&nbsp;&nbsp;&nbsp;&nbsp;fn&nbsp;use(a:&nbsp;&amp;int)&nbsp;{&nbsp;}
</c24><br/><ln>&nbsp;714</ln><a id="714">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;715</ln><a id="715">&nbsp;</a><c24>In&nbsp;this&nbsp;example,&nbsp;the&nbsp;variable&nbsp;`b`&nbsp;is&nbsp;created&nbsp;uninitialized.&nbsp;In&nbsp;one
</c24><br/><ln>&nbsp;716</ln><a id="716">&nbsp;</a><c24>branch&nbsp;of&nbsp;an&nbsp;`if`,&nbsp;we&nbsp;then&nbsp;move&nbsp;the&nbsp;variable&nbsp;`a`&nbsp;into&nbsp;`b`.&nbsp;Once&nbsp;we
</c24><br/><ln>&nbsp;717</ln><a id="717">&nbsp;</a><c24>exit&nbsp;the&nbsp;`if`,&nbsp;therefore,&nbsp;it&nbsp;is&nbsp;an&nbsp;error&nbsp;to&nbsp;use&nbsp;`a`&nbsp;or&nbsp;`b`&nbsp;since&nbsp;both
</c24><br/><ln>&nbsp;718</ln><a id="718">&nbsp;</a><c24>are&nbsp;only&nbsp;conditionally&nbsp;initialized.&nbsp;I&nbsp;have&nbsp;annotated&nbsp;the&nbsp;dataflow
</c24><br/><ln>&nbsp;719</ln><a id="719">&nbsp;</a><c24>state&nbsp;using&nbsp;comments.&nbsp;There&nbsp;are&nbsp;two&nbsp;dataflow&nbsp;bits,&nbsp;with&nbsp;bit&nbsp;0
</c24><br/><ln>&nbsp;720</ln><a id="720">&nbsp;</a><c24>corresponding&nbsp;to&nbsp;the&nbsp;creation&nbsp;of&nbsp;`b`&nbsp;without&nbsp;an&nbsp;initializer,&nbsp;and&nbsp;bit&nbsp;1
</c24><br/><ln>&nbsp;721</ln><a id="721">&nbsp;</a><c24>corresponding&nbsp;to&nbsp;the&nbsp;move&nbsp;of&nbsp;`a`.&nbsp;The&nbsp;assignment&nbsp;`b&nbsp;=&nbsp;a`&nbsp;both
</c24><br/><ln>&nbsp;722</ln><a id="722">&nbsp;</a><c24>generates&nbsp;bit&nbsp;1,&nbsp;because&nbsp;it&nbsp;is&nbsp;a&nbsp;move&nbsp;of&nbsp;`a`,&nbsp;and&nbsp;kills&nbsp;bit&nbsp;0,&nbsp;because
</c24><br/><ln>&nbsp;723</ln><a id="723">&nbsp;</a><c24>`b`&nbsp;is&nbsp;now&nbsp;initialized.&nbsp;On&nbsp;the&nbsp;else&nbsp;branch,&nbsp;though,&nbsp;`b`&nbsp;is&nbsp;never
</c24><br/><ln>&nbsp;724</ln><a id="724">&nbsp;</a><c24>initialized,&nbsp;and&nbsp;so&nbsp;bit&nbsp;0&nbsp;remains&nbsp;untouched.&nbsp;When&nbsp;the&nbsp;two&nbsp;flows&nbsp;of
</c24><br/><ln>&nbsp;725</ln><a id="725">&nbsp;</a><c24>control&nbsp;join,&nbsp;we&nbsp;union&nbsp;the&nbsp;bits&nbsp;from&nbsp;both&nbsp;sides,&nbsp;resulting&nbsp;in&nbsp;both
</c24><br/><ln>&nbsp;726</ln><a id="726">&nbsp;</a><c24>bits&nbsp;0&nbsp;and&nbsp;1&nbsp;being&nbsp;set.&nbsp;Thus&nbsp;any&nbsp;attempt&nbsp;to&nbsp;use&nbsp;`a`&nbsp;uncovers&nbsp;the&nbsp;bit&nbsp;1
</c24><br/><ln>&nbsp;727</ln><a id="727">&nbsp;</a><c24>from&nbsp;the&nbsp;"then"&nbsp;branch,&nbsp;showing&nbsp;that&nbsp;`a`&nbsp;may&nbsp;be&nbsp;moved,&nbsp;and&nbsp;any&nbsp;attempt
</c24><br/><ln>&nbsp;728</ln><a id="728">&nbsp;</a><c24>to&nbsp;use&nbsp;`b`&nbsp;uncovers&nbsp;bit&nbsp;0,&nbsp;from&nbsp;the&nbsp;"else"&nbsp;branch,&nbsp;showing&nbsp;that&nbsp;`b`
</c24><br/><ln>&nbsp;729</ln><a id="729">&nbsp;</a><c24>may&nbsp;not&nbsp;be&nbsp;initialized.
</c24><br/><ln>&nbsp;730</ln><a id="730">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;731</ln><a id="731">&nbsp;</a><c24>##&nbsp;Initialization&nbsp;of&nbsp;immutable&nbsp;variables
</c24><br/><ln>&nbsp;732</ln><a id="732">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;733</ln><a id="733">&nbsp;</a><c24>Initialization&nbsp;of&nbsp;immutable&nbsp;variables&nbsp;works&nbsp;in&nbsp;a&nbsp;very&nbsp;similar&nbsp;way,
</c24><br/><ln>&nbsp;734</ln><a id="734">&nbsp;</a><c24>except&nbsp;that:
</c24><br/><ln>&nbsp;735</ln><a id="735">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;736</ln><a id="736">&nbsp;</a><c24>1.&nbsp;we&nbsp;generate&nbsp;bits&nbsp;for&nbsp;each&nbsp;assignment&nbsp;to&nbsp;a&nbsp;variable;
</c24><br/><ln>&nbsp;737</ln><a id="737">&nbsp;</a><c24>2.&nbsp;the&nbsp;bits&nbsp;are&nbsp;never&nbsp;killed&nbsp;except&nbsp;when&nbsp;the&nbsp;variable&nbsp;goes&nbsp;out&nbsp;of&nbsp;scope.
</c24><br/><ln>&nbsp;738</ln><a id="738">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;739</ln><a id="739">&nbsp;</a><c24>Thus&nbsp;the&nbsp;presence&nbsp;of&nbsp;an&nbsp;assignment&nbsp;bit&nbsp;indicates&nbsp;that&nbsp;the&nbsp;assignment
</c24><br/><ln>&nbsp;740</ln><a id="740">&nbsp;</a><c24>may&nbsp;have&nbsp;occurred.&nbsp;Note&nbsp;that&nbsp;assignments&nbsp;are&nbsp;only&nbsp;killed&nbsp;when&nbsp;the
</c24><br/><ln>&nbsp;741</ln><a id="741">&nbsp;</a><c24>variable&nbsp;goes&nbsp;out&nbsp;of&nbsp;scope,&nbsp;as&nbsp;it&nbsp;is&nbsp;not&nbsp;relevant&nbsp;whether&nbsp;or&nbsp;not&nbsp;there
</c24><br/><ln>&nbsp;742</ln><a id="742">&nbsp;</a><c24>has&nbsp;been&nbsp;a&nbsp;move&nbsp;in&nbsp;the&nbsp;meantime.&nbsp;Using&nbsp;these&nbsp;bits,&nbsp;we&nbsp;can&nbsp;declare&nbsp;that
</c24><br/><ln>&nbsp;743</ln><a id="743">&nbsp;</a><c24>an&nbsp;assignment&nbsp;to&nbsp;an&nbsp;immutable&nbsp;variable&nbsp;is&nbsp;legal&nbsp;iff&nbsp;there&nbsp;is&nbsp;no&nbsp;other
</c24><br/><ln>&nbsp;744</ln><a id="744">&nbsp;</a><c24>assignment&nbsp;bit&nbsp;to&nbsp;that&nbsp;same&nbsp;variable&nbsp;in&nbsp;scope.
</c24><br/><ln>&nbsp;745</ln><a id="745">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;746</ln><a id="746">&nbsp;</a><c24>##&nbsp;Why&nbsp;is&nbsp;the&nbsp;design&nbsp;made&nbsp;this&nbsp;way?
</c24><br/><ln>&nbsp;747</ln><a id="747">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;748</ln><a id="748">&nbsp;</a><c24>It&nbsp;may&nbsp;seem&nbsp;surprising&nbsp;that&nbsp;we&nbsp;assign&nbsp;dataflow&nbsp;bits&nbsp;to&nbsp;*each&nbsp;move*
</c24><br/><ln>&nbsp;749</ln><a id="749">&nbsp;</a><c24>rather&nbsp;than&nbsp;*each&nbsp;path&nbsp;being&nbsp;moved*.&nbsp;This&nbsp;is&nbsp;somewhat&nbsp;less&nbsp;efficient,
</c24><br/><ln>&nbsp;750</ln><a id="750">&nbsp;</a><c24>since&nbsp;on&nbsp;each&nbsp;use,&nbsp;we&nbsp;must&nbsp;iterate&nbsp;through&nbsp;all&nbsp;moves&nbsp;and&nbsp;check&nbsp;whether
</c24><br/><ln>&nbsp;751</ln><a id="751">&nbsp;</a><c24>any&nbsp;of&nbsp;them&nbsp;correspond&nbsp;to&nbsp;the&nbsp;path&nbsp;in&nbsp;question.&nbsp;Similar&nbsp;concerns&nbsp;apply
</c24><br/><ln>&nbsp;752</ln><a id="752">&nbsp;</a><c24>to&nbsp;the&nbsp;analysis&nbsp;for&nbsp;double&nbsp;assignments&nbsp;to&nbsp;immutable&nbsp;variables.&nbsp;The
</c24><br/><ln>&nbsp;753</ln><a id="753">&nbsp;</a><c24>main&nbsp;reason&nbsp;to&nbsp;do&nbsp;it&nbsp;this&nbsp;way&nbsp;is&nbsp;that&nbsp;it&nbsp;allows&nbsp;us&nbsp;to&nbsp;print&nbsp;better
</c24><br/><ln>&nbsp;754</ln><a id="754">&nbsp;</a><c24>error&nbsp;messages,&nbsp;because&nbsp;when&nbsp;a&nbsp;use&nbsp;occurs,&nbsp;we&nbsp;can&nbsp;print&nbsp;out&nbsp;the
</c24><br/><ln>&nbsp;755</ln><a id="755">&nbsp;</a><c24>precise&nbsp;move&nbsp;that&nbsp;may&nbsp;be&nbsp;in&nbsp;scope,&nbsp;rather&nbsp;than&nbsp;simply&nbsp;having&nbsp;to&nbsp;say
</c24><br/><ln>&nbsp;756</ln><a id="756">&nbsp;</a><c24>"the&nbsp;variable&nbsp;may&nbsp;not&nbsp;be&nbsp;initialized".
</c24><br/><ln>&nbsp;757</ln><a id="757">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;758</ln><a id="758">&nbsp;</a><c24>##&nbsp;Data&nbsp;structures&nbsp;used&nbsp;in&nbsp;the&nbsp;move&nbsp;analysis
</c24><br/><ln>&nbsp;759</ln><a id="759">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;760</ln><a id="760">&nbsp;</a><c24>The&nbsp;move&nbsp;analysis&nbsp;maintains&nbsp;several&nbsp;data&nbsp;structures&nbsp;that&nbsp;enable&nbsp;it&nbsp;to
</c24><br/><ln>&nbsp;761</ln><a id="761">&nbsp;</a><c24>cross-reference&nbsp;moves&nbsp;and&nbsp;assignments&nbsp;to&nbsp;determine&nbsp;when&nbsp;they&nbsp;may&nbsp;be
</c24><br/><ln>&nbsp;762</ln><a id="762">&nbsp;</a><c24>moving/assigning&nbsp;the&nbsp;same&nbsp;memory.&nbsp;These&nbsp;are&nbsp;all&nbsp;collected&nbsp;into&nbsp;the
</c24><br/><ln>&nbsp;763</ln><a id="763">&nbsp;</a><c24>`MoveData`&nbsp;and&nbsp;`FlowedMoveData`&nbsp;structs.&nbsp;The&nbsp;former&nbsp;represents&nbsp;the&nbsp;set
</c24><br/><ln>&nbsp;764</ln><a id="764">&nbsp;</a><c24>of&nbsp;move&nbsp;paths,&nbsp;moves,&nbsp;and&nbsp;assignments,&nbsp;and&nbsp;the&nbsp;latter&nbsp;adds&nbsp;in&nbsp;the
</c24><br/><ln>&nbsp;765</ln><a id="765">&nbsp;</a><c24>results&nbsp;of&nbsp;a&nbsp;dataflow&nbsp;computation.
</c24><br/><ln>&nbsp;766</ln><a id="766">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;767</ln><a id="767">&nbsp;</a><c24>###&nbsp;Move&nbsp;paths
</c24><br/><ln>&nbsp;768</ln><a id="768">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;769</ln><a id="769">&nbsp;</a><c24>The&nbsp;`MovePath`&nbsp;tree&nbsp;tracks&nbsp;every&nbsp;path&nbsp;that&nbsp;is&nbsp;moved&nbsp;or&nbsp;assigned&nbsp;to.
</c24><br/><ln>&nbsp;770</ln><a id="770">&nbsp;</a><c24>These&nbsp;paths&nbsp;have&nbsp;the&nbsp;same&nbsp;form&nbsp;as&nbsp;the&nbsp;`LoanPath`&nbsp;data&nbsp;structure,&nbsp;which
</c24><br/><ln>&nbsp;771</ln><a id="771">&nbsp;</a><c24>in&nbsp;turn&nbsp;is&nbsp;the&nbsp;"real&nbsp;world&nbsp;version&nbsp;of&nbsp;the&nbsp;lvalues&nbsp;`LV`&nbsp;that&nbsp;we
</c24><br/><ln>&nbsp;772</ln><a id="772">&nbsp;</a><c24>introduced&nbsp;earlier.&nbsp;The&nbsp;difference&nbsp;between&nbsp;a&nbsp;`MovePath`&nbsp;and&nbsp;a&nbsp;`LoanPath`
</c24><br/><ln>&nbsp;773</ln><a id="773">&nbsp;</a><c24>is&nbsp;that&nbsp;move&nbsp;paths&nbsp;are:
</c24><br/><ln>&nbsp;774</ln><a id="774">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;775</ln><a id="775">&nbsp;</a><c24>1.&nbsp;Canonicalized,&nbsp;so&nbsp;that&nbsp;we&nbsp;have&nbsp;exactly&nbsp;one&nbsp;copy&nbsp;of&nbsp;each,&nbsp;and
</c24><br/><ln>&nbsp;776</ln><a id="776">&nbsp;</a><c24>&nbsp;&nbsp;&nbsp;we&nbsp;can&nbsp;refer&nbsp;to&nbsp;move&nbsp;paths&nbsp;by&nbsp;index;
</c24><br/><ln>&nbsp;777</ln><a id="777">&nbsp;</a><c24>2.&nbsp;Cross-referenced&nbsp;with&nbsp;other&nbsp;paths&nbsp;into&nbsp;a&nbsp;tree,&nbsp;so&nbsp;that&nbsp;given&nbsp;a&nbsp;move
</c24><br/><ln>&nbsp;778</ln><a id="778">&nbsp;</a><c24>&nbsp;&nbsp;&nbsp;path&nbsp;we&nbsp;can&nbsp;efficiently&nbsp;find&nbsp;all&nbsp;parent&nbsp;move&nbsp;paths&nbsp;and&nbsp;all
</c24><br/><ln>&nbsp;779</ln><a id="779">&nbsp;</a><c24>&nbsp;&nbsp;&nbsp;extensions&nbsp;(e.g.,&nbsp;given&nbsp;the&nbsp;`a.b`&nbsp;move&nbsp;path,&nbsp;we&nbsp;can&nbsp;easily&nbsp;find&nbsp;the
</c24><br/><ln>&nbsp;780</ln><a id="780">&nbsp;</a><c24>&nbsp;&nbsp;&nbsp;move&nbsp;path&nbsp;`a`&nbsp;and&nbsp;also&nbsp;the&nbsp;move&nbsp;paths&nbsp;`a.b.c`)
</c24><br/><ln>&nbsp;781</ln><a id="781">&nbsp;</a><c24>3.&nbsp;Cross-referenced&nbsp;with&nbsp;moves&nbsp;and&nbsp;assignments,&nbsp;so&nbsp;that&nbsp;we&nbsp;can
</c24><br/><ln>&nbsp;782</ln><a id="782">&nbsp;</a><c24>&nbsp;&nbsp;&nbsp;easily&nbsp;find&nbsp;all&nbsp;moves&nbsp;and&nbsp;assignments&nbsp;to&nbsp;a&nbsp;given&nbsp;path.
</c24><br/><ln>&nbsp;783</ln><a id="783">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;784</ln><a id="784">&nbsp;</a><c24>The&nbsp;mechanism&nbsp;that&nbsp;we&nbsp;use&nbsp;is&nbsp;to&nbsp;create&nbsp;a&nbsp;`MovePath`&nbsp;record&nbsp;for&nbsp;each
</c24><br/><ln>&nbsp;785</ln><a id="785">&nbsp;</a><c24>move&nbsp;path.&nbsp;These&nbsp;are&nbsp;arranged&nbsp;in&nbsp;an&nbsp;array&nbsp;and&nbsp;are&nbsp;referenced&nbsp;using
</c24><br/><ln>&nbsp;786</ln><a id="786">&nbsp;</a><c24>`MovePathIndex`&nbsp;values,&nbsp;which&nbsp;are&nbsp;newtype'd&nbsp;indices.&nbsp;The&nbsp;`MovePath`
</c24><br/><ln>&nbsp;787</ln><a id="787">&nbsp;</a><c24>structs&nbsp;are&nbsp;arranged&nbsp;into&nbsp;a&nbsp;tree,&nbsp;representing&nbsp;using&nbsp;the&nbsp;standard
</c24><br/><ln>&nbsp;788</ln><a id="788">&nbsp;</a><c24>Knuth&nbsp;representation&nbsp;where&nbsp;each&nbsp;node&nbsp;has&nbsp;a&nbsp;child&nbsp;'pointer'&nbsp;and&nbsp;a&nbsp;"next
</c24><br/><ln>&nbsp;789</ln><a id="789">&nbsp;</a><c24>sibling"&nbsp;'pointer'.&nbsp;In&nbsp;addition,&nbsp;each&nbsp;`MovePath`&nbsp;has&nbsp;a&nbsp;parent
</c24><br/><ln>&nbsp;790</ln><a id="790">&nbsp;</a><c24>'pointer'.&nbsp;&nbsp;In&nbsp;this&nbsp;case,&nbsp;the&nbsp;'pointers'&nbsp;are&nbsp;just&nbsp;`MovePathIndex`
</c24><br/><ln>&nbsp;791</ln><a id="791">&nbsp;</a><c24>values.
</c24><br/><ln>&nbsp;792</ln><a id="792">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;793</ln><a id="793">&nbsp;</a><c24>In&nbsp;this&nbsp;way,&nbsp;if&nbsp;we&nbsp;want&nbsp;to&nbsp;find&nbsp;all&nbsp;base&nbsp;paths&nbsp;of&nbsp;a&nbsp;given&nbsp;move&nbsp;path,
</c24><br/><ln>&nbsp;794</ln><a id="794">&nbsp;</a><c24>we&nbsp;can&nbsp;just&nbsp;iterate&nbsp;up&nbsp;the&nbsp;parent&nbsp;pointers&nbsp;(see&nbsp;`each_base_path()`&nbsp;in
</c24><br/><ln>&nbsp;795</ln><a id="795">&nbsp;</a><c24>the&nbsp;`move_data`&nbsp;module).&nbsp;If&nbsp;we&nbsp;want&nbsp;to&nbsp;find&nbsp;all&nbsp;extensions,&nbsp;we&nbsp;can
</c24><br/><ln>&nbsp;796</ln><a id="796">&nbsp;</a><c24>iterate&nbsp;through&nbsp;the&nbsp;subtree&nbsp;(see&nbsp;`each_extending_path()`).
</c24><br/><ln>&nbsp;797</ln><a id="797">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;798</ln><a id="798">&nbsp;</a><c24>###&nbsp;Moves&nbsp;and&nbsp;assignments
</c24><br/><ln>&nbsp;799</ln><a id="799">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;800</ln><a id="800">&nbsp;</a><c24>There&nbsp;are&nbsp;structs&nbsp;to&nbsp;represent&nbsp;moves&nbsp;(`Move`)&nbsp;and&nbsp;assignments
</c24><br/><ln>&nbsp;801</ln><a id="801">&nbsp;</a><c24>(`Assignment`),&nbsp;and&nbsp;these&nbsp;are&nbsp;also&nbsp;placed&nbsp;into&nbsp;arrays&nbsp;and&nbsp;referenced
</c24><br/><ln>&nbsp;802</ln><a id="802">&nbsp;</a><c24>by&nbsp;index.&nbsp;All&nbsp;moves&nbsp;of&nbsp;a&nbsp;particular&nbsp;path&nbsp;are&nbsp;arranged&nbsp;into&nbsp;a&nbsp;linked
</c24><br/><ln>&nbsp;803</ln><a id="803">&nbsp;</a><c24>lists,&nbsp;beginning&nbsp;with&nbsp;`MovePath.first_move`&nbsp;and&nbsp;continuing&nbsp;through
</c24><br/><ln>&nbsp;804</ln><a id="804">&nbsp;</a><c24>`Move.next_move`.
</c24><br/><ln>&nbsp;805</ln><a id="805">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;806</ln><a id="806">&nbsp;</a><c24>We&nbsp;distinguish&nbsp;between&nbsp;"var"&nbsp;assignments,&nbsp;which&nbsp;are&nbsp;assignments&nbsp;to&nbsp;a
</c24><br/><ln>&nbsp;807</ln><a id="807">&nbsp;</a><c24>variable&nbsp;like&nbsp;`x&nbsp;=&nbsp;foo`,&nbsp;and&nbsp;"path"&nbsp;assignments&nbsp;(`x.f&nbsp;=&nbsp;foo`).&nbsp;&nbsp;This
</c24><br/><ln>&nbsp;808</ln><a id="808">&nbsp;</a><c24>is&nbsp;because&nbsp;we&nbsp;need&nbsp;to&nbsp;assign&nbsp;dataflows&nbsp;to&nbsp;the&nbsp;former,&nbsp;but&nbsp;not&nbsp;the
</c24><br/><ln>&nbsp;809</ln><a id="809">&nbsp;</a><c24>latter,&nbsp;so&nbsp;as&nbsp;to&nbsp;check&nbsp;for&nbsp;double&nbsp;initialization&nbsp;of&nbsp;immutable
</c24><br/><ln>&nbsp;810</ln><a id="810">&nbsp;</a><c24>variables.
</c24><br/><ln>&nbsp;811</ln><a id="811">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;812</ln><a id="812">&nbsp;</a><c24>###&nbsp;Gathering&nbsp;and&nbsp;checking&nbsp;moves
</c24><br/><ln>&nbsp;813</ln><a id="813">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;814</ln><a id="814">&nbsp;</a><c24>Like&nbsp;loans,&nbsp;we&nbsp;distinguish&nbsp;two&nbsp;phases.&nbsp;The&nbsp;first,&nbsp;gathering,&nbsp;is&nbsp;where
</c24><br/><ln>&nbsp;815</ln><a id="815">&nbsp;</a><c24>we&nbsp;uncover&nbsp;all&nbsp;the&nbsp;moves&nbsp;and&nbsp;assignments.&nbsp;As&nbsp;with&nbsp;loans,&nbsp;we&nbsp;do&nbsp;some
</c24><br/><ln>&nbsp;816</ln><a id="816">&nbsp;</a><c24>basic&nbsp;sanity&nbsp;checking&nbsp;in&nbsp;this&nbsp;phase,&nbsp;so&nbsp;we'll&nbsp;report&nbsp;errors&nbsp;if&nbsp;you
</c24><br/><ln>&nbsp;817</ln><a id="817">&nbsp;</a><c24>attempt&nbsp;to&nbsp;move&nbsp;out&nbsp;of&nbsp;a&nbsp;borrowed&nbsp;pointer&nbsp;etc.&nbsp;Then&nbsp;we&nbsp;do&nbsp;the&nbsp;dataflow
</c24><br/><ln>&nbsp;818</ln><a id="818">&nbsp;</a><c24>(see&nbsp;`FlowedMoveData::new`).&nbsp;Finally,&nbsp;in&nbsp;the&nbsp;`check_loans.rs`&nbsp;code,&nbsp;we
</c24><br/><ln>&nbsp;819</ln><a id="819">&nbsp;</a><c24>walk&nbsp;back&nbsp;over,&nbsp;identify&nbsp;all&nbsp;uses,&nbsp;assignments,&nbsp;and&nbsp;captures,&nbsp;and
</c24><br/><ln>&nbsp;820</ln><a id="820">&nbsp;</a><c24>check&nbsp;that&nbsp;they&nbsp;are&nbsp;legal&nbsp;given&nbsp;the&nbsp;set&nbsp;of&nbsp;dataflow&nbsp;bits&nbsp;we&nbsp;have
</c24><br/><ln>&nbsp;821</ln><a id="821">&nbsp;</a><c24>computed&nbsp;for&nbsp;that&nbsp;program&nbsp;point.
</c24><br/><ln>&nbsp;822</ln><a id="822">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;823</ln><a id="823">&nbsp;</a><c24>#&nbsp;Future&nbsp;work
</c24><br/><ln>&nbsp;824</ln><a id="824">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;825</ln><a id="825">&nbsp;</a><c24>While&nbsp;writing&nbsp;up&nbsp;these&nbsp;docs,&nbsp;I&nbsp;encountered&nbsp;some&nbsp;rules&nbsp;I&nbsp;believe&nbsp;to&nbsp;be
</c24><br/><ln>&nbsp;826</ln><a id="826">&nbsp;</a><c24>stricter&nbsp;than&nbsp;necessary:
</c24><br/><ln>&nbsp;827</ln><a id="827">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;828</ln><a id="828">&nbsp;</a><c24>-&nbsp;I&nbsp;think&nbsp;the&nbsp;restriction&nbsp;against&nbsp;mutating&nbsp;`&amp;mut`&nbsp;pointers&nbsp;found&nbsp;in&nbsp;an
</c24><br/><ln>&nbsp;829</ln><a id="829">&nbsp;</a><c24>&nbsp;&nbsp;aliasable&nbsp;location&nbsp;is&nbsp;unnecessary.&nbsp;They&nbsp;cannot&nbsp;be&nbsp;reborrowed,&nbsp;to&nbsp;be&nbsp;sure,
</c24><br/><ln>&nbsp;830</ln><a id="830">&nbsp;</a><c24>&nbsp;&nbsp;so&nbsp;it&nbsp;should&nbsp;be&nbsp;safe&nbsp;to&nbsp;mutate&nbsp;them.&nbsp;Lifting&nbsp;this&nbsp;might&nbsp;cause&nbsp;some&nbsp;common
</c24><br/><ln>&nbsp;831</ln><a id="831">&nbsp;</a><c24>&nbsp;&nbsp;cases&nbsp;(`&amp;mut&nbsp;int`)&nbsp;to&nbsp;work&nbsp;just&nbsp;fine,&nbsp;but&nbsp;might&nbsp;lead&nbsp;to&nbsp;further&nbsp;confusion
</c24><br/><ln>&nbsp;832</ln><a id="832">&nbsp;</a><c24>&nbsp;&nbsp;in&nbsp;other&nbsp;cases,&nbsp;so&nbsp;maybe&nbsp;it's&nbsp;best&nbsp;to&nbsp;leave&nbsp;it&nbsp;as&nbsp;is.
</c24><br/><ln>&nbsp;833</ln><a id="833">&nbsp;</a><c24>-&nbsp;I&nbsp;think&nbsp;restricting&nbsp;the&nbsp;`&amp;mut`&nbsp;LV&nbsp;against&nbsp;moves&nbsp;and&nbsp;`ALIAS`&nbsp;is&nbsp;sufficient,
</c24><br/><ln>&nbsp;834</ln><a id="834">&nbsp;</a><c24>&nbsp;&nbsp;`MUTATE`&nbsp;and&nbsp;`CLAIM`&nbsp;are&nbsp;overkill.&nbsp;`MUTATE`&nbsp;was&nbsp;necessary&nbsp;when&nbsp;swap&nbsp;was
</c24><br/><ln>&nbsp;835</ln><a id="835">&nbsp;</a><c24>&nbsp;&nbsp;a&nbsp;built-in&nbsp;operator,&nbsp;but&nbsp;as&nbsp;it&nbsp;is&nbsp;not,&nbsp;it&nbsp;is&nbsp;implied&nbsp;by&nbsp;`CLAIM`,
</c24><br/><ln>&nbsp;836</ln><a id="836">&nbsp;</a><c24>&nbsp;&nbsp;and&nbsp;`CLAIM`&nbsp;is&nbsp;implied&nbsp;by&nbsp;`ALIAS`.&nbsp;The&nbsp;only&nbsp;net&nbsp;effect&nbsp;of&nbsp;this&nbsp;is&nbsp;an
</c24><br/><ln>&nbsp;837</ln><a id="837">&nbsp;</a><c24>&nbsp;&nbsp;extra&nbsp;error&nbsp;message&nbsp;in&nbsp;some&nbsp;cases,&nbsp;though.
</c24><br/><ln>&nbsp;838</ln><a id="838">&nbsp;</a><c24>-&nbsp;I&nbsp;have&nbsp;not&nbsp;described&nbsp;how&nbsp;closures&nbsp;interact.&nbsp;Current&nbsp;code&nbsp;is&nbsp;unsound.
</c24><br/><ln>&nbsp;839</ln><a id="839">&nbsp;</a><c24>&nbsp;&nbsp;I&nbsp;am&nbsp;working&nbsp;on&nbsp;describing&nbsp;and&nbsp;implementing&nbsp;the&nbsp;fix.
</c24><br/><ln>&nbsp;840</ln><a id="840">&nbsp;</a><c24>-&nbsp;If&nbsp;we&nbsp;wish,&nbsp;we&nbsp;can&nbsp;easily&nbsp;extend&nbsp;the&nbsp;move&nbsp;checking&nbsp;to&nbsp;allow&nbsp;finer-grained
</c24><br/><ln>&nbsp;841</ln><a id="841">&nbsp;</a><c24>&nbsp;&nbsp;tracking&nbsp;of&nbsp;what&nbsp;is&nbsp;initialized&nbsp;and&nbsp;what&nbsp;is&nbsp;not,&nbsp;enabling&nbsp;code&nbsp;like
</c24><br/><ln>&nbsp;842</ln><a id="842">&nbsp;</a><c24>&nbsp;&nbsp;this:
</c24><br/><ln>&nbsp;843</ln><a id="843">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;844</ln><a id="844">&nbsp;</a><c24>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a&nbsp;=&nbsp;x.f.g;&nbsp;//&nbsp;x.f.g&nbsp;is&nbsp;now&nbsp;uninitialized
</c24><br/><ln>&nbsp;845</ln><a id="845">&nbsp;</a><c24>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;here,&nbsp;x&nbsp;and&nbsp;x.f&nbsp;are&nbsp;not&nbsp;usable,&nbsp;but&nbsp;x.f.h&nbsp;*is*
</c24><br/><ln>&nbsp;846</ln><a id="846">&nbsp;</a><c24>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x.f.g&nbsp;=&nbsp;b;&nbsp;//&nbsp;x.f.g&nbsp;is&nbsp;not&nbsp;initialized
</c24><br/><ln>&nbsp;847</ln><a id="847">&nbsp;</a><c24>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;now&nbsp;x,&nbsp;x.f,&nbsp;x.f.g,&nbsp;x.f.h&nbsp;are&nbsp;all&nbsp;usable
</c24><br/><ln>&nbsp;848</ln><a id="848">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;849</ln><a id="849">&nbsp;</a><c24>&nbsp;&nbsp;What&nbsp;needs&nbsp;to&nbsp;change&nbsp;here,&nbsp;most&nbsp;likely,&nbsp;is&nbsp;that&nbsp;the&nbsp;`moves`&nbsp;module
</c24><br/><ln>&nbsp;850</ln><a id="850">&nbsp;</a><c24>&nbsp;&nbsp;should&nbsp;record&nbsp;not&nbsp;only&nbsp;what&nbsp;paths&nbsp;are&nbsp;moved,&nbsp;but&nbsp;what&nbsp;expressions
</c24><br/><ln>&nbsp;851</ln><a id="851">&nbsp;</a><c24>&nbsp;&nbsp;are&nbsp;actual&nbsp;*uses*.&nbsp;For&nbsp;example,&nbsp;the&nbsp;reference&nbsp;to&nbsp;`x`&nbsp;in&nbsp;`x.f.g&nbsp;=&nbsp;b`
</c24><br/><ln>&nbsp;852</ln><a id="852">&nbsp;</a><c24>&nbsp;&nbsp;is&nbsp;not&nbsp;a&nbsp;true&nbsp;*use*&nbsp;in&nbsp;the&nbsp;sense&nbsp;that&nbsp;it&nbsp;requires&nbsp;`x`&nbsp;to&nbsp;be&nbsp;fully
</c24><br/><ln>&nbsp;853</ln><a id="853">&nbsp;</a><c24>&nbsp;&nbsp;initialized.&nbsp;This&nbsp;is&nbsp;in&nbsp;fact&nbsp;why&nbsp;the&nbsp;above&nbsp;code&nbsp;produces&nbsp;an&nbsp;error
</c24><br/><ln>&nbsp;854</ln><a id="854">&nbsp;</a><c24>&nbsp;&nbsp;today:&nbsp;the&nbsp;reference&nbsp;to&nbsp;`x`&nbsp;in&nbsp;`x.f.g&nbsp;=&nbsp;b`&nbsp;is&nbsp;considered&nbsp;illegal
</c24><br/><ln>&nbsp;855</ln><a id="855">&nbsp;</a><c24>&nbsp;&nbsp;because&nbsp;`x`&nbsp;is&nbsp;not&nbsp;fully&nbsp;initialized.
</c24><br/><ln>&nbsp;856</ln><a id="856">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;857</ln><a id="857">&nbsp;</a><c24>There&nbsp;are&nbsp;also&nbsp;some&nbsp;possible&nbsp;refactorings:
</c24><br/><ln>&nbsp;858</ln><a id="858">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;859</ln><a id="859">&nbsp;</a><c24>-&nbsp;It&nbsp;might&nbsp;be&nbsp;nice&nbsp;to&nbsp;replace&nbsp;all&nbsp;loan&nbsp;paths&nbsp;with&nbsp;the&nbsp;MovePath&nbsp;mechanism,
</c24><br/><ln>&nbsp;860</ln><a id="860">&nbsp;</a><c24>&nbsp;&nbsp;since&nbsp;they&nbsp;allow&nbsp;lightweight&nbsp;comparison&nbsp;using&nbsp;an&nbsp;integer.
</c24><br/><ln>&nbsp;861</ln><a id="861">&nbsp;</a><c0>
</c0><br/><ln>&nbsp;862</ln><a id="862">&nbsp;</a><c24>*/
</c24><br/><div/></c0></c0>